#+PROPERTY: header-args:jupyter-python  :session aoc-2015 :kernel aoc
#+PROPERTY: header-args    :pandoc t

* Imports
#+begin_src jupyter-python
  import pandas as pd
  import numpy as np
  from collections import defaultdict
  from pathlib import Path
  import functools
  import itertools
  import more_itertools
  import re
  datadir = Path("data/2015")
#+end_src

* Day 1
[[https://adventofcode.com/2015/day/1][Not Quite Lisp]]

** Part 1
#+begin_src jupyter-python
  line = open(datadir / "1.txt", encoding="utf8").readline()
  line.count("(") - line.count(")")
#+end_src

** Part 2
#+begin_src jupyter-python
  position = 0
  for idx, character in enumerate(line):
      position = position + (1 if character == "(" else -1)
      if position < 0:
          break
  idx + 1
#+end_src

* Day 2
[[https://adventofcode.com/2015/day/2][I Was Told There Would Be No Math]]
** Part 1
#+begin_src jupyter-python
with open(datadir / '2.txt') as f:
    boxes = [[int(x) for x in y.split('x')] for y in f.readlines()]
sum([(3*x*y + 2*x*z + 2*y*z) for x,y,z in map(sorted, boxes)])
#+end_src

** Part 2
#+begin_src jupyter-python
sum([ x * y * z + 2 * (x + y) for x,y,z in map(sorted, boxes)])
#+end_src

* Day 3
[[https://adventofcode.com/2015/day/3][Perfectly Spherical Houses in a Vacuum]]
** Part 1
#+begin_src jupyter-python
  instructions = open(datadir / "3.txt", encoding="utf8").readline().strip()
  commands = {"^": lambda x, y: (x, y + 1), "v": lambda x, y: (x, y - 1),
              ">": lambda x, y: (x + 1, y), "<": lambda x, y: (x - 1, y),}

  def execute_instructions(instructions, houses=None):
      position = 0, 0
      if houses is None:
          houses = {(0, 0): 1}
      for instruction in instructions:
          position = commands[instruction](*position)
          houses[position] = 1
      return houses

  len(execute_instructions(instructions))
#+end_src

** Part 2
#+begin_src jupyter-python
  houses = execute_instructions(instructions[::2])
  len(execute_instructions(instructions[1::2], houses))
#+end_src

* Day 4
[[https://adventofcode.com/2015/day/4][The Ideal Stocking Stuffer]]
** Part 1
#+begin_src jupyter-python
  import hashlib
  h = hashlib.md5()
  prefix = "iwrupvqb"
  def brute_force(n):
      i = 0
      while i := i + 1:
          md5 = hashlib.md5((prefix + str(i)).encode(encoding="UTF-8")).hexdigest()
          if md5[:n] == n * "0":
              return i
  brute_force(5)
#+end_src

** Part 2
#+begin_src jupyter-python
  brute_force(6)
#+end_src

* Day 5
[[https://adventofcode.com/2015/day/5][Doesn't He Have Intern-Elves For This?]]
** Part 1
#+begin_src jupyter-python
  def is_nice(s):
      sufficient_vowels = len(re.findall("[aeiou]", s)) >= 3
      contains_double = (np.array(list(s))[1:] == np.roll(list(s), 1)[1:]).any()
      contains_forbidden = any(val in s for val in ["ab", "cd", "pq", "xy"])
      return sufficient_vowels and contains_double and not contains_forbidden
  sum(is_nice(x) for x in open(datadir / "5.txt").readlines())
#+end_src

** Part 2
#+begin_src jupyter-python
  def is_nice(s):
      contains_double = (np.array(list(s))[2:] == np.roll(list(s), 2)[2:]).any()
      contains_double_pair = bool(re.findall("(..).*\\1", s))
      return contains_double and contains_double_pair
  sum(is_nice(x) for x in open(datadir / "5.txt").readlines())
#+end_src

* Day 6
[[https://adventofcode.com/2015/day/6][Probably a Fire Hazard]]
** Part 1
#+begin_src jupyter-python
  lines = open(datadir / "6.txt").readlines()
  numbers = [[int(x) for x in re.findall("\d+", line)] for line in lines]
  instructions = [line.replace("turn ", "").split()[0] for line in lines]
  field = np.zeros([1000, 1000], dtype=int)
  for (x1, y1, x2, y2), instruction in zip(numbers, instructions):
      if instruction == "toggle":
          field[x1:x2 + 1, y1:y2 + 1] ^= 1
      else:
          field[x1:x2 + 1, y1:y2 + 1] = int(instruction == "on")
  field.sum()
#+end_src

** Part 2
#+begin_src jupyter-python
  field = np.zeros([1000, 1000], dtype=int)
  for (x1, y1, x2, y2), instruction in zip(numbers, instructions):
      if instruction == "toggle":
          field[x1:x2 + 1, y1:y2 + 1] += 2
      else:
          field[x1:x2 + 1, y1:y2 + 1] += 2 * int(instruction == "on") - 1
      field[np.where(field < 0)] = 0
  field.sum()
#+end_src

* Day 7
[[https://adventofcode.com/2015/day/7][Some Assembly Required]]
** Part 1
#+begin_src jupyter-python
  lines = open(datadir / "7.txt").readlines()
  circuit = {target: source for source, target in map(lambda x: x.strip().split(" -> "), lines)}
  binops = {"AND": lambda x, y: x & y,
            "OR": lambda x, y: x | y,
            "LSHIFT": lambda x, y: x << y,
            "RSHIFT": lambda x, y: x >> y}

  @functools.cache
  def evaluate(symbol):
      try:
          result = int(symbol)
          return result
      except ValueError:
          pass
      operation = circuit[symbol].split()
      if len(operation) == 1:
          return evaluate(operation[0])
      elif len(operation) == 2:
          return evaluate(operation[1]) ^ (2**16 - 1)
      else:
          arg1, op, arg2 = operation
          return binops[op](evaluate(arg1), evaluate(arg2))
  evaluate("a")
#+end_src

** Part 2
We can reset everything by clearing out the cache, and setting a wire to a specific value (or expression) can be accomplished by modifying the circuit.

That gives
#+begin_src jupyter-python
  evaluate.cache_clear()
  circuit["b"] = str(evaluate("a"))
  evaluate("a")
#+end_src

* Day 8
[[https://adventofcode.com/2015/day/8][Matchsticks]]
** Part 1
#+begin_src jupyter-python
  lines = [x[:-1] for x in open(datadir / "8.txt").readlines()]
  sum(len(line) - len(eval(line)) for line in lines)
#+end_src

** Part 2
#+begin_src jupyter-python
  sum(2 + len([x for x in line if x in ["\"", "\\"]]) for line in lines)
#+end_src

* Day 9
[[https://adventofcode.com/2015/day/9][All in a Single Night]]
** Part 1
#+begin_src jupyter-python
  d = {}
  data = [x.split() for x in open(datadir / "9.txt").readlines()]
  for source, _, destination, __, distance in data:
      d[(source, destination)] = int(distance)
      d[(destination, source)] = int(distance)
  cities = set(x[0] for x in d.keys())
  tours = [sum(d[route[start], route[start + 1]] for start in range(len(cities) - 1))
           for route in itertools.permutations(cities)]
  min(tours)
#+end_src

** Part 2
#+begin_src jupyter-python
  max(tours)
#+end_src

* Day 10
[[https://adventofcode.com/2015/day/10][Elves Look, Elves Say]]
** Part 1
#+begin_src jupyter-python
  message = "3113322113"
  regex = re.compile(r"(([123])\2*)")
  for _ in range(40):
      runs = re.findall(regex, message)
      message = ''.join([str(len(run)) + run[0] for run in map(lambda x: x[0], runs)])
  len(message)
#+end_src

** Part 2
#+begin_src jupyter-python
  for _ in range(10):
      runs = re.findall(regex, message)
      message = ''.join([str(len(run)) + run[0] for run in map(lambda x: x[0], runs)])
  len(message)

#+end_src

* Day 11

[[https://adventofcode.com/2015/day/11][Corporate Policy]]

** Part 1
So there are two jobs here:

1. Determine whether a candidate password is valid
2. Iterate over candidate passwords in order, starting with the puzzle input

Is valid is not too difficult to accomplish. The "straight" condition can be rewritten as "1, 1" appears somewhere in the list of differences between neighboring characters. The "double pair" condition can be shortly expressed as matching a simple regex. Forbidding certain characters outright is most easily accomplished by never generating them as candidates

To iterate over candidate passwords, we first construct a helper method to iterate over candidate passwords that keep some prefix string fixed. The full iterator is then a chain over all these with successively shorter prefix strings.

#+begin_src jupyter-python
  def has_straight(password):
      if isinstance(password, str):
          password = np.array([ord(x) for x in password], dtype=int)
      differences = np.diff(password)
      return (1, 1) in zip(differences, differences[1:])


  r = re.compile(r"(.)\1.*(.)\2")
  def has_double_pair(password):
      return bool(re.search(r, "".join(chr(x) for x in password)))

  def is_valid_password(password):
      return has_double_pair(password) and has_straight(password)

  puzzle_input = tuple(ord(x) for x in "hxbxwxba")
  password = puzzle_input
  characters = tuple(ord(x) for x in "abcdefghjkmnpqrstuvwxyz")

  def iterate(string, prefix_length):
      n_free = len(string) - prefix_length - 1
      first = characters[characters.index(string[prefix_length]) + 1:]

      suffixes = itertools.product(first, *([characters]*n_free))
      for suffix in suffixes:
          yield string[:prefix_length] + suffix

  password_iterator = itertools.chain.from_iterable([iterate(password, l) for l in range(len(password))][::-1])
  while not is_valid_password(password):
      password = next(password_iterator)
  print("".join(chr(x) for x in password))
#+end_src

** Part 2
#+begin_src jupyter-python
  password = next(password_iterator)
  while not is_valid_password(password):
      password = next(password_iterator)
  print("".join(chr(x) for x in password))

#+end_src

* Day 12
[[https://adventofcode.com/2015/day/12][JSAbacusFramework.io]]
** Part 1
For the first part, we've been promised that integers only appear as integers. So there's no reason to try and read in the json properly - a simple regex does the trick
#+begin_src jupyter-python
  s = open(datadir / "12.txt").read()
  integers = re.findall("-?\d+", f.read())
  sum(map(int, integers))
#+end_src

** Part 2
That approach obviously doesn't work for the second part, so we'll need a json library
#+begin_src jupyter-python
  import json
  s = json.load(open(datadir / "12.txt"))
  def find_value(structure):
      if isinstance(structure, str):
          return 0
      if isinstance(structure, int):
          return structure
      if isinstance(structure, list):
          return(sum(find_value(x) for x in structure))
      if "red" in structure.values():
          return 0
      return sum(find_value(x) for x in structure.values())
  find_value(s)
#+end_src

* Day 13
[[https://adventofcode.com/2015/day/13][Knights of the Dinner Table]]
** Part 1
#+begin_src jupyter-python
  data = open(datadir / "13.txt").readlines()
  def parse(line):
      words = line.strip().split()
      people = tuple(sorted([words[0], words[-1][:-1]]))
      amount = int(re.search("(\d+)", line).groups(0)[0])
      sign = 2 * ("gain" in words) - 1
      return people, amount * sign
  scores = defaultdict(int)
  with open(datadir / "13.txt") as f:
      for line in f:
          people, score = parse(line)
          scores[people] += score

  people = sorted(set([person for pair in scores.keys() for person in pair]))
  def calculate_score(permutation):
      score = 0
      n = len(permutation)
      for i in range(n):
          score += scores[tuple(sorted([permutation[i], permutation[(i + 1) % n]]))]
      return score
  maxval = 0
  for permutation in itertools.permutations(people[1:]):
      score = calculate_score((people[0],) + permutation)
      if score > maxval:
          maxval = score
  maxval
#+end_src

** Part 2
Here we see the magic of the defaultdict - since all of the pairs involving "You" have a net score of zero, we don't need to change the scoring dictionary at all. We just add "You" to the people we are permuting over, and run everything exactly as before.
#+begin_src jupyter-python
  maxval = 0
  for permutation in itertools.permutations(people[1:] + ["You"]):
      score = calculate_score((people[0],) + permutation)
      if score > maxval:
          maxval = score
  maxval
#+end_src

* Day 14
[[https://adventofcode.com/2015/day/14][Reindeer Olympics]]
** Part 1
#+begin_src jupyter-python
  data = open(datadir / "14.txt").readlines()
  reindeer = [list(map(int, re.findall("-?\d+", line))) for line in data]
  def score(time, speed, on, off):
      cycle_length = on + off
      n_cycles = time // (cycle_length)
      offset = min(on, n_cycles % cycle_length)
      return speed * (n_cycles * on + offset)
  max(map(lambda x: score(2503, *x), reindeer))
#+end_src
** Part 2
#+begin_src jupyter-python
  wins = np.zeros(len(numbers))
  positions = np.zeros(len(numbers))
  for i in range(2503):
      for idx, (speed, on, off) in enumerate(reindeer):
          cycle_length = on + off
          if i % cycle_length < on:
              positions[idx] += speed
      wins += (positions == max(positions))
  max(wins)
#+end_src

* Day 15
[[https://adventofcode.com/2015/day/15][Science for Hungry People]]

** Part 1
#+begin_src jupyter-python
  data = open(datadir / "15.txt").readlines()
  data = np.array([[int(x) for x in re.findall("-?\d+", line)] for line in data]).T
#+end_src

Since each of the values has to be positive, we can derive some constraints on how much of each ingredient we can use. We know there are 100 of each in total, so letting the four variables be $w, x, y, z$, we have $w + x + y + z = 100$. Additionally, since only one ingredient contributes a positive value to any given quantitity we have to use at least one of each. With that out of the way we can use the matrix to set up the following system of inequalities:


\begin{align*}
 3w - 3x - y &> 0 \\
 4y - 3z &> 0 \\
 -3w + 2z &> 0
\end{align*}

From that we can derive the following bounds for the amount of each ingredient

\begin{align*}
1 &\leq w\leq 39\\
1 &\leq x\leq 39\\
1 &\leq y\leq 72\\
1 &\leq z\leq 65
\end{align*}

For example, the upper bound on $w$ follows from the last inequality, which implies that $z > 1.5 w$. The one on $x$ comes from the first inequality, which implies that $x < w$.

The last thing to consider is that once three of the values are fixed, the fourth is known. Together, these optimizations let us reduce the cases we have to consider from 1 million to less than 50k.
#+begin_src jupyter-python

  initial_bounds = [[1, 39 + 1], [1, 39 + 1], [1, 72 + 1], [1, 65 + 1]]
  def calculate(part=1):
      maxval = 0
      for w in range(*initial_bounds[0]):
          for x in range(1, w):
              left, right = initial_bounds[2]
              new_y = 3 * (w - x)
              for y in range(left, min(right, new_y)):
                  z = 100 - x - y - w
                  score = (data @ (w, x, y, z))
                  if (score <= 0).any() or (part == 2 and (score[-1] != 500)):
                      continue
                  val = np.product(score[:-1])
                  if val > maxval:
                      maxval = val
      return maxval
  calculate()
#+end_src

** Part 2
#+begin_src jupyter-python
  calculate(2)
#+end_src
