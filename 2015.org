#+PROPERTY: header-args:jupyter-python  :session aoc-2015 :kernel aoc
#+PROPERTY: header-args    :pandoc t

* Imports
#+begin_src jupyter-python
  import pandas as pd
  import numpy as np
  from collections import defaultdict
  from pathlib import Path
  import functools
  import itertools
  import more_itertools
  import re
  import scipy
  from utils import year_load
  load = year_load(2015)
#+end_src

* Day 1
[[https://adventofcode.com/2015/day/1][Not Quite Lisp]]

** Part 1
#+begin_src jupyter-python
  line = load(1)[0]
  line.count("(") - line.count(")")
#+end_src

** Part 2
#+begin_src jupyter-python
  position = 0
  for idx, character in enumerate(line):
      position = position + (1 if character == "(" else -1)
      if position < 0:
          break
  idx + 1
#+end_src

* Day 2
[[https://adventofcode.com/2015/day/2][I Was Told There Would Be No Math]]
** Part 1
#+begin_src jupyter-python
  data = load(2)
  boxes = [[int(x) for x in line.split('x')] for line in data]
  sum([(3*x*y + 2*x*z + 2*y*z) for x,y,z in map(sorted, boxes)])
#+end_src

** Part 2
#+begin_src jupyter-python
sum([ x * y * z + 2 * (x + y) for x,y,z in map(sorted, boxes)])
#+end_src

* Day 3
[[https://adventofcode.com/2015/day/3][Perfectly Spherical Houses in a Vacuum]]
** Part 1
#+begin_src jupyter-python
  instructions = load(3)[0].strip()
  commands = {"^": lambda x, y: (x, y + 1), "v": lambda x, y: (x, y - 1),
              ">": lambda x, y: (x + 1, y), "<": lambda x, y: (x - 1, y),}

  def execute_instructions(instructions, houses=None):
      position = 0, 0
      if houses is None:
          houses = {(0, 0): 1}
      for instruction in instructions:
          position = commands[instruction](*position)
          houses[position] = 1
      return houses

  len(execute_instructions(instructions))
#+end_src

** Part 2
#+begin_src jupyter-python
  houses = execute_instructions(instructions[::2])
  len(execute_instructions(instructions[1::2], houses))
#+end_src

* Day 4
[[https://adventofcode.com/2015/day/4][The Ideal Stocking Stuffer]]
** Part 1
#+begin_src jupyter-python
  import hashlib
  h = hashlib.md5()
  prefix = "iwrupvqb"
  def brute_force(n):
      i = 0
      while i := i + 1:
          md5 = hashlib.md5((prefix + str(i)).encode(encoding="UTF-8")).hexdigest()
          if md5[:n] == n * "0":
              return i
  brute_force(5)
#+end_src

** Part 2
#+begin_src jupyter-python
  brute_force(6)
#+end_src

* Day 5
[[https://adventofcode.com/2015/day/5][Doesn't He Have Intern-Elves For This?]]
** Part 1
#+begin_src jupyter-python
  def is_nice(s):
      sufficient_vowels = len(re.findall("[aeiou]", s)) >= 3
      contains_double = (np.array(list(s))[1:] == np.roll(list(s), 1)[1:]).any()
      contains_forbidden = any(val in s for val in ["ab", "cd", "pq", "xy"])
      return sufficient_vowels and contains_double and not contains_forbidden
  sum(is_nice(x) for x in load(5))
#+end_src

** Part 2
#+begin_src jupyter-python
  def is_nice(s):
      contains_double = (np.array(list(s))[2:] == np.roll(list(s), 2)[2:]).any()
      contains_double_pair = bool(re.findall("(..).*\\1", s))
      return contains_double and contains_double_pair
  sum(is_nice(x) for x in load(5))
#+end_src

* Day 6
[[https://adventofcode.com/2015/day/6][Probably a Fire Hazard]]
** Part 1
#+begin_src jupyter-python
  lines = load(6)
  numbers = [[int(x) for x in re.findall("\d+", line)] for line in lines]
  instructions = [line.replace("turn ", "").split()[0] for line in lines]
  field = np.zeros([1000, 1000], dtype=int)
  for (x1, y1, x2, y2), instruction in zip(numbers, instructions):
      if instruction == "toggle":
          field[x1:x2 + 1, y1:y2 + 1] ^= 1
      else:
          field[x1:x2 + 1, y1:y2 + 1] = int(instruction == "on")
  field.sum()
#+end_src

** Part 2
#+begin_src jupyter-python
  field = np.zeros([1000, 1000], dtype=int)
  for (x1, y1, x2, y2), instruction in zip(numbers, instructions):
      if instruction == "toggle":
          field[x1:x2 + 1, y1:y2 + 1] += 2
      else:
          field[x1:x2 + 1, y1:y2 + 1] += 2 * int(instruction == "on") - 1
      field[np.where(field < 0)] = 0
  field.sum()
#+end_src

* Day 7
[[https://adventofcode.com/2015/day/7][Some Assembly Required]]
** Part 1
#+begin_src jupyter-python
  lines = load(7)
  circuit = {target: source for source, target in map(lambda x: x.strip().split(" -> "), lines)}
  binops = {"AND": lambda x, y: x & y,
            "OR": lambda x, y: x | y,
            "LSHIFT": lambda x, y: x << y,
            "RSHIFT": lambda x, y: x >> y}

  @functools.cache
  def evaluate(symbol):
      try:
          result = int(symbol)
          return result
      except ValueError:
          pass
      operation = circuit[symbol].split()
      if len(operation) == 1:
          return evaluate(operation[0])
      elif len(operation) == 2:
          return evaluate(operation[1]) ^ (2**16 - 1)
      else:
          arg1, op, arg2 = operation
          return binops[op](evaluate(arg1), evaluate(arg2))
  evaluate("a")
#+end_src

** Part 2
We can reset everything by clearing out the cache, and setting a wire to a specific value (or expression) can be accomplished by modifying the circuit.

That gives
#+begin_src jupyter-python
  evaluate.cache_clear()
  circuit["b"] = str(evaluate("a"))
  evaluate("a")
#+end_src

* Day 8
[[https://adventofcode.com/2015/day/8][Matchsticks]]
** Part 1
#+begin_src jupyter-python
  lines = [x[:-1] for x load(8)]
  sum(len(line) - len(eval(line)) for line in lines)
#+end_src

** Part 2
#+begin_src jupyter-python
  sum(2 + len([x for x in line if x in ["\"", "\\"]]) for line in lines)
#+end_src

* Day 9
[[https://adventofcode.com/2015/day/9][All in a Single Night]]
** Part 1
#+begin_src jupyter-python
  d = {}
  data = [x.split() for x in load(9)]
  for source, _, destination, __, distance in data:
      d[(source, destination)] = int(distance)
      d[(destination, source)] = int(distance)
  cities = set(x[0] for x in d.keys())
  tours = [sum(d[route[start], route[start + 1]] for start in range(len(cities) - 1))
           for route in itertools.permutations(cities)]
  min(tours)
#+end_src

** Part 2
#+begin_src jupyter-python
  max(tours)
#+end_src

* Day 10
[[https://adventofcode.com/2015/day/10][Elves Look, Elves Say]]
** Part 1
#+begin_src jupyter-python
  message = "3113322113"
  regex = re.compile(r"(([123])\2*)")
  for _ in range(40):
      runs = re.findall(regex, message)
      message = ''.join([str(len(run)) + run[0] for run in map(lambda x: x[0], runs)])
  len(message)
#+end_src

** Part 2
#+begin_src jupyter-python
  for _ in range(10):
      runs = re.findall(regex, message)
      message = ''.join([str(len(run)) + run[0] for run in map(lambda x: x[0], runs)])
  len(message)

#+end_src

* Day 11

[[https://adventofcode.com/2015/day/11][Corporate Policy]]

** Part 1
So there are two jobs here:

1. Determine whether a candidate password is valid
2. Iterate over candidate passwords in order, starting with the puzzle input

Is valid is not too difficult to accomplish. The "straight" condition can be rewritten as "1, 1" appears somewhere in the list of differences between neighboring characters. The "double pair" condition can be shortly expressed as matching a simple regex. Forbidding certain characters outright is most easily accomplished by never generating them as candidates

To iterate over candidate passwords, we first construct a helper method to iterate over candidate passwords that keep some prefix string fixed. The full iterator is then a chain over all these with successively shorter prefix strings.

#+begin_src jupyter-python
  def has_straight(password):
      if isinstance(password, str):
          password = np.array([ord(x) for x in password], dtype=int)
      differences = np.diff(password)
      return (1, 1) in zip(differences, differences[1:])


  r = re.compile(r"(.)\1.*(.)\2")
  def has_double_pair(password):
      return bool(re.search(r, "".join(chr(x) for x in password)))

  def is_valid_password(password):
      return has_double_pair(password) and has_straight(password)

  puzzle_input = tuple(ord(x) for x in "hxbxwxba")
  password = puzzle_input
  characters = tuple(ord(x) for x in "abcdefghjkmnpqrstuvwxyz")

  def iterate(string, prefix_length):
      n_free = len(string) - prefix_length - 1
      first = characters[characters.index(string[prefix_length]) + 1:]

      suffixes = itertools.product(first, *([characters]*n_free))
      for suffix in suffixes:
          yield string[:prefix_length] + suffix

  password_iterator = itertools.chain.from_iterable([iterate(password, l) for l in range(len(password))][::-1])
  while not is_valid_password(password):
      password = next(password_iterator)
  print("".join(chr(x) for x in password))
#+end_src

** Part 2
#+begin_src jupyter-python
  password = next(password_iterator)
  while not is_valid_password(password):
      password = next(password_iterator)
  print("".join(chr(x) for x in password))

#+end_src

* Day 12
[[https://adventofcode.com/2015/day/12][JSAbacusFramework.io]]
** Part 1
For the first part, we've been promised that integers only appear as integers. So there's no reason to try and read in the json properly - a simple regex does the trick
#+begin_src jupyter-python
  s = load(12, "int")
  sum([n for line in s for n in line])
#+end_src

** Part 2
That approach obviously doesn't work for the second part, so we'll need a json library
#+begin_src jupyter-python
  import json
  s = json.loads(load(12, "raw"))
  def find_value(structure):
      if isinstance(structure, str):
          return 0
      if isinstance(structure, int):
          return structure
      if isinstance(structure, list):
          return(sum(find_value(x) for x in structure))
      if "red" in structure.values():
          return 0
      return sum(find_value(x) for x in structure.values())
  find_value(s)
#+end_src


* Day 13
[[https://adventofcode.com/2015/day/13][Knights of the Dinner Table]]
** Part 1
#+begin_src jupyter-python
  data = load(13)
  def parse(line):
      words = line.strip().split()
      people = tuple(sorted([words[0], words[-1][:-1]]))
      amount = int(re.search("(\d+)", line).groups(0)[0])
      sign = 2 * ("gain" in words) - 1
      return people, amount * sign
  scores = defaultdict(int)
  for line in load(13):
      people, score = parse(line)
      scores[people] += score

  people = sorted(set([person for pair in scores.keys() for person in pair]))
  def calculate_score(permutation):
      score = 0
      n = len(permutation)
      for i in range(n):
          score += scores[tuple(sorted([permutation[i], permutation[(i + 1) % n]]))]
      return score
  maxval = 0
  for permutation in itertools.permutations(people[1:]):
      score = calculate_score((people[0],) + permutation)
      if score > maxval:
          maxval = score
  maxval
#+end_src

** Part 2
Here we see the magic of the defaultdict - since all of the pairs involving "You" have a net score of zero, we don't need to change the scoring dictionary at all. We just add "You" to the people we are permuting over, and run everything exactly as before.
#+begin_src jupyter-python
  maxval = 0
  for permutation in itertools.permutations(people[1:] + ["You"]):
      score = calculate_score((people[0],) + permutation)
      if score > maxval:
          maxval = score
  maxval
#+end_src

* Day 14
[[https://adventofcode.com/2015/day/14][Reindeer Olympics]]
** Part 1
#+begin_src jupyter-python
  reindeer = load(14, "int")
  def score(time, speed, on, off):
      cycle_length = on + off
      n_cycles = time // (cycle_length)
      offset = min(on, n_cycles % cycle_length)
      return speed * (n_cycles * on + offset)
  max(map(lambda x: score(2503, *x), reindeer))
#+end_src
** Part 2
#+begin_src jupyter-python
  wins = np.zeros(len(numbers))
  positions = np.zeros(len(numbers))
  for i in range(2503):
      for idx, (speed, on, off) in enumerate(reindeer):
          cycle_length = on + off
          if i % cycle_length < on:
              positions[idx] += speed
      wins += (positions == max(positions))
  max(wins)
#+end_src

* Day 15
[[https://adventofcode.com/2015/day/15][Science for Hungry People]]

** Part 1
Since each of the values has to be positive, we can derive some constraints on how much of each ingredient we can use. We know there are 100 of each in total, so letting the four variables be $w, x, y, z$, we have $w + x + y + z = 100$. Additionally, since only one ingredient contributes a positive value to any given quantitity we have to use at least one of each. With that out of the way we can use the matrix to set up the following system of inequalities:


\begin{align*}
 3w - 3x - y &> 0 \\
 4y - 3z &> 0 \\
 -3w + 2z &> 0
\end{align*}

From that we can derive the following bounds for the amount of each ingredient

\begin{align*}
1 &\leq w\leq 39\\
1 &\leq x\leq 39\\
1 &\leq y\leq 72\\
1 &\leq z\leq 65
\end{align*}

For example, the upper bound on $w$ follows from the last inequality, which implies that $z > 1.5 w$. The one on $x$ comes from the first inequality, which implies that $x < w$.

The last thing to consider is that once three of the values are fixed, the fourth is known. Together, these optimizations let us reduce the cases we have to consider from 1 million to less than 50k.
#+begin_src jupyter-python
  data = np.array(load(15, "int")).T
  initial_bounds = [[1, 39 + 1], [1, 39 + 1], [1, 72 + 1], [1, 65 + 1]]
  def calculate(part=1):
      maxval = 0
      for w in range(*initial_bounds[0]):
          for x in range(1, w):
              left, right = initial_bounds[2]
              new_y = 3 * (w - x)
              for y in range(left, min(right, new_y)):
                  z = 100 - x - y - w
                  score = (data @ (w, x, y, z))
                  if (score <= 0).any() or (part == 2 and (score[-1] != 500)):
                      continue
                  val = np.product(score[:-1])
                  if val > maxval:
                      maxval = val
      return maxval
  calculate()
#+end_src

** Part 2
#+begin_src jupyter-python
  calculate(2)
#+end_src

* Day 16
[[https://adventofcode.com/2015/day/16][Aunt Sue]]
** Part 1
#+begin_src jupyter-python
  data = load(16)
  sues = {}
  for line in data:
      sep = line.index(":")
      sue, info = line[:sep], line[sep + 1:]
      sues[int(sue.split()[1])] = {k: int(v) for k, v in
                                   map(lambda x: x.split(": "), info.strip().split(", "))}
  match = {"children": 3,
           "cats": 7,
           "samoyeds": 2,
           "pomeranians": 3,
           "akitas": 0,
           "vizslas": 0,
           "goldfish": 5,
           "trees": 3,
           "cars": 2,
           "perfumes": 1}
  for sue in sues:
      comparison = sues[sue]
      for key in match:
          if key not in comparison:
              continue
          if match[key] != comparison[key]:
              break
      else:
          print(sue)
          break
#+end_src
** Part 2
#+begin_src jupyter-python
  for sue in sues:
      comparison = sues[sue]
      for key in match:
          if key not in comparison:
              continue
          f = lambda known, measured: known == measured
          if key in ["cats", "trees"]:
              f = lambda known, measured: measured > known
          elif key in ["pomeranians", "goldfish"]:
              f = lambda known, measured: measured < known
          if not f(match[key], comparison[key]):
              break
      else:
          print(sue)
          break

#+end_src
* Day 17
[[https://adventofcode.com/2015/day/17][No Such Thing as Too Much]]
** Part 1
#+begin_src jupyter-python
  def count(value, containers):
      if value == 0:
          return 1
      if value < 0 or len(containers) == 0:
          return 0
      return count(value - containers[0], containers[1:]) + count(value, containers[1:])
  count(150, load(17, "np"))
#+end_src
** Part 2
#+begin_src jupyter-python
  def count(value, containers):
      result = defaultdict(int)
      def inner(value, containers, depth):
          if value == 0:
              result[depth] += 1
              return
          if value < 0 or len(containers) == 0:
              return
          inner(value - containers[0], containers[1:], depth + 1)
          inner(value, containers[1:], depth)
      inner(value, containers, 0)
      return result
  result = count(150, load(17, "np"))
  result[min(result.keys())]
#+end_src

* Day 18
[[https://adventofcode.com/2015/day/18][Like a GIF For Your Yard]]
** Part 1
#+begin_src jupyter-python
  weights = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
  initial_board = np.array([[0 if char == "." else 1 for char in line.strip()]
                            for line in load(18)])
  board = initial_board.copy()
  for i in range(100):
      mask = scipy.ndimage.convolve(board, weights, mode='constant')
      board = ((mask == 3) | ((mask - board) == 3)).astype(int)
  board.sum()
#+end_src

** Part 2
#+begin_src jupyter-python
  def fix_corners(board):
      board = np.roll(board, 1, axis=[0,1])
      board[:2, :2] = 1
      return np.roll(board, -1, axis=[0,1])

  board = fix_corners(initial_board)
  for i in range(100):
      mask = scipy.ndimage.convolve(board, weights, mode='constant')
      board = fix_corners(((mask == 3) | ((mask - board) == 3)).astype(int))
  board.sum()
#+end_src

* Day 19
[[https://adventofcode.com/2015/day/19][Medicine for Rudolph]]
** Part 1
#+begin_src jupyter-python
  data = load(19)
  transitions, initial_string = data[:-2], data[-1].strip()
  transitions = [x.strip().split(" => ") for x in transitions]
  transformations = defaultdict(list)
  for source, dest in transitions:
      transformations[source].append(dest)
  element_regex = "[A-Z][a-z]?"
  elements = re.findall(element_regex, initial_string)
  result = set()
  for idx, element in enumerate(elements):
      prefix = ''.join(elements[:idx])
      suffix = ''.join(elements[idx+1:])
      for transformation in transformations[element]:
          result.add(prefix + transformation + suffix)
  len(result)
#+end_src

** Part 2
Instead of trying to make the final string starting from "e" and using the given transformations, we can equivalently try to reduce the final string to "e" using the reverse transformations - that should be the same thing.

If we're naive about this, it's going to take a very long time. One thing to notice is that "Ca" only appears on the right hand side of our transformation rules as "X => XCa" or "X => CaX". So generating one unit of "Ca" always takes one step, and we can pretend there's a rule of the form "'∅ => Ca".

That still leaves us with more than 100k candidates for shortening after only 4 reverse substitutions, which is less than ideal. Luckily, there's a pen and paper solution!

Looking further at the list of reactions given, all the ones that don't produce Rn are of the form "A => BC", and thus always take exactly one step to increase the length of the molecule by one.

The only remaining question is how efficiently we can use the Rn we have available. Now, some of the "Rn" reactions give a "C" to start with, but "C" is not the source of any reaction and it's not present in our string, so we can completely ignore these. Looking at the remainder, all the reactions convert one element into four, apart from "H => NRnFYFAr" and "Ca => SiRnFYFAr", which convert one to six. There are only 6 Ys in the initial string, so these reactions have to run exactly six times, and the others run 30 times (There are 36 Rns in my input)

There are 292 elements in the initial string. After getting rid of Rns I have 292 - 5 * 6 - 3 * 30 = 172 elements left, and have spent 36 reactions. Getting to one electron requires a further 171 reactions for a total of 207.
