#+PROPERTY: header-args:jupyter-python  :session aoc-2016 :kernel aoc
#+PROPERTY: header-args    :pandoc t

* Imports
#+begin_src jupyter-python
  import pandas as pd
  import numpy as np
  from collections import defaultdict, deque
  from pathlib import Path
  import functools
  import itertools
  import more_itertools
  import re
  from utils import year_load
  load = year_load(2016)
#+end_src

* Day 1
[[https://adventofcode.com/2016/day/1][No Time for a Taxicab]]
** Part 1
How many blocks away is Easter Bunny HQ?
#+begin_src jupyter-python
  instructions = load(1)[0].strip().split(", ")
  position = np.array([0, 0])
  direction = np.array([0, 1])
  rotations = {"R": np.array([[0, 1], [-1, 0]], dtype=int),
               "L": np.array([[0, -1], [1, 0]], dtype=int)}
  for instruction in instructions:
      direction = rotations[instruction[0]] @ direction
      position += direction * int(instruction[1:])
  sum(abs(position))

#+end_src

** Part 2
Then, you notice the instructions continue on the back of the Recruiting Document. Easter Bunny HQ is actually at the first location you visit twice.
#+begin_src jupyter-python
  position = np.array([0, 0])
  direction = np.array([0, 1])
  seen = {tuple(position): True}
  for instruction in instructions:
      direction = rotations[instruction[0]] @ direction
      for i in range(int(instruction[1:])):
          position += direction
          if tuple(position) in seen: break
          seen[tuple(position)] = True
      else: continue
      break
  sum(abs(position))
#+end_src

* Day 2
[[https://adventofcode.com/2016/day/2][Bathroom Security]]
** Part 1
#+begin_src jupyter-python
  commands = {"U": -1j, "D": 1j, "L": -1, "R": 1}
  grid = { 0: 1,    1: 2,    2: 3,
          1j: 4, 1+1j: 5, 2+1j: 6,
          2j: 7, 1+2j: 8, 2+2j: 9}
  def update(point, grid, instructions):
      for instruction in instructions:
          new_point = point + commands[instruction]
          if new_point in grid:
              point = new_point
      return point
  point = 1 + 1j
  password = ''
  instructions = [line.strip() for line in load(2)]
  for line in instructions:
      point = update(point, grid, line)
      password += str(grid[point])
  password

#+end_src

** Part 2
#+begin_src jupyter-python
  grid = {0j + 2: 1,
          1j + 1: 2, 1j + 2: 3, 1j + 3: 4,
          2j: 5, 2j + 1: 6, 2j + 2: 7, 2j+3: 8, 2j + 4: 9,
          3j + 1: "A", 3j + 2: "B", 3j + 3: "C",
          4j + 2: "D"}
  point = 2j
  password = ""
  for line in instructions:
      point = update(point, grid, line)
      password += str(grid[point])
  password
#+end_src

* Day 3
[[https://adventofcode.com/2016/day/3][Squares with three sides]]
** Part 1
#+begin_src jupyter-python
  data = np.array(load(3, "int"), dtype=int)
  def is_valid(triangle):
      x, y, z = triangle
      return x + y > z and x + z > y and y + z > x
  sum(map(is_valid, data))
#+end_src

** Part 2
#+begin_src jupyter-python
sum(map(is_valid, data.T.ravel().reshape(-1, 3)))
#+end_src

* Day 4
[[https://adventofcode.com/2016/day/4][Security Through Obscurity]]
** Part 1

#+begin_src jupyter-python
  def parse_line(room):
      checksum = room[-6:-1]
      sector_id = int(room[:-7].split("-")[-1])
      name = '-'.join(room.split("-")[:-1])
      return name, sector_id, checksum

  def calculate_checksum(name):
      occurrences = list(zip(*np.unique(list(name.replace("-", "")), return_counts=True)))
      return ''.join(x[0] for x in sorted(occurrences, key = lambda x: [-x[1], x[0]])[:5])

  data = [parse_line(l.strip()) for l in load(4)]
  sum(sector_id for name, sector_id, checksum in data if calculate_checksum(name) == checksum)
#+end_src

** Part 2
#+begin_src jupyter-python
  real_rooms = [room[:2] for room in data if calculate_checksum(room[0]) == room[2]]
  def decrypt(name, offset):
      alphabet = "abcdefghijklmnopqrstuvwxyz"
      shifted_alphabet = ''.join(x for x in np.roll(list(alphabet), -offset % 26))
      return name.translate(str.maketrans(alphabet, shifted_alphabet)), offset

  [answer for room in real_rooms if "north" in (answer := decrypt(*room))[0]]

#+end_src

* Day 5
[[https://adventofcode.com/2016/day/5][How About a Nice Game of Chess?]]
** Part 1
#+begin_src jupyter-python
  import hashlib
  h = hashlib.md5()
  prefix = "wtnhxymk"
  password = ""
  i = 0
  while len(password) < 8:
      s = hashlib.md5((prefix + str(i)).encode(encoding="UTF-8")).hexdigest()
      if s[:5] == "0" * 5:
          password = password + s[5]
      i += 1
  password
#+end_src

#+begin_src jupyter-python
  password = [None] * 8
  i = 0
  while any([x is None for x in password]):
      s = hashlib.md5((prefix + str(i)).encode(encoding="UTF-8")).hexdigest()
      if s[:5] == "0" * 5 and s[5] in "01234567" and password[int(s[5])] is None:
          password[int(s[5])] = s[6]
      i += 1
  ''.join(password)
#+end_src

* Day 6
[[https://adventofcode.com/2016/day/6][Signals and Noise]]
** Part 1
#+begin_src jupyter-python
  messages = load(6)
  ''.join(pd.DataFrame([list(x.strip()) for x in messages]).mode().values[0])

#+end_src

** Part 2
#+begin_src jupyter-python
  foo = np.array([list(x.strip()) for x in messages])
  s = ''
  for i in range(foo.shape[1]):
      letters, counts = np.unique(foo[:, i], return_counts=True)
      s += letters[counts.argmin()]
  s
#+end_src

* Day 7
[[https://adventofcode.com/2016/day/7][Internet Protocol Version 7]]
** Part 1
#+begin_src jupyter-python
  data = load(7)
  abba = re.compile(r"(.)(?!\1)(.)\2\1")
  bracketed_abba = re.compile(r"\[[^]]*(.)(?!\1)(.)\2\1.*?\]")
  def supports_tls(haystack):
      return bool(re.search(abba, haystack)) and not bool(re.search(bracketed_abba, haystack))

  sum(supports_tls(line) for line in data)

#+end_src

** Part 2
Part two is more regex wrangling, except the patterns can overlap now. We could spend time figuring out exactly how to account for that, or we can import the third party regex module which does it for us automagically.
#+begin_src jupyter-python
  import regex
  def supports_ssl(haystack):
      aba = regex.compile(r"(.)(?!\1)(.)\1")
      bracket_split = [x.split("[") for x in haystack.split("]")]
      outside, inside = itertools.zip_longest(*bracket_split, fillvalue='')
      abas = [match for fragment in outside for match in regex.findall(aba, fragment, overlapped=True)]
      for a, b in abas:
          bab = f"{b}{a}{b}"
          if any(bab in fragment for fragment in inside):
              return True
      return False

  sum(supports_ssl(line) for line in data)

#+end_src

* Day 8
[[https://adventofcode.com/2016/day/8][Two-Factor Authentication]]
** Part 1
#+begin_src jupyter-python
  array = np.zeros((6, 50), dtype=int)
  lines = [x.strip().split() for x in load(8)]
  for instructions in lines:
      if instructions[0] == 'rect':
          row, col = [int(a) for a in instructions[1].split("x")]
          array[:col, :row] = 1
          continue
      row = int(instructions[2].split("=")[1])
      amount = int(instructions[-1])
      if instructions[1] == "column":
          array = array.T
      array[row] = np.roll(array[row], amount)
      if instructions[1] == "column":
          array = array.T
  array.sum()
#+end_src

** Part 2
#+begin_src jupyter-python
  [[''.join('â–ˆ' if char else ' ' for char in line)] for line in array]
#+end_src

* Day 9
[[https://adventofcode.com/2016/day/9][Explosives in Cyberspace]]
** Part 1
#+begin_src jupyter-python
  data = load(9)[0].strip()
  part1 = data

  def count(s, part2 = False):
      total = 0
      while s:
          if s[0] != "(":
              total += 1
              s = s[1:]
              continue
          end = s.index(")")
          chars, repeat = map(int, s[1:end].split("x"))
          s = s[end + 1:]
          if part2:
              total += repeat * count(s[:chars], True)
          else:
              total += repeat * chars
          s = s[chars:]
      return total
  count(data)
#+end_src

** Part 2
#+begin_src jupyter-python
  count(data, part2=True)
#+end_src

* Day 10
[[https://adventofcode.com/2016/day/10][Balance Bots]]

** Part 1
#+begin_src jupyter-python
  import pprint
  data = load(10)
  wiring = {}
  state = defaultdict(list)
  for line in data:
      command = re.findall("(bot|value|output) (\d+)", line)
      numbers = [int(x[1]) for x in command]
      names = [x[0] for x in command]
      if len(command) == 2:
          state[numbers[1]].append(numbers[0])
      else:
          wiring[numbers[0]] = [x for x in zip(names[1:], numbers[1:])]

  queue = deque([x for x in start if len(state[x]) == 2])
  output = [0] * 21

  def step():
      current = queue.popleft()
      values = sorted(state[current])
      state[current] = []
      left, right = wiring[current]
      for idx, (name, value) in enumerate(wiring[current]):
          if name == "bot":
              state[value].append(values[idx])
              if len(state[value]) == 2:
                  queue.append(value)
          else:
              output[value] = values[idx]
      return current, values
  while True:
      current, values = step()
      if values == [17, 61]:
          break
  current
#+end_src

** Part 2
With Part 1 out of the way, part 2 is just
#+begin_src jupyter-python
  while queue:
      step()
  np.product(output[:3])
#+end_src

* Day 11

** Part 1
This one looks difficult, but I don't think it is too tricky. Given that we are in floor $n$, the valid next positions are us at floor $n+1$ or $n - 1$, with up to two items moved; with the items moved being subject to the puzzle constraints.

So I think the way to go is A*.

#+begin_src jupyter-python
  from more_itertools import grouper
  from utils import astar
  n_floors = 4

  def distance_estimate(state, end):
      items = state[1]
      return sum((val / 2) * (n_floors - i - 1) for i, val in enumerate(items))

  def is_valid(items):
      generators, chips = state[::2], state[1::2]
      return all((chip == generator) or (chip not in generators)
                 for chip, generator in zip(chips, generators))

  def normalize(items):
      return tuple(x for pair in sorted(list(grouper(items, 2))) for x in pair)

  def constrained_neighbors(state):
      floor, items = state
      active_indices = [index for index, val in enumerate(items) if val == floor]
      neighbors = set()
      for new_floor in [floor + 1, floor - 1]:
          if not (0 <= new_floor < n_floors):
              continue
          moves = [[x] for x in active_indices]
          if new_floor == floor + 1:
              moves = itertools.chain(moves, itertools.combinations(active_indices, 2))
          for move in moves:
              new_items = list(items)
              for index in move:
                  new_items[index] = new_floor
              if is_valid(new_items):
                  neighbors.add((new_floor, normalize(new_items)))
      return neighbors

  state = 0, (0, 0, 0, 0, 1, 1, 1, 1, 1, 2)
  target = 3, (3,)*len(state[1])
  astar(state, target, constrained_neighbors, distance_estimate)
#+end_src

** Part 2
Extending this to part 2 without changing anything is possible, but the whole thing takes about a minute and a half to run. When I have time, I'll come back and look at it again.

Reducing the search space by only letting the elevator move down with one item at a time reduced the runtime to about half. I'm not 100% convinced the restriction is always valid, but it did work in this case.
#+begin_src jupyter-python
  state = 0, (0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2)
  target = 3, (3,)*len(state[1])
  astar(state, target, constrained_neighbors, distance_estimate)
#+end_src

* Day 12
[[https://adventofcode.com/2016/day/12][Leonardo's Monorail]]

** Part 1
This is a fairly straightforward implementation of the problem description, with no particular cleverness going on. We have two types of instructions - ones that take two operands, and ones that take only one, and we can treat those together.
#+begin_src jupyter-python
  def run(program, registers=None):
      if registers is None:
          registers = defaultdict(int)
      ip = 0
      while ip < len(program):
          instruction = program[ip]
          operator, operands = instruction[0], instruction[1:]
          if operator in ["cpy", "jnz"]:
              source, destination = operands
              value = int(source) if source not in 'abcd' else registers[source]
              if operator == "cpy":
                  registers[destination] = value
              if operator == "jnz" and value != 0:
                  ip += int(destination) - 1
          elif operator in ["inc", "dec"]:
              registers[operands[0]] += 2 * (operator == "inc") - 1
          ip += 1
      return registers['a']

  data = [line.strip().split(" ") for line in load(12)]
  run(data)
#+end_src

** Part 2
#+begin_src jupyter-python
  registers = defaultdict(int)
  registers['c'] = 1
  run(data, registers)
#+end_src

* Day 13
[[https://adventofcode.com/2016/day/13][A Maze of Twisty Little Cubicles]]

** Part 1
#+begin_src jupyter-python
  from utils import astar
  def is_valid(x, y, secret=1362):
      if x < 0 or y < 0:
          return False
      val = x*x + 3*x + 2*x*y + y + y*y + secret
      ones = f"{val:b}".count("1")
      return (ones % 2) == 0

  def neighbors(state):
      x, y = state
      candidates = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]
      return [candidate for candidate in candidates if is_valid(*candidate)]

  def distance_function(point, target):
      return abs(point[0] - target[0]) + abs(point[1] - target[1])
  start = (1, 1)
  target = 31, 39
  astar(start, target, neighbors, distance_function)
#+end_src

** Part 2
#+begin_src jupyter-python
  active = [(1, 1)]
  visited = set()

  for i in range(51):
      new_states = []
      for state in active:
          if state in visited:
              continue
          visited.add(state)
          new_neighbors = [neighbor for neighbor in neighbors(state)
                           if neighbor not in visited]
          new_states += new_neighbors
      active = new_states
  len(visited)

#+end_src

* Day 14
[[https://adventofcode.com/2016/day/14][One-Time Pad]]
** Part 1
#+begin_src jupyter-python
  import hashlib
  def infinite_triples(prefix, part=1):
      r1 = r"(.)\1\1"
      r2 = r"(.)\1\1\1\1"
      n = 1
      while True:
          s = hashlib.md5((prefix + str(n)).encode()).hexdigest()
          if part == 2:
              for i in range(2016):
                  s = hashlib.md5(s.encode()).hexdigest()
          if r := re.search(r1, s):
              yield (r.groups(1)[0], re.findall(r2, s))
          else:
              yield False
          n += 1

  def nth_key_index(prefix, n=64, part=1):
      triples = filter(lambda x: x[1], enumerate(infinite_triples(prefix, part)))
      window = [next(triples)]
      current = 0
      while current < n:
         idx, (triple, _) = window.pop(0)
         while not window or window[-1][0] < idx + 1000:
             window.append(next(triples))
         active_quints = [char for triple in window[:-1] for char in triple[1][1]]
         if triple in active_quints:
             current += 1
      return idx + 1
  nth_key_index("yjdafjpo")
#+end_src
** Part 2
I was a little uncertain about how to write this cleanly -- all of the logic from part one is the same, the only difference is how the hash is generated. In the end, I made a toggle in the `infinite_triples` function, which is why part 2 can be solved by writing just:
#+begin_src jupyter-python
  nth_key_index("yjdafjpo", part=2)
#+end_src
* Day 15
[[https://adventofcode.com/2016/day/15][Timing is Everything]]
** Part 1
Another round of the chinese remainder theorem.
#+begin_src jupyter-python
  from utils import crt
  data = [[int(x) for x in re.findall(r"\d+", line)] for line in load(15)]
  remainders = [(x[1], -(x[-1] + x[0])) for x in data]
  crt(remainders)
#+end_src

** Part 2
#+begin_src jupyter-python
  remainders.append([11, -(len(remainders) + 1)])
  crt(remainders)
#+end_src

* Day 16
[[https://adventofcode.com/2016/day/16][Dragon Checksum]]

** Part 1
#+begin_src jupyter-python
  start = [1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,1]
  length = 272
  def solve(prefix, length):
      while len(prefix) < length:
          prefix = prefix + [0] + [1 ^ x for x in prefix[::-1]]
      s = prefix[:length]
      while len(s) % 2 == 0:
          s = (abs(np.diff(s))[::2] ^ 1)
      return s
  print(*solve(start, length), sep="")
#+end_src

** Part 2
#+begin_src jupyter-python
  print(*solve(start, 35651584), sep="")
#+end_src

