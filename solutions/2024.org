#+PROPERTY: header-args:jupyter-python  :session aoc-2024 :kernel aoc
#+PROPERTY: header-args    :pandoc t
#+TITLE: 2024 Solutions

* Imports
#+begin_src jupyter-python
# | eval: true
# | output: false
import dataclasses
import functools
import itertools
import os
import re
import sys
from collections import defaultdict, deque, namedtuple
from queue import PriorityQueue

import more_itertools
import numpy as np
import pandas as pd
import scipy

sys.path.insert(1, "..")

import utils

load = utils.year_load(2024)
#+end_src

* [[https://adventofcode.com/2024/day/1][Day 1: Historian Hysteria]]
** Part 1
Load the data, sort the two columns, find the absolute difference between them and sum the result.
#+begin_src jupyter-python
data = np.sort(load(1, "int"), axis=0)
abs(np.diff(data)).sum()
#+end_src

** Part 2
~numpy~ has a handy method to find the unique values in an array, and their counts. Let's use that to make a dictionary of ~value -> count~ pairs for the right list with a default value of zero, and then just look up that value for each element of the left list.
#+begin_src jupyter-python
lookup = defaultdict(int)
lookup.update(
    {value: count for value, count in zip(*np.unique(data[:, 1], return_counts=True))}
)
sum(x * lookup[x] for x in data[:, 0])
#+end_src

* [[https://adventofcode.com/2024/day/2][Day 2: Red-Nosed Reports]]
** Part 1
Nothing too complicated going on here: load the data, and find the difference between successive values. To account for decreasing sequences, multiply by the sign of the first difference and then require that all the differences be greater than one and less than or equal to three.
#+begin_src jupyter-python
data = load(2, "int")


def is_safe(line):
    diff = np.diff(line)
    diff = diff * np.sign(diff[0])
    return int(((diff > 0) & (diff <= 3)).all())


sum(is_safe(line) for line in data)
#+end_src
** Part 2
I spent a bit of time trying to see if there was a neat way of incorporating the "is valid if any one number is deleted" requirement, but I couldn't immediately see it, so I ended up just iterating over all the possible deletions instead.
#+begin_src jupyter-python
total = 0
for line in data:
    for idx in range(len(line)):
        if is_safe(line[:idx] + line[idx + 1 :]):
            total += 1
            break
total
#+end_src
