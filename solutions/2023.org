#+PROPERTY: header-args:jupyter-python  :session aoc-2023 :kernel aoc
#+PROPERTY: header-args    :pandoc t
#+TITLE: 2023 Solutions

* Imports
#+begin_src jupyter-python
  # | eval: true
  # | output: false
  import functools
  import itertools
  import os
  import re
  import sys
  from collections import defaultdict, deque, namedtuple
  from queue import PriorityQueue

  import more_itertools
  import numpy as np
  import pandas as pd
  import scipy

  sys.path.insert(1, os.path.join(sys.path[0], ".."))

  import utils

  load = utils.year_load(2023)
#+end_src

* [[https://adventofcode.com/2023/day/1][Day 1: Trebuchet?!]]
** Part 1
Not much going on in part one. We need to extract the digits in each line and then add together $10\times$ all the first digits and all the last digits.
#+begin_src jupyter-python
  data = [[int(char) for char in line if char in "0123456879"] for line in load(1)]
  10 * sum(x[0] for x in data) + sum(x[-1] for x in data)
#+end_src

** Part 2
For part two, we need to work with the string representation of the numbers. The examples show that the numbers can overlap, so we want a string like "fiveight" to show a "5" first and then an "8".

We are only interested in the first and last digits of the string, so this could be done using a sliding window. Or we could hack it by padding the string representation of the number and doing a search and replace:
#+begin_src jupyter-python
  number_names = [
      ("one", "one1one"),
      ("two", "two2two"),
      ("three", "three3three"),
      ("four", "four4four"),
      ("five", "five5five"),
      ("six", "six6six"),
      ("seven", "seven7seven"),
      ("eight", "eight8eight"),
      ("nine", "nine9nine"),
  ]
  data = load(1, "raw")
  for pair in number_names:
      data = data.replace(pair[0], pair[1])

  data = data.split("\n")[:-1]
  data = [[int(char) for char in line if char in "0123456879"] for line in data]
  10 * sum(x[0] for x in data) + sum(x[-1] for x in data)
#+end_src

* [[https://adventofcode.com/2023/day/2][Day 2: Cube Conundrum]]

** Part 1
The most fiddly task in part 1 is parsing the input. Each line is a single game, with the game id appearing first and then the game outcome, separated by a colon. Each game consists of multiple rounds (delimited by a semicolon) and each round reveals multiple colours (delimited by commas).

So we split on the colon to separate the game id from the outcome, then split the outcome on semicolons to get each round, and finally split each round on commas to find the colours. A bit of regex let's us finally get to a list of three integers as the representation of a round.

Once we have that, we can compare each round in a game with the maximum number of =[red, green, blue]= cubes available and see if it is possible. A game fails if any single round is impossible.
#+begin_src jupyter-python
  def parse_game_round(game_round):
      colormap = {"red": 0, "green": 1, "blue": 2}
      regex = r"([0-9]*) (red|green|blue)"
      result = [0, 0, 0]
      for v, c in [re.search(regex, entry).groups() for entry in game_round.split(",")]:
          result[colormap[c]] = int(v)
      return result


  total = 0
  games = [
      np.array([parse_game_round(x) for x in line.split(":")[1].split(";")])
      for line in load(2)
  ]

  for idx, game in enumerate(games):
      if ((game - [12, 13, 14]) <= 0).all():
          total += idx + 1
  total
#+end_src

** Part 2
With part 1 out of the way, part 2 is trivial: we get the same representation for each game as before, and just calculate the maximum for each coordinate in any round, and then multiply those three numbers together.
#+begin_src jupyter-python
  sum(np.product(game.max(axis=0)) for game in games)
#+end_src

* [[https://adventofcode.com/2023/day/3][Day 3: Gear Ratios]]

** Part 1
It seems the theme for AOC this year is "let's make things annoying to parse".

We'll need to extract the values and locations of all the numbers in the grid, and then compare that with the locations of the symbols. To get the coordinates that neighbor a symbol we can use a neat convolution trick. To get the coordinates of each number we'll loop over all the lines in the grid, and use a regex to find the numbers.

Once we have that, we can find the desired value by finding the set intersetion of the number-coordinates and the neighbor coordinates; if that's non-empty, we add the number to a running total.
#+begin_src jupyter-python
  data = load(3)
  symbols = np.array([[(c not in "0123456789") and c != "." for c in l] for l in data])
  w = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]
  neighbors = scipy.ndimage.convolve(symbols, w, mode="constant")
  neighbors = set(zip(*np.where(neighbors)))
  numbers = {}
  for i, row in enumerate(data):
      for n in re.finditer("\d+", row):
          numbers[frozenset((i, j) for j in range(*n.span()))] = int(n.group())
  sum(numbers[key] if key & neighbors else 0 for key in numbers)
#+end_src

** Part 2
After part 1, part 2 is pretty simple. We can use the same (coordinates) -> number mapping as before, and then just loop over all locations in the grid that have a value of "*". We find the neighbors of each star, intersect with all the numbers coordinates, and only use the ones that intersect exactly two numbers
#+begin_src jupyter-python
  total = 0
  offsets = np.array(list(zip(*np.where(w)))) - 1
  for star in zip(*np.where(np.array([[c for c in l] for l in data]) == "*")):
      neighbors = set([tuple(x) for x in star + offsets])
      values = [numbers[key] for key in numbers if key & neighbors]
      total += values[0] * values[1] if len(values) == 2 else 0
  total
#+end_src

* [[https://adventofcode.com/2023/day/4][Day 4: Scratchcards]]

** Part 1
After the interesting parsing tasks of the last few days, today was straightforward. Part one can be boiled down to this oneliner, which I don't even think is completely illegible
#+begin_src jupyter-python
  sum(int(2 ** (len(set(row[1:11]) & set(row[11:])) - 1)) for row in load(4, "int"))
#+end_src

** Part 2
I could have found some way of saving the intersections from part 1 so that I didn't have to recalculate in part two, but it's not that complicated.
#+begin_src jupyter-python
  data = load(4, "int")
  counts = np.ones(len(data), dtype=int)
  for i, row in enumerate(data):
      wins = len(set(row[1:11]) & set(row[11:]))
      counts[i+1:i+wins+1] += counts[i]
  sum(counts)
#+end_src

* [[https://adventofcode.com/2023/day/5][Day 5: If You Give A Seed A Fertilizer]]

** Part 1
The first part is a straightforward implementation of the requirements.

To parse the file, we first split on "\n\n" to get each of the sections separately, then for each line of each section, we extract all of the integers. These are all positive, so we can do that with the regex "(\d+)". After skipping through lines which don't contain integers, we have a sensible representation for our data.

After that it's just a question of following through what happens to each initial value: for each one we scan through the rulesets in order, and when we find a rule in a ruleset that matches we convert it to the new value and move on. If we don't find a rule that matches we're told that the converted value is the same as the original one.
#+begin_src jupyter-python
  [seeds], *rules = [
      [
          [int(x) for x in ints]
          for line in groups.split("\n")
          if (ints := re.findall("(\d+)", line))
      ]
      for groups in load(5, "raw").split("\n\n")
  ]

  minval = np.inf
  for seed in seeds:
      current = seed
      for ruleset in rules:
          for destination, source, length in ruleset:
              if source <= current < source + length:
                  current = current + destination - source
                  break
      if current < minval:
          minval = current
  minval
#+end_src

** Part 2
For part two we need to be a bit cleverer. We know that each rule converts a specific source range to a specific destination range. So to apply a rule to an arbitrary range, we split the range into three: The parts of the range before the rule applies, the parts of the range that intersect the rule and the parts of the range after the rule. Some of these parts can be empty, but that's OK.

From there, building a routine to iteratively apply each ruleset to the original ranges is not too tricky.
#+begin_src jupyter-python
  def split_range(r, rule):
      return [
          x if x[0] < x[1] else []
          for x in [
              (r[0], min(rule[0], r[1])),
              (max(r[0], rule[0]), min(r[1], rule[1])),
              (max(rule[1], r[0]), r[1]),
          ]
      ]


  def split_ranges(ranges, rule):
      dest, src, length = rule
      done, todo = [], []
      for l, m, r in [split_range(r, [src, src + length]) for r in ranges]:
          todo += [l] if l else []
          todo += [r] if r else []
          done += [(m[0] + dest - src, m[1] + dest - src)] if m else []
      return done, todo


  ranges = [(start, start + l) for start, l in more_itertools.chunked(seeds, 2)]
  for ruleset in rules:
      todo = ranges
      ranges = []
      for rule in ruleset:
          new_ranges, todo = split_ranges(todo, rule)
          ranges += new_ranges
      ranges += todo
  min(x[0] for x in ranges)
#+end_src

* [[https://adventofcode.com/2023/day/6][Day 6: Wait For It]]
** Part 1
We can set up an equation for how far the boat will move in a given time, $t$ when waiting for a given period $w$ at the start, to wit
$$
d(t, w) = w(t-w)
$$

We are interested in which values of $w$ give $d(t_0, w) > d_0$, for the $d_0, t_0$ pairs we are given in the input, which is the same as exploring when the parabola described by $-w^2 +wt_0 - d_0$ is positive. This parabola has a maximum at $w = \frac{t_0}{2}$, and it's positive region (if any) will lie between the two roots. The roots are given by

$$
w_{1,2} = \frac{t_0 \mp \sqrt{t_0^2 - 4d_0^2}}{2};
$$

and for each $(d_0, t_0)$ pair we are interested in how many integers lie in the open interval $(w_1, w_2)$
#+begin_src jupyter-python
  ts, ds = np.array(load(6, "int"))
  Δs = np.sqrt(ts**2 - 4 * ds)
  np.prod(np.floor(ts / 2 + Δs / 2 - 1e-10) - np.ceil(ts / 2 - Δs / 2 + 1e-10) + 1)
#+end_src

** Part 2
For part 2, we don't need to change anything.
#+begin_src jupyter-python
  t = int("".join([str(x) for x in ts]))
  d = int("".join([str(x) for x in ds]))
  Δ = np.sqrt(t**2 - 4 * d)
  np.floor(t / 2 + Δ / 2 - 1e-10) - np.ceil(t / 2 - Δ / 2 + 1e-10) + 1
#+end_src

* [[https://adventofcode.com/2023/day/7][Day 7: Camel Cards]]

** Part 1
This feels doable. The key is to find a method to compare two hands of cards. We can use =np.unique= to get the count of how many times each unique value appears in the hand, which is almost exactly what we need. If we sort this count, then two hands will compare correctly if we compare their count tuples, since tuples sort lexicographically. The final comparator is =[counts, [card_value for card in hand]]=, to correctly sort hands of the same type but with different values. 
#+begin_src jupyter-python
  def counts(hand, part=1):
      hand = [x for x in hand if x != "J"] if part == 2 else hand
      _, counts = np.unique([x for x in hand], return_counts=True)
      counts = sorted(counts, reverse=True) if hand else [0]
      counts[0] += 5 - len(hand)
      return counts


  data = [x.strip().split() for x in load(7)]
  order = sorted(
      data, key=lambda row: [counts(row[0]), ["23456789TJQKA".index(c) for c in row[0]]]
  )

  sum([int(x[1]) for x in order] * np.arange(1, 1 + len(order)))
#+end_src

** Part 2
Part 2 was similar enough to part 1 that I just made a flag in the =counts= function and changed the order of the card values
#+begin_src jupyter-python
  order = sorted(
      data,
      key=lambda row: [counts(row[0], part=2), ["J23456789TQKA".index(c) for c in row[0]]],
  )

  sum([int(x[1]) for x in order] * np.arange(1, 1 + len(order)))
#+end_src

* [[https://adventofcode.com/2023/day/8][Day 8: Haunted Wasteland]]
** Part 1
For part 1 we build a dictionary of left, right instructions for each node, which makes following a path from start to end easy.
#+begin_src jupyter-python
  instructions, lines = load(8, "raw").split("\n\n")
  instructions = instructions.strip()
  data = [words for line in lines.split("\n") if (words := re.findall("[A-Z]+", line))]
  nodes = {node: {"L": left, "R": right} for node, left, right in data}
  node = "AAA"
  i = 0
  while node != "ZZZ":
      node = nodes[node][instructions[i % len(instructions)]]
      i += 1
  i
#+end_src

** Part 2
Part 2 screams cycle checking, and indeed it is. The state at any given time is given by the current node and the index of the instruction list. If we ever see the same state twice, we know we're in a cycle, and can figure out the period. All of the cycles turn out to have periods that match the offset from the start, so we can just use the =lcm= to find the common period. If some of the cycles had had a different offset, we would have need the full chinese remainder theorem.
#+begin_src jupyter-python
  import math
  i = 0
  periods = []
  def find_cycle(node):
      seen = {}
      i = 0
      z = None
      while (node, i % len(instructions)) not in seen:
          seen[node, i % len(instructions)] = i
          node = nodes[node][instructions[i % len(instructions)]]
          i += 1
          if node[-1] == "Z":
              z = i
      period = i - seen[(node, i % len(instructions))]
      return period, z % period
  periods, congruences = list(zip(*[find_cycle(node) for node in nodes if node[-1] == "A"]))
  math.lcm(*periods)
#+end_src

* [[https://adventofcode.com/2023/day/9][Day 9: Mirage Maintenance]]
** Part 1
This one's pretty straightforward: calculate all the needed differences; add the last element of each difference to the calculation.
#+begin_src jupyter-python
  def score(line, part=1):
      total = 0
      if part == 2:
          line = line[::-1]
      while any(line):
          total += line[-1]
          line = [line[i] - line[i - 1] for i in range(1, len(line))]
      return total


  sum(score(line) for line in load(9, "int"))
#+end_src

** Part 2
...and part 2 is simple enough that it can be included in part 1 with a flag
#+begin_src jupyter-python
  sum(score(line, part=2) for line in load(9, "int"))
#+end_src

* [[https://adventofcode.com/2023/day/10][Day 10: Pipe Maze]]

** Part 1
For part 1 we find the two directions leading away from the starting point, and follow the path along each one at the same pace. The point where they overlap is the point furthest away from the start, so we return that.
#+begin_src jupyter-python
  data = np.pad(
      np.array([[char for char in line.strip()] for line in load(10)]),
      1,
      constant_values=".",
  )
  connections = {
      "-": [(0, -1), (0, 1)],
      "|": [(-1, 0), (1, 0)],
      "L": [(-1, 0), (0, 1)],
      "J": [(-1, 0), (0, -1)],
      "7": [(1, 0), (0, -1)],
      "F": [(1, 0), (0, 1)],
      ".": [],
  }
  Δs = np.array([[1, 0], [0, 1], [-1, 0], [0, -1]])
  point = np.array(next(zip(*np.where(data == "S"))))
  (lx, lv), (rx, rv) = [
      (point + Δ, Δ) for Δ in Δs if tuple(-Δ) in connections[data[tuple(point + Δ)]]
  ]


  def update(point, direction):
      options = connections[data[tuple(point)]]
      new_direction = np.array(
          options[1] if tuple(-direction) == options[0] else options[0]
      )
      return point + new_direction, new_direction


  i = 1
  left_path = [point, lx]
  right_path = [rx]
  while not np.allclose(lx, rx):
      lx, lv = update(lx, lv)
      left_path.append(lx)
      rx, rv = update(rx, rv)
      right_path.append(rx)
      i += 1
  i
#+end_src

** Part 2
For part 2, we need some way of distinguishing points inside from outside the circuit. Since the lines that make up the boundary of the circuit never cross, this is a point in polygon problem. We could solve it by raytracing: for every point in the polygon we can draw all rays to the outside edge and see if they cross the boundary of the polygon an odd number of times. If they do, the point is inside the polygon. We could also look at the winding number of the polygon with respect the the point: points inside will have a nonzero winding number, while points outside will have a positive winding number.

Ultimately, what I ended up doing was just blowing up the grid to double size, flood filling the outside and looking at the even coordinate values of whatever was left. It's stupid, but it works.
#+begin_src jupyter-python
  ys, xs = zip(*(left_path + right_path[:-1][::-1]))
  dy, dx = np.diff([ys + (ys[0],), xs + (xs[0],)], axis=1)
  board = np.ones((data.shape[0] * 2, data.shape[1] * 2))
  ys, xs = map(np.array, [ys, xs])
  board[2 * ys, 2 * xs] = 0

  board[2 * ys + dy, 2 * xs + dx] = 0
  board = np.pad(board[1:-1, 1:-1], 1, constant_values=0)
  points = deque([(1, 1)])
  while points:
      point = points.popleft()
      if board[point] == 0:
          continue
      board[point] = 0
      for Δ in Δs:
          nb = tuple(Δ + point)
          if board[nb]:
              points.append(nb)
  int(board[::2, ::2].sum())
#+end_src

* [[https://adventofcode.com/2023/day/11][Day 11: Cosmic Expansion]]

** Part 1
I liked this puzzle, and I feel that I managed to come up with an OK slick array solution. We can get the coordinates of the original galaxies and the empty rows using =np.where=. For each empty row we can increase the first coordinate of the galaxies below it by some amount, and, mutatis mutandis, we can do the same for the empty columns.

That gives us a set of new coordinates, and we need to find the sum of all the manhattan distances from one point to the others. for any pair of points $i, j$, that's $\left|x_i - x_j\right| +\left|y_i - y_j\right|$; we can construct the entire matrix by taking the row vector of coordinates, and subtracting from it the column vector of the same coordinates and relying on =numpy='s broadcasting magic.
#+begin_src jupyter-python
  def solve(s=1):
      y, x = np.where(data == "#")

      empty_r = [i for i in range(len(data)) if all(data[i] == ".")]
      empty_c = [i for i in range(len(data)) if all(data[:, i] == ".")]
      new_y = y + s * np.array([y > empty_r[i] for i in range(len(empty_r))]).sum(axis=0)
      new_x = x + s * np.array([x > empty_c[i] for i in range(len(empty_c))]).sum(axis=0)
      return (
          abs(new_y - new_y.reshape(-1, 1)) + abs(new_x - new_x.reshape(-1, 1))
      ).sum() // 2


  data = load(11, "chararray")
  solve()
#+end_src

** Part 2
The second part is pretty trivially included in the first
#+begin_src jupyter-python
  solve(999_999)
#+end_src

* [[https://adventofcode.com/2023/day/12][Day 12: Hot Springs]]

** Part 1
The core of this solution is the =count= function, which takes a tuple of ints representing the three states (off, ambiguous and on), as well as a tuple of block lengths, and returns the number of assignments of the ambiguous values that work.

It's recursive, with the following base cases; the third is checked last:

- If the number of on values is more than the sum of block lengths, no assignments are possible
- If the sum of the number of on values and ambiguous values is less than the sum of block lengths, no assignments are possible
- If the sum of block lengths is zero, exactly one assignment is possible

Otherwise, if the first character is off, then the count is the same as the count ignoring that assignment and we can recurse.

If the first character is on, we can check whether the first =l= characters would fit the first block, and the =l+1='th character is either the end of the string or compatible with an off state. If it is, the count is the same as the count for the remainder of the string on the remainder of the blocks and we can recurse.

Finally, if the first character is ambiguous, the count is the sum of the counts for the two possible assignments of the character, and we can recurse.
#+begin_src jupyter-python
  def parse(line):
      s, groups = line.strip().split(" ")
      lookup = {"#": 2, "?": 1, ".": 0}
      return tuple(lookup[char] for char in s), tuple(int(g) for g in groups.split(","))


  data = [parse(x) for x in load(12)]


  def match_beginning(data, length):
      return all(x > 0 for x in data[:length]) and (
          (len(data) == length) or data[length] < 2
      )


  @functools.cache
  def count(data, blocks):
      total = sum(blocks)
      minimum = sum(x == 2 for x in data)
      maximum = sum(x > 0 for x in data)
      if minimum > total or maximum < total:
          return 0
      if total == 0:
          return 1
      if data[0] == 0:
          return count(data[1:], blocks)
      if data[0] == 2:
          l = blocks[0]
          if match_beginning(data, l):
              if l == len(data):
                  return 1
              return count(data[l + 1 :], blocks[1:])
          return 0
      return count(data[1:], blocks) + count((2,) + data[1:], blocks)


  sum(count(*line) for line in data)
#+end_src

** Part 2
With the memoization added to part 1, part 2 runs in 8s with no changes needed. Not great, but not terrible
#+begin_src jupyter-python
  sum(count(((chars + (1,)) * 5)[:-1], blocks * 5) for chars, blocks in data)
#+end_src

* [[https://adventofcode.com/2023/day/13][Day 13: Point of Incidence]]

** Part 1
This wasn't too tricky. The idea is that we test all horizontal lines of reflection to see if there are any that match the given condition; if none are found, we rotate the array by 90 degrees clockwise and try again. For part 1, the test is that the two halves should line up exactly after flipping.

The only bit that requires some thought is how to account for the points beyond the top/bottom edge. We do that by saying that the number of lines on either side of the mirror line is the shortest distance to the top/bottom edge, so that only relevant lines are compared. 
#+begin_src jupyter-python
  def find_reflection(array, part=1):
      if part == 1:
          test = lambda a, b: (a == b[::-1]).all()
      else:
          test = lambda a, b: (a != b[::-1]).sum() == 1
      for i in range(1, len(array)):
          l = min(len(array) - i, i)
          if test(array[i - l : i], array[i : i + l]):
              return i
      return None


  arrays = [
      np.array([[char for char in line.strip()] for line in array.split("\n")])
      for array in load(13, "raw").split("\n\n")
  ]

  sum(
      100 * y
      if (y := find_reflection(array)) is not None
      else find_reflection(np.rot90(array, -1))
      for array in arrays
  )
#+end_src

** Part 2
Part 2 is so similar to part 1 that we can include it as a flag there; instead of a perfect match, the test is that exactly one pair of elements should be different on the two sides of the mirror line. Conceptually, that means that the sum of the differences should be exactly 1.
#+begin_src jupyter-python
  sum(
      100 * y
      if (y := find_reflection(array, part=2)) is not None
      else find_reflection(np.rot90(array, -1), part=2)
      for array in arrays
  )
#+end_src
