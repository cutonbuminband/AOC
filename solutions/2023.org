#+PROPERTY: header-args:jupyter-python  :session aoc-2023 :kernel aoc
#+PROPERTY: header-args    :pandoc t
#+TITLE: 2023 Solutions

* Imports
#+begin_src jupyter-python
  # | eval: true
  # | output: false
  import functools
  import itertools
  import os
  import re
  import sys
  from collections import defaultdict, deque, namedtuple
  from queue import PriorityQueue

  import more_itertools
  import numpy as np
  import pandas as pd
  import scipy

  sys.path.insert(1, os.path.join(sys.path[0], ".."))

  import utils

  load = utils.year_load(2023)
#+end_src

* [[https://adventofcode.com/2023/day/1][Day 1: Trebuchet?!]]
** Part 1
Not much going on in part one. We need to extract the digits in each line and then add together $10\times$ all the first digits and all the last digits.
#+begin_src jupyter-python
  data = [[int(char) for char in line if char in "0123456879"] for line in load(1)]
  10 * sum(x[0] for x in data) + sum(x[-1] for x in data)
#+end_src

** Part 2
For part two, we need to work with the string representation of the numbers. The examples show that the numbers can overlap, so we want a string like "fiveight" to show a "5" first and then an "8".

We are only interested in the first and last digits of the string, so this could be done using a sliding window. Or we could hack it by padding the string representation of the number and doing a search and replace:
#+begin_src jupyter-python
  number_names = [
      ("one", "one1one"),
      ("two", "two2two"),
      ("three", "three3three"),
      ("four", "four4four"),
      ("five", "five5five"),
      ("six", "six6six"),
      ("seven", "seven7seven"),
      ("eight", "eight8eight"),
      ("nine", "nine9nine"),
  ]
  data = load(1, "raw")
  for pair in number_names:
      data = data.replace(pair[0], pair[1])

  data = data.split("\n")[:-1]
  data = [[int(char) for char in line if char in "0123456879"] for line in data]
  10 * sum(x[0] for x in data) + sum(x[-1] for x in data)
#+end_src

* [[https://adventofcode.com/2023/day/2][Day 2: Cube Conundrum]]

** Part 1
The most fiddly task in part 1 is parsing the input. Each line is a single game, with the game id appearing first and then the game outcome, separated by a colon. Each game consists of multiple rounds (delimited by a semicolon) and each round reveals multiple colours (delimited by commas).

So we split on the colon to separate the game id from the outcome, then split the outcome on semicolons to get each round, and finally split each round on commas to find the colours. A bit of regex let's us finally get to a list of three integers as the representation of a round.

Once we have that, we can compare each round in a game with the maximum number of =[red, green, blue]= cubes available and see if it is possible. A game fails if any single round is impossible.
#+begin_src jupyter-python
  def parse_game_round(game_round):
      colormap = {"red": 0, "green": 1, "blue": 2}
      regex = r"([0-9]*) (red|green|blue)"
      result = [0, 0, 0]
      for v, c in [re.search(regex, entry).groups() for entry in game_round.split(",")]:
          result[colormap[c]] = int(v)
      return result


  total = 0
  games = [
      np.array([parse_game_round(x) for x in line.split(":")[1].split(";")])
      for line in load(2)
  ]

  for idx, game in enumerate(games):
      if ((game - [12, 13, 14]) <= 0).all():
          total += idx + 1
  total
#+end_src

** Part 2
With part 1 out of the way, part 2 is trivial: we get the same representation for each game as before, and just calculate the maximum for each coordinate in any round, and then multiply those three numbers together.
#+begin_src jupyter-python
  sum(np.product(game.max(axis=0)) for game in games)
#+end_src

* [[https://adventofcode.com/2023/day/3][Day 3: Gear Ratios]]

** Part 1
It seems the theme for AOC this year is "let's make things annoying to parse".

We'll need to extract the values and locations of all the numbers in the grid, and then compare that with the locations of the symbols. To get the coordinates that neighbor a symbol we can use a neat convolution trick. To get the coordinates of each number we'll loop over all the lines in the grid, and use a regex to find the numbers.

Once we have that, we can find the desired value by finding the set intersetion of the number-coordinates and the neighbor coordinates; if that's non-empty, we add the number to a running total.
#+begin_src jupyter-python
  data = load(3)
  symbols = np.array([[(c not in "0123456789") and c != "." for c in l] for l in data])
  w = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]
  neighbors = scipy.ndimage.convolve(symbols, w, mode="constant")
  neighbors = set(zip(*np.where(neighbors)))
  numbers = {}
  for i, row in enumerate(data):
      for n in re.finditer("\d+", row):
          numbers[frozenset((i, j) for j in range(*n.span()))] = int(n.group())
  sum(numbers[key] if key & neighbors else 0 for key in numbers)
#+end_src

** Part 2
After part 1, part 2 is pretty simple. We can use the same (coordinates) -> number mapping as before, and then just loop over all locations in the grid that have a value of "*". We find the neighbors of each star, intersect with all the numbers coordinates, and only use the ones that intersect exactly two numbers
#+begin_src jupyter-python
  total = 0
  offsets = np.array(list(zip(*np.where(w)))) - 1
  for star in zip(*np.where(np.array([[c for c in l] for l in data]) == "*")):
      neighbors = set([tuple(x) for x in star + offsets])
      values = [numbers[key] for key in numbers if key & neighbors]
      total += values[0] * values[1] if len(values) == 2 else 0
  total
#+end_src

* [[https://adventofcode.com/2023/day/4][Day 4: Scratchcards]]

** Part 1
After the interesting parsing tasks of the last few days, today was straightforward. Part one can be boiled down to this oneliner, which I don't even think is completely illegible
#+begin_src jupyter-python
  sum(int(2 ** (len(set(row[1:11]) & set(row[11:])) - 1)) for row in load(4, "int"))
#+end_src

** Part 2
I could have found some way of saving the intersections from part 1 so that I didn't have to recalculate in part two, but it's not that complicated.
#+begin_src jupyter-python
  data = load(4, "int")
  counts = np.ones(len(data), dtype=int)
  for i, row in enumerate(data):
      wins = len(set(row[1:11]) & set(row[11:]))
      counts[i+1:i+wins+1] += counts[i]
  sum(counts)
#+end_src

* [[https://adventofcode.com/2023/day/5][Day 5: If You Give A Seed A Fertilizer]]

** Part 1
The first part is a straightforward implementation of the requirements.

To parse the file, we first split on "\n\n" to get each of the sections separately, then for each line of each section, we extract all of the integers. These are all positive, so we can do that with the regex "(\d+)". After skipping through lines which don't contain integers, we have a sensible representation for our data.

After that it's just a question of following through what happens to each initial value: for each one we scan through the rulesets in order, and when we find a rule in a ruleset that matches we convert it to the new value and move on. If we don't find a rule that matches we're told that the converted value is the same as the original one.
#+begin_src jupyter-python
  [seeds], *rules = [
      [
          [int(x) for x in ints]
          for line in groups.split("\n")
          if (ints := re.findall("(\d+)", line))
      ]
      for groups in load(5, "raw").split("\n\n")
  ]

  minval = np.inf
  for seed in seeds:
      current = seed
      for ruleset in rules:
          for destination, source, length in ruleset:
              if source <= current < source + length:
                  current = current + destination - source
                  break
      if current < minval:
          minval = current
  minval
#+end_src

** Part 2
For part two we need to be a bit cleverer. We know that each rule converts a specific source range to a specific destination range. So to apply a rule to an arbitrary range, we split the range into three: The parts of the range before the rule applies, the parts of the range that intersect the rule and the parts of the range after the rule. Some of these parts can be empty, but that's OK.

From there, building a routine to iteratively apply each ruleset to the original ranges is not too tricky.
#+begin_src jupyter-python
  def split_range(r, rule):
      return [
          x if x[0] < x[1] else []
          for x in [
              (r[0], min(rule[0], r[1])),
              (max(r[0], rule[0]), min(r[1], rule[1])),
              (max(rule[1], r[0]), r[1]),
          ]
      ]


  def split_ranges(ranges, rule):
      dest, src, length = rule
      done, todo = [], []
      for l, m, r in [split_range(r, [src, src + length]) for r in ranges]:
          todo += [l] if l else []
          todo += [r] if r else []
          done += [(m[0] + dest - src, m[1] + dest - src)] if m else []
      return done, todo


  ranges = [(start, start + l) for start, l in more_itertools.chunked(seeds, 2)]
  for ruleset in rules:
      todo = ranges
      ranges = []
      for rule in ruleset:
          new_ranges, todo = split_ranges(todo, rule)
          ranges += new_ranges
      ranges += todo
  min(x[0] for x in ranges)
#+end_src
