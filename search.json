[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Solutions to the advent of code problems",
    "section": "",
    "text": "This is where I publish my solutions to the yearly Advent of Code problems. Most of the problems just get a short code snippet. These snippets are more or less self-contained, apart from some global imports that are shared for all problems in a given year. Some of the problems rely on code written for previous days of the same year, in a not particularly organised fashion.\nThe ones I had to think about slightly longer also have some text explaining my approach and talking through the problem. When I was feeling particularly inspired, I’ve also added some visualizations.\nEach year gets its own page - check them out on the sidebar to the left."
  },
  {
    "objectID": "qmd/2021.html",
    "href": "qmd/2021.html",
    "title": "2021 Solutions",
    "section": "",
    "text": "Code\nimport functools\nimport itertools\nimport os\nimport queue\nimport sys\nfrom collections import defaultdict\nfrom pathlib import Path\n\nimport numpy as np\nimport pandas as pd\n\nsys.path.insert(1, os.path.join(sys.path[0], \"..\"))\nimport utils\n\nload = utils.year_load(2021)\ndatadir = Path(\"../data/2021\")"
  },
  {
    "objectID": "qmd/2021.html#part-1",
    "href": "qmd/2021.html#part-1",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(1, \"np\")\n(np.diff(data) &gt; 0).sum()"
  },
  {
    "objectID": "qmd/2021.html#part-2",
    "href": "qmd/2021.html#part-2",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\n(pd.Series(data).rolling(3).sum().diff() &gt; 0).sum()"
  },
  {
    "objectID": "qmd/2021.html#part-1-1",
    "href": "qmd/2021.html#part-1-1",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = [x.split() for x in load(2)]\ndf = pd.DataFrame(data, columns=[\"instruction\", \"amount\"])\ndf[\"amount\"] = df[\"amount\"].apply(int)\ntotals = df.groupby(\"instruction\").sum()\n(totals.loc[\"forward\"] * (totals.loc[\"down\"] - totals.loc[\"up\"])).iat[0]"
  },
  {
    "objectID": "qmd/2021.html#part-2-1",
    "href": "qmd/2021.html#part-2-1",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nstate = (0, 0, 0)\nops = {\n    \"down\": lambda x, y: (x[0] + y, x[1], x[2]),\n    \"up\": lambda x, y: (x[0] - y, x[1], x[2]),\n    \"forward\": lambda x, y: (x[0], x[1] + y, x[2] + x[0] * y),\n}\nfor row in data:\n    state = ops[row[0]](state, int(row[1]))\nprint(state[1] * state[2])"
  },
  {
    "objectID": "qmd/2021.html#part-1-2",
    "href": "qmd/2021.html#part-1-2",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndf = pd.read_fwf(datadir / \"3.txt\", widths=[1] * 12, header=None)\n\n\ndef binarize(array):\n    return int(\"\".join(str(x) for x in array.reshape(-1)), 2)\n\n\nbits = df.median().to_numpy(dtype=int)\nbinarize(bits) * binarize(1 - bits)"
  },
  {
    "objectID": "qmd/2021.html#part-2-2",
    "href": "qmd/2021.html#part-2-2",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\noxygen = df\nco2 = df\nfor column in df.columns:\n    oxygen = oxygen[oxygen[column] == int(oxygen[column].median() + 0.5)]\n    if len(co2) &gt; 1:\n        co2 = co2[co2[column] != int(co2[column].median() + 0.5)]\nbinarize(oxygen.to_numpy()) * binarize(co2.to_numpy())"
  },
  {
    "objectID": "qmd/2021.html#part-1-3",
    "href": "qmd/2021.html#part-1-3",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(4, \"raw\").split(\"\\n\\n\")\nnumbers = np.array([int(x) for x in data[0].strip().split(\",\")])\nboards = np.array(\n    [int(x) for x in \" \".join(data[1:]).replace(\"\\n\", \" \").split()]\n).reshape(-1, 5, 5)\n\n\ndef winning_array(boards):\n    return ((boards == -1).all(axis=2) | (boards == -1).all(axis=1)).any(axis=1)\n\n\nfor number in numbers:\n    boards[np.where(boards == number)] = -1\n    if winning_array(boards).any():\n        break\nindex = np.where(winning_array(boards))\nnp.sum(np.ma.array(boards, mask=(boards == -1))[index]) * number"
  },
  {
    "objectID": "qmd/2021.html#part-2-3",
    "href": "qmd/2021.html#part-2-3",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFigure out which board will win last. Once it wins, what would its final score be?\n\n\nCode\nfor number in numbers:\n    boards[np.where(boards == number)] = -1\n    wins = winning_array(boards)\n    if wins.sum() == len(boards) - 1:\n        index = np.where(~wins)[0]\n    if wins.all():\n        break\nnp.sum(np.ma.array(boards, mask=(boards == -1))[index]) * number"
  },
  {
    "objectID": "qmd/2021.html#part-1-4",
    "href": "qmd/2021.html#part-1-4",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = pd.read_csv(datadir / \"5.txt\", names=[\"x1\", \"middle\", \"y2\"])\ndata[[\"y1\", \"x2\"]] = data[\"middle\"].apply(\n    lambda x: pd.Series(x.split(\"-&gt;\")).astype(\"int\")\n)\ngrid = np.zeros((1000, 1000))\n\n\ndef endpoints_to_line(x1, x2, y1, y2):\n    steps = max(abs(x1 - x2), abs(y1 - y2))\n    delta = np.array([np.sign(x2 - x1), np.sign(y2 - y1)])\n    points = [np.array([x1, y1]) + delta * n for n in range(steps + 1)]\n    return tuple(np.array(points).T.tolist())\n\n\non_axis = data[(data[\"x1\"] == data[\"x2\"]) | (data[\"y1\"] == data[\"y2\"])]\nfor row in on_axis.itertuples():\n    grid[endpoints_to_line(row.x1, row.x2, row.y1, row.y2)] += 1\n\n(grid &gt; 1).sum()"
  },
  {
    "objectID": "qmd/2021.html#part-2-4",
    "href": "qmd/2021.html#part-2-4",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nskewed = data[(data[\"x1\"] != data[\"x2\"]) & (data[\"y1\"] != data[\"y2\"])]\nfor row in skewed.itertuples():\n    grid[endpoints_to_line(row.x1, row.x2, row.y1, row.y2)] += 1\n\n(grid &gt; 1).sum()"
  },
  {
    "objectID": "qmd/2021.html#part-1-5",
    "href": "qmd/2021.html#part-1-5",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(6, \"np\")\npopulation, _ = np.histogram(data, range(10))\ntransition_matrix = np.roll(np.eye(9, dtype=int), 1, axis=1)\ntransition_matrix[6, 0] = 1\n(np.linalg.matrix_power(transition_matrix, 80) @ population).sum()"
  },
  {
    "objectID": "qmd/2021.html#part-2-5",
    "href": "qmd/2021.html#part-2-5",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\n(np.linalg.matrix_power(transition_matrix, 256) @ population).sum()"
  },
  {
    "objectID": "qmd/2021.html#part-1-6",
    "href": "qmd/2021.html#part-1-6",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(7, \"np\")\nnp.abs(data - np.median(data)).sum()"
  },
  {
    "objectID": "qmd/2021.html#part-2-6",
    "href": "qmd/2021.html#part-2-6",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef cost(position):\n    delta = np.abs(data - position)\n    return ((delta) * (delta + 1) / 2).sum()\n\n\noptions = [cost(int(data.mean())), cost(int(data.mean() + 0.5))]\nmin(options)"
  },
  {
    "objectID": "qmd/2021.html#part-1-7",
    "href": "qmd/2021.html#part-1-7",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nsegments = [line.split(\"|\")[1].split() for line in load(8)]\nmylen = np.vectorize(len)\nnp.isin(mylen(segments), [2, 3, 4, 7]).sum()"
  },
  {
    "objectID": "qmd/2021.html#part-2-7",
    "href": "qmd/2021.html#part-2-7",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThis is an obvious task for constraint programming. It feels a bit like cheating, so I’ll see if I can come up with a home-grown approach at a later stage. I’ll start by describing the segment pattern of each digit. I’m deliberately using numbers for the segment positions and letters for the segment names so that I don’t get confused.\nWe can do part 2 by exploiting the structure in our data.\nWe know that every digit occurs before the pipe for every row in our input.\nUsing that, we can immediately identify segment 1, segments {36} segments {24} and segments {57}.\nThe three five segment numbers let us disambiguate {147}, {25}, {36}. 147 occur in every group, 25 in only 1 and 36 in two\nThe three six segment numbers let us disambiguate {1267}, {345}.\n\n1 is the segment present in 3 but not in 2.\n2 is the segment present in 4, not present in 2, and present in every 6\n3 is the segment present in 2 which is not present in every 6\n4 is the segment present in 4, not present in 2, and not present in every 6\n5 is the segment not present in 4 which only occurs once in 5\n6 is the segment which is present in 2 and is present in every 6\n7 is the segment present in every 5, not present in every 6, not present in 4\nIt’s not super elegant, and I kind of prefer just using the generalised constraints programming."
  },
  {
    "objectID": "qmd/2021.html#part-1-8",
    "href": "qmd/2021.html#part-1-8",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = pd.read_fwf(datadir / \"9.txt\", widths=[1] * 100, header=None).to_numpy()\ndata = np.pad(data, pad_width=1, mode=\"constant\", constant_values=9)\nmask = (\n    (data &lt; np.roll(data, -1, axis=0))\n    & (data &lt; np.roll(data, 1, axis=0))\n    & (data &lt; np.roll(data, -1))\n    & (data &lt; np.roll(data, 1))\n)\nnp.ma.array(data + 1, mask=~mask).sum()"
  },
  {
    "objectID": "qmd/2021.html#part-2-8",
    "href": "qmd/2021.html#part-2-8",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef up(x, y):\n    return x, y + 1\n\n\ndef down(x, y):\n    return x, y - 1\n\n\ndef left(x, y):\n    return x - 1, y\n\n\ndef right(x, y):\n    return x + 1, y\n\n\nmoves = [up, down, left, right]\n\n\ndef basin(x, y):\n    visited = np.zeros(data.shape, dtype=bool)\n    neighbors = [(x, y)]\n    result = 0\n    while neighbors:\n        x, y = neighbors.pop()\n        if data[x, y] == 9 or visited[x, y]:\n            continue\n        result += 1\n        visited[x, y] = True\n        for move in moves:\n            new_x, new_y = move(x, y)\n            if not visited[new_x, new_y]:\n                neighbors.append((new_x, new_y))\n    return result\n\n\nlow_points = zip(*np.where(mask))\nsizes = list(map(lambda x: basin(*x), low_points))\nprint(np.product(sorted(sizes)[-3:]))"
  },
  {
    "objectID": "qmd/2021.html#part-1-9",
    "href": "qmd/2021.html#part-1-9",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nlines = load(10)\npairs = [\"[]\", \"()\", \"&lt;&gt;\", \"{}\"]\n\n\ndef normalize(string):\n    old_string = string\n    while True:\n        for pair in pairs:\n            string = string.replace(pair, \"\")\n        if string == old_string:\n            break\n        old_string = string\n    return string\n\n\nscores = {\")\": 3, \"]\": 57, \"}\": 1197, \"&gt;\": 25137}\ntotal = 0\nfor line in lines:\n    normalized = normalize(line)\n    indices = np.array([normalized.find(pair[1]) for pair in pairs])\n    if (indices == -1).all():\n        continue\n    index = min(index for index in indices if index != -1)\n    total += scores[normalized[index]]\nprint(total)"
  },
  {
    "objectID": "qmd/2021.html#part-2-9",
    "href": "qmd/2021.html#part-2-9",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndelimiters = \" ([{&lt;\"\nscores = []\nfor line in lines:\n    normalized = normalize(line)\n    indices = np.array([normalized.find(pair[1]) for pair in pairs])\n    if (indices != -1).any():\n        continue\n    scores.append(\n        functools.reduce(lambda x, y: 5 * x + delimiters.find(y), normalized[::-1], 0)\n    )\nint(np.median(scores))"
  },
  {
    "objectID": "qmd/2021.html#part-1-10",
    "href": "qmd/2021.html#part-1-10",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndef find_neighbors(x, y):\n    return (\n        (x - 1, x - 1, x - 1, x, x, x + 1, x + 1, x + 1),\n        (y - 1, y, y + 1, y - 1, y + 1, y - 1, y, y + 1),\n    )\n\n\ndef step(board):\n    board += 1\n    flashed = np.zeros(board.shape, dtype=bool)\n    indices = list(zip(*np.where(board &gt; 9)))\n    while indices:\n        x, y = indices.pop()\n        if flashed[x, y]:\n            continue\n        flashed[x, y] = True\n        neighbors = find_neighbors(x, y)\n        board[neighbors] += 1\n        for neighbor in zip(*neighbors):\n            if board[neighbor] &gt; 9:\n                indices.append(neighbor)\n    board[np.where(flashed)] = 0\n    return flashed.sum()\n\n\nresult = 0\ndata = pd.read_fwf(datadir / \"11.txt\", widths=[1] * 10, header=None).to_numpy(\n    dtype=float\n)\ndata = np.pad(data, pad_width=1, mode=\"constant\", constant_values=-np.inf)\narr = data.copy()\nfor i in range(100):\n    result += step(arr)\nprint(result)"
  },
  {
    "objectID": "qmd/2021.html#part-2-10",
    "href": "qmd/2021.html#part-2-10",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ncount = 0\narr = data.copy()\nwhile arr[1:-1, 1:-1].sum() &gt; 0:\n    step(arr)\n    count += 1\ncount"
  },
  {
    "objectID": "qmd/2021.html#part-1-11",
    "href": "qmd/2021.html#part-1-11",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndef flatten(mylist):\n    return (element for sublist in mylist for element in sublist)\n\n\ndef edges_to_tree(edges, repeat_visits=0):\n    tree = defaultdict(set)\n    for e1, e2 in edges:\n        tree[e1].add(e2)\n        tree[e2].add(e1)\n    return tree\n\n\ndef remove_node(tree, node):\n    tree = tree.copy()\n    neighbors = tree[node]\n    del tree[node]\n    for neighbor in neighbors:\n        tree[neighbor] = tree[neighbor] - set([node])\n    return tree\n\n\ndef paths(tree, node, end):\n    if node == end:\n        return [(end,)]\n    if not tree[node]:\n        return []\n    new_tree = tree if node == node.upper() else remove_node(tree, node)\n    return [\n        (node,) + x\n        for x in flatten([paths(new_tree, neighbor, end) for neighbor in tree[node]])\n    ]\n\n\nedges = [line.split(\"-\") for line in load(12)]\ntree = edges_to_tree(edges)\nlen(paths(tree, \"start\", \"end\"))"
  },
  {
    "objectID": "qmd/2021.html#part-2-11",
    "href": "qmd/2021.html#part-2-11",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef paths(tree):\n    def inner(subtree, node, end, state):\n        if node == end:\n            return [(end,)]\n        if not subtree[node]:\n            return []\n        new_tree = subtree if node == node.upper() else remove_node(subtree, node)\n        tail = [inner(new_tree, neighbor, end, state) for neighbor in subtree[node]]\n        if state == 1 and node != \"start\":\n            tail += [inner(subtree, neighbor, end, 0) for neighbor in subtree[node]]\n        return [(node,) + x for x in flatten(tail)]\n\n    return inner(tree, \"start\", \"end\", 1)\n\n\nlen(set(paths(tree)))"
  },
  {
    "objectID": "qmd/2021.html#part-1-12",
    "href": "qmd/2021.html#part-1-12",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nstart = load(13, \"np\")\narr = np.zeros(start.max(axis=0) + 1, dtype=bool)\narr[start[:, 0], start[:, 1]] = 1\n\ntop = arr[:655]\nbottom = arr[656:]\nbottom = np.pad(bottom, ((0, top.shape[0] - bottom.shape[0]), (0, 0)))\nprint((top | np.flip(bottom, 0)).sum())"
  },
  {
    "objectID": "qmd/2021.html#part-2-12",
    "href": "qmd/2021.html#part-2-12",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nreplacement = np.vectorize(lambda x: \"█\" if x else \" \")\ninstructions = [\n    \"x=655\",\n    \"y=447\",\n    \"x=327\",\n    \"y=223\",\n    \"x=163\",\n    \"y=111\",\n    \"x=81\",\n    \"y=55\",\n    \"x=40\",\n    \"y=27\",\n    \"y=13\",\n    \"y=6\",\n]\nfor instruction in instructions:\n    direction, position = instruction.split(\"=\")\n    position = int(position)\n    arr = arr.T if direction == \"y\" else arr\n    top = arr[:position]\n    bottom = arr[position + 1 :]\n    if top.shape[0] &lt; bottom.shape[0]:\n        top = np.pad(top, ((bottom.shape[0] - top.shape[0], 0), (0, 0)))\n    else:\n        bottom = np.pad(bottom, ((0, top.shape[0] - bottom.shape[0]), (0, 0)))\n    arr = np.flip(bottom, 0) | top\n    arr = arr.T if direction == \"y\" else arr\nfor row in replacement(arr.T):\n    print(\"\".join(row))"
  },
  {
    "objectID": "qmd/2021.html#part-1-13",
    "href": "qmd/2021.html#part-1-13",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nstate_string = \"VCOPVNKPFOOVPVSBKCOF\"\ndata = load(14)\ntransition_elements = \"\".join(line.replace(\" -&gt; \", \"\") for line in data)\nelements = sorted(set(state_string + transition_elements))\nn = len(elements)\n\n\ndef encode(pair):\n    return elements.index(pair[0]) * n + elements.index(pair[1])\n\n\ninitial_pairs = [encode(state_string[i : i + 2]) for i in range(len(state_string) - 1)]\ninitial_state = np.zeros(n**2, dtype=np.int64)\nfor pair in initial_pairs:\n    initial_state[pair] += 1\ntransition_matrix = np.zeros((n**2, n**2), dtype=np.int64)\nfor line in data:\n    source, target = line.split(\" -&gt; \")\n    transition_matrix[encode(source), encode(source[0] + target)] = 1\n    transition_matrix[encode(source), encode(target + source[1])] = 1\n\n\ndef count(state):\n    result = defaultdict(int)\n    result[state_string[0]] += 1\n    result[state_string[-1]] += 1\n    for index, number in enumerate(state):\n        result[elements[int(index % n)]] += number\n        result[elements[int(index // n)]] += number\n    return {k: int(v / 2) for k, v in result.items()}\n\n\ntotals = count(initial_state.T @ (np.linalg.matrix_power(transition_matrix, 10)))\npd.Series(totals).max() - pd.Series(totals).min()"
  },
  {
    "objectID": "qmd/2021.html#part-2-13",
    "href": "qmd/2021.html#part-2-13",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ntotals = count(initial_state.T @ (np.linalg.matrix_power(transition_matrix, 40)))\npd.Series(totals).max() - pd.Series(totals).min()"
  },
  {
    "objectID": "qmd/2021.html#part-1-14",
    "href": "qmd/2021.html#part-1-14",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis is a shortest path search, where we’ll use a priority queue to store the items and their cost. Reusing my A* implementation then gives\n\n\nCode\ndata = pd.read_fwf(datadir / \"15.txt\", widths=[1] * 100, header=None).to_numpy(\n    dtype=int\n)\n\n\ndef neighbors(state, data=None):\n    x, y = state\n    if data is None:\n        return []\n    xmax, ymax = data.shape\n    candidates = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n    return [c for c in candidates if 0 &lt;= c[0] &lt; xmax and 0 &lt;= c[1] &lt; ymax]\n\n\ndef cost(state, neighbor, data=None):\n    return 1 if data is None else 0 if state == neighbor else data[neighbor]\n\n\ndef heuristic(node, end):\n    return abs(node[0] - end[0]) + abs(node[1] - end[1])\n\n\nutils.astar((0, 0), (99, 99), neighbors, heuristic, cost, data=data)"
  },
  {
    "objectID": "qmd/2021.html#part-2-14",
    "href": "qmd/2021.html#part-2-14",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nx, y = data.shape\narr = np.zeros([5 * x, 5 * y], dtype=int)\nfor i in range(5):\n    for j in range(5):\n        arr[i * x : (i + 1) * x, j * y : (j + 1) * y] = data + i + j\narr = ((arr - 1) % 9) + 1\nutils.astar((0, 0), (499, 499), neighbors, heuristic, cost, data=arr)"
  },
  {
    "objectID": "qmd/2021.html#part-1-15",
    "href": "qmd/2021.html#part-1-15",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nnybbles = {hex(i)[2:]: bin(i)[2:].rjust(4, \"0\") for i in range(16)}\n\n\ndef parse(bitstring):\n    if len(bitstring) == 0 or set(bitstring) == set(\"0\"):\n        return 0, 0\n    version = int(bitstring[:3], 2)\n    offset = 3\n    type_id = int(bitstring[offset : offset + 3], 2)\n    offset += 3\n    if type_id == 4:\n        while True:\n            chunk = bitstring[offset : offset + 5]\n            offset += 5\n            if chunk[0] != \"1\":\n                break\n        return version, offset\n    kind = bitstring[offset]\n    offset += 1\n    if kind == \"0\":\n        length = int(bitstring[offset : offset + 15], 2)\n        offset += 15\n        target = offset + length\n        while offset != target:\n            dv, do = parse(bitstring[offset:])\n            version += dv\n            offset += do\n        return version, target\n    if kind == \"1\":\n        n_operators = int(bitstring[offset : offset + 11], 2)\n        offset += 11\n        for i in range(n_operators):\n            dv, do = parse(bitstring[offset:])\n            version += dv\n            offset += do\n        return version, offset\n\n\ndata = load(16)[0]\nbits = \"\".join(nybbles[x.lower()] for x in data)\nparse(bits)"
  },
  {
    "objectID": "qmd/2021.html#part-2-15",
    "href": "qmd/2021.html#part-2-15",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, we have to completely ignore the version number and actually do something with the data associated with each packet. Actually moving through the packet happens in the same way, but what we have to do at each level is sufficiently different that it’s not worth it to try and reuse the parsing function.\n\n\nCode\ndef evaluate_one_packet(bitstring):\n    offset = 3\n    type_id = int(bitstring[offset : offset + 3], 2)\n    offset += 3\n    if type_id == 4:\n        result = \"\"\n        while True:\n            chunk = bitstring[offset : offset + 5]\n            result += chunk[1:]\n            offset += 5\n            if chunk[0] == \"0\":\n                break\n        return int(result, 2), offset\n    kind = bitstring[offset]\n    offset += 1\n    operands = []\n    if kind == \"0\":\n        length = int(bitstring[offset : offset + 15], 2)\n        offset += 15\n        target = offset + length\n        while offset &lt; target:\n            operand, do = evaluate_one_packet(bitstring[offset:])\n            operands.append(operand)\n            offset += do\n    elif kind == \"1\":\n        n_operators = int(bitstring[offset : offset + 11], 2)\n        offset += 11\n        for i in range(n_operators):\n            operand, do = evaluate_one_packet(bitstring[offset:])\n            operands.append(operand)\n            offset += do\n    operators = [\n        sum,\n        np.product,\n        min,\n        max,\n        None,\n        lambda x: x[0] &gt; x[1],\n        lambda x: x[0] &lt; x[1],\n        lambda x: x[0] == x[1],\n    ]\n    return operators[type_id](operands), offset\n\n\nprint(evaluate_one_packet(bits)[0])"
  },
  {
    "objectID": "qmd/2021.html#part-1-16",
    "href": "qmd/2021.html#part-1-16",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\nFirst pen and paper solution for this year.\nThings to note:\n\nx and y are completely decoupled\nThere exists a time velocity x0 such that the probe will be within the target area for all t &gt; some ti\nAs long as the up velocity is greater than this, then by the time the probe reaches the baseline in y, it will have stopped in x.\nThe arc up and down is symmetric; a probe launched from y=0 at t=0 with v=v0 will hit y=0 at t=2v0 + 1\nThis probe will have velocity (-v0 - 1) at that point\nIf -v0 - 1 &lt; bottom of target, then the probe will entirely miss the target in the next step\nThe greater v0 is, the higher the probe will go; ymax = ½ v0 (v0 + 1)\nSo we just set -v0 - 1 = -126 =&gt; v0 = 125\nSo ymax = 125 * 126 / 2 = 7875.\n∎"
  },
  {
    "objectID": "qmd/2021.html#part-2-16",
    "href": "qmd/2021.html#part-2-16",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nxmin, xmax = 217, 240\nymin, ymax = -126, -69\nparabola = lambda v, t: (t * v - int(t * (t - 1) / 2))\n\ntime_map = defaultdict(list)\nfor vy in range(ymin, -ymin):\n    for time in [\n        t for t in range(1, 3 - 2 * ymin) if parabola(vy, t) in range(ymin, ymax + 1)\n    ]:\n        time_map[time].append(vy)\n\n\ndef x_times(vx):\n    times = [t for t in range(1, vx) if parabola(vx, t) in range(xmin, xmax + 1)]\n    if vx - 1 in times:\n        times += list(range(max(times) + 1, max(time_map.keys()) + 1))\n    return times\n\n\nresult = []\nfor vx in range(int(0.5 + np.sqrt(0.25 + 2 * xmin)), xmax + 1):\n    times = x_times(vx)\n    for time in times:\n        for vy in time_map[time]:\n            result.append((vx, vy))\nprint(len(set(result)))"
  },
  {
    "objectID": "qmd/2021.html#part-1-17",
    "href": "qmd/2021.html#part-1-17",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndef to_node(thing, depth):\n    if isinstance(thing, int):\n        return thing\n    elif isinstance(thing, Pair):\n        for node in thing.traverse():\n            node.depth += 1\n        return thing\n    else:\n        return Pair(thing[0], thing[1], depth + 1)\n\n\nclass Pair:\n    def __init__(self, left, right, depth=0):\n        self.depth = depth\n        self.left = to_node(left, depth)\n        self.right = to_node(right, depth)\n\n    def leftmost(self):\n        return self if isinstance(self.left, int) else self.left.leftmost()\n\n    def rightmost(self):\n        return self if isinstance(self.right, int) else self.right.rightmost()\n\n    def sum(self):\n        left = self.left if isinstance(self.left, int) else self.left.sum()\n        right = self.right if isinstance(self.right, int) else self.right.sum()\n        return 3 * left + 2 * right\n\n    def traverse(self):\n        left = [] if isinstance(self.left, int) else self.left.traverse()\n        right = [] if isinstance(self.right, int) else self.right.traverse()\n        return left + [self] + right\n\n    def reduce(self):\n        while True:\n            altered = False\n            altered = self.explode()\n            if not altered:\n                altered = self.split()\n                if not altered:\n                    return self\n\n    def split(self):\n        for node in self.traverse():\n            for d in [\"left\", \"right\"]:\n                val = getattr(node, d)\n                if isinstance(val, int) and val &gt;= 10:\n                    setattr(node, d, Pair(val // 2, val // 2 + val % 2, node.depth + 1))\n                    return True\n        return False\n\n    def explode(self):\n        traversal = self.traverse()\n        for idx, node in enumerate(traversal):\n            if node.depth == 4:\n                if idx == len(traversal) - 1:\n                    parent = traversal[idx - 1]\n                    direction = \"right\"\n                elif traversal[idx + 1].left == node:\n                    parent = traversal[idx + 1]\n                    direction = \"left\"\n                else:\n                    parent = traversal[idx - 1]\n                    direction = \"right\"\n                setattr(parent, direction, 0)\n                if idx != 0:\n                    if isinstance(traversal[idx - 1].left, int):\n                        traversal[idx - 1].left += node.left\n                    else:\n                        left_neighbor = traversal[idx - 1].left.rightmost()\n                        left_neighbor.right += node.left\n\n                if idx != len(traversal) - 1:\n                    if isinstance(traversal[idx + 1].right, int):\n                        traversal[idx + 1].right += node.right\n                    else:\n                        right_neighbor = traversal[idx + 1].right.leftmost()\n                        right_neighbor.left += node.right\n                return True\n        return False\n\n\nsnumbers = [eval(line) for line in load(18)]\nresult = Pair(*snumbers[0])\nfor snumber in snumbers[1:]:\n    result = Pair(result, Pair(*snumber)).reduce()\nprint(result.sum())"
  },
  {
    "objectID": "qmd/2021.html#part-2-17",
    "href": "qmd/2021.html#part-2-17",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nmaxval = 0\nfor left, right in itertools.permutations(snumbers, 2):\n    total = (Pair(left, right).reduce()).sum()\n    maxval = total if total &gt; maxval else maxval\nmaxval"
  },
  {
    "objectID": "qmd/2021.html#part-1-18",
    "href": "qmd/2021.html#part-1-18",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\nWe’ll start by generating the 24 rotation matrices. There are six possible ways of permuting the axes, and eight possible sign conventions. Half of the sign conventions will be left-handed, so we discard them\n\n\nCode\nrotations = []\nfor permutation in itertools.permutations([0, 1, 2], 3):\n    arr = np.zeros((3, 3), dtype=int)\n    arr[np.array([0, 1, 2]), permutation] = 1\n    for sign in itertools.product([-1, 1], repeat=3):\n        rotation = arr.copy() * sign\n        if np.linalg.det(rotation) &gt; 0:\n            rotations.append(rotation)\n\n\nThen we find overlapping scanners in the input and populate a map (x, y) with the matrices to convert from y coordinates to x coordinates\n\n\nCode\nfrom scipy.spatial.distance import pdist, squareform\n\nfoo = load(19, \"raw\")[:-1]\nscanners = foo.split(\"\\n\\n\")\nscanners = [\n    np.array(\n        [list(map(int, line.split(\",\"))) for line in scanner.split(\"\\n\")[1:]], dtype=int\n    )\n    for scanner in scanners\n]\n\ndistances = [squareform(pdist(scanner)) for scanner in scanners]\nmapping = {}\nfor a, b in itertools.combinations(range(len(scanners)), 2):\n    pairs = []\n    d0 = distances[a]\n    d1 = distances[b]\n    for i in range(len(d0)):\n        for j in range(len(d1)):\n            if len(np.intersect1d(d1[j], d0[i])) &gt;= 12:\n                pairs.append((i, j))\n    pairs = np.array(pairs)\n    if len(pairs) &lt; 12:\n        continue\n    x0 = scanners[a][pairs[:, 0]]\n    y0 = scanners[b][pairs[:, 1]]\n    for rotation in rotations:\n        c = x0[0] - y0[0] @ rotation\n        if (x0[1:] == (y0[1:] @ rotation + c)).all():\n            mapping[(a, b)] = [rotation, c]\n            mapping[(b, a)] = [rotation.T, -c @ rotation.T]\n            break\n\n\nWe do some linear algebra to extend this map to all the scanners\n\n\nCode\nwhile True:\n    done = True\n    for x in range(len(scanners)):\n        columns = [pair[1] for pair in mapping.keys() if pair[0] == x]\n        for y, z in itertools.combinations(columns, 2):\n            if (y, z) not in mapping:\n                done = False\n                Q1, a1 = mapping[(x, y)]\n                Q2, a2 = mapping[(x, z)]\n                mapping[(z, y)] = [Q1 @ Q2.T, (a1 - a2) @ Q2.T]\n                mapping[(y, z)] = [Q2 @ Q1.T, (a2 - a1) @ Q1.T]\n    if done:\n        break\n\n\nAnd then we convert all the initial coordinates to one representation and find its length\n\n\nCode\ncoords = [tuple(x) for x in scanners[0]]\nfor idx in range(1, len(scanners)):\n    Q, a = mapping[0, idx]\n    coords += [tuple(x) for x in (np.array(scanners[idx]) @ Q + a)]\nprint(len(set(coords)))"
  },
  {
    "objectID": "qmd/2021.html#part-2-18",
    "href": "qmd/2021.html#part-2-18",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWhat is the largest Manhattan distance between any two scanners?\n\n\nCode\nmaxval = 0\nfor i, j in itertools.combinations(range(len(scanners)), 2):\n    total = sum(abs(mapping[(i, j)][1]))\n    if total &gt; maxval:\n        maxval = total\nmaxval"
  },
  {
    "objectID": "qmd/2021.html#part-1-and-2",
    "href": "qmd/2021.html#part-1-and-2",
    "title": "2021 Solutions",
    "section": "Part 1 and 2",
    "text": "Part 1 and 2\n\n\nCode\ndata = load(20, \"raw\")\npixel_map = {\".\": 0, \"#\": 1}\nkey, array = data.split(\"\\n\\n\")\nkey = np.array([pixel_map[x] for x in key.strip()], dtype=bool)\nnew = np.array(\n    [[pixel_map[x] for x in line.strip()] for line in array.split(\"\\n\")[:-1]]\n)\nfor n in range(1, 51):\n    old = np.pad(new, 2, constant_values=(n % 2 == 0))\n    new = old.copy()\n    for i in range(1, len(old) - 1):\n        for j in range(1, len(old) - 1):\n            index = sum(\n                (2 ** np.arange(9)) * old[i - 1 : i + 2, j - 1 : j + 2].ravel()[::-1]\n            )\n            new[i, j] = key[index]\n    new = new[1:-1, 1:-1]\n    if n == 2 or n == 50:\n        print(new.sum())"
  },
  {
    "objectID": "qmd/2021.html#part-1-19",
    "href": "qmd/2021.html#part-1-19",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\npositions, scores, count = [4, 6], [0, 0], 0\n\n\ndef step_one(position, score, count):\n    position = (position + 3 * count + 5) % 10 + 1\n    return position, score + position, count + 3\n\n\ni = 0\nwhile max(scores) &lt; 1000:\n    positions[i], scores[i % 2], count = step_one(\n        positions[i % 2], scores[i % 2], count\n    )\n    i = 1 - i\ncount * min(scores)"
  },
  {
    "objectID": "qmd/2021.html#part-2-19",
    "href": "qmd/2021.html#part-2-19",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nstates = {((4, 0), (6, 0)): 1}\nwins = [0, 0]\n# The frequency table for the 3x3 dice\nrolls = [0, 0, 0, 1, 3, 6, 7, 6, 3, 1]\n\n\ndef step_one(states, player):\n    new_states = defaultdict(int)\n    for state in states:\n        for step in range(3, 10):\n            new_position = ((state[player][0] + step) - 1) % 10 + 1\n            new_score = state[player][1] + new_position\n            if new_score &gt;= 21:\n                wins[player] += states[state] * rolls[step]\n            else:\n                new_state = list(state)\n                new_state[player] = (new_position, new_score)\n                new_states[tuple(new_state)] += states[state] * rolls[step]\n    return new_states, wins\n\n\ni = 0\nwhile states:\n    states, wins = step_one(states, i)\n    i = 1 - i\n\nmax(wins)"
  },
  {
    "objectID": "qmd/2021.html#part-1-20",
    "href": "qmd/2021.html#part-1-20",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThe first part can be solved trivially by using numpy’s indexing\n\n\nCode\noffset = 50\nboard = np.zeros((101, 101, 101), dtype=int)\n\n\ndef parse_line(line):\n    command, line = line.split(\" \")\n    indices = [x.split(\"..\") for x in line.split(\",\")]\n    return command, [[int(x[0][2:]), int(x[1]) + 1] for x in indices]\n\n\ncommands = [parse_line(line) for line in load(22)]\nvalues = {\"on\": 1, \"off\": 0}\nmaxval = 0\nfor command, indices in commands:\n    idx = np.ravel(indices) + offset\n    if max(abs(idx)) &gt; maxval:\n        maxval = max(abs(idx))\n    if (idx &lt; 0).any() or (idx &gt; 100).any():\n        continue\n    board[idx[0] : idx[1], idx[2] : idx[3], idx[4] : idx[5]] = values[command]\nboard.sum()"
  },
  {
    "objectID": "qmd/2021.html#part-2-20",
    "href": "qmd/2021.html#part-2-20",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe above approach doesn’t work for part two since the field of play is too large; we have ~ 100k elements in each direction, which give ~10**15 elements in total; far too much to keep in memory.\nThe first step is to realise that the vast majority of the empty space is never touched – so there’s no reason to store all those zeros.\nWhat we can do instead is to store a set containing only the coordinates which are turned on. Turning on more coordinates corresponds to making the union with the new coordinate, while turning off coordinates is a set difference. This automatically accounts for not lighting coordinates which are already lit, and not turning off coordinates which are already off.\nUnfortunately, this is still too memory intensive – from the example solution, we see that at the end of the process, 2,758,514,936,282,235 coordinates are on, which is way too many to store individually.\nWe need an approach that only looks at corners of cuboids, and doesn’t need to store the individual coordinates at all.\nIf there were only “on” instructions, we could use the inclusion-exclusion principle, along with the fact that the intersection of two cuboids is always another cuboid, or empty.\nThat is, the volume lit by one “on” instruction is just the volume of the cuboid it represents. The volume lit by two is the sum of the volumes of each, minus the volume of their intersection. The volume lit by three is:\n\nThe volume of the individual cuboids\nMinus the volume of all the pairwise intersections\nPlus the volume of the triple intersection\n\nAnd this extends to the general case. The volume lit after the nth instruction, N, is:\nThe volume lit after the (n-1)th instruction plus the volume of N, minus the sum of the volumes of the pairwise intersection of N with all previous instructions, plus the sum of the volumes of intersection of N with all previously calculated pairs, and so on.\nTurning a cuboid off is equivalent to removing the intersection between it and all the other cuboids from the sum, and then accounting for the double counting by adding back the triple intersections etc. But that’s the same as we’re doing for the positive cuboid, except for the off cuboid we never add the volume of the individual cuboid\nWe’re going to need a way of calculating the intersection of two cuboids. But that’s just the intersection of 3 pairs of lines, since the cuboids are axis-aligned. And we can intersect two line segments and hence two cuboids as follows\n\n\nCode\ndef intersect_segments(x1, x2):\n    pair = [max(x1[0], x2[0]), min(x1[1], x2[1])]\n    return pair if pair[1] &gt; pair[0] else False\n\n\ndef intersect_cuboids(c1, c2):\n    result = [intersect_segments(*pair) for pair in zip(c1, c2)]\n    return result if all(result) else False\n\n\nThe segments were originally given as closed intervals, but the parsing converted them to open intervals. The length of each is thus the endpoint minus the starting point. The volume of a cuboid is just the product the three lengths:\n\n\nCode\ndef cuboid_volume(cuboid):\n    return np.product([[line[1] - line[0]] for line in cuboid])\n\n\nThe approach we’ll take is to process the list of instructions sequentially, calculating the various intersections as we go. They’ll go in a list where the first element represents the positive terms, and the second represents the negative terms. The final score is then just the sum of the positive values minus the sum of the negative values\nPutting it all together gives the following. For each instruction, we intersect with all previous cuboids, and swap the signs. If it’s an “on” instruction, we also add the whole region to the list of positive volumes.\n\n\nCode\ndef reboot(instructions):\n    state = [[], []]\n    for instruction, region in instructions:\n        extra = [region] if instruction == \"on\" else []\n        clipped_state = [\n            [c for cuboid in s if (c := intersect_cuboids(cuboid, region))]\n            for s in state\n        ]\n        state = [state[0] + clipped_state[1] + extra, state[1] + clipped_state[0]]\n    return sum(map(cuboid_volume, state[0])) - sum(map(cuboid_volume, state[1]))\n\n\nreboot(commands)"
  },
  {
    "objectID": "qmd/2021.html#part-1-21",
    "href": "qmd/2021.html#part-1-21",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis is definitely not pretty, and takes a bunch of time to run as well, but it works. This is a pathfinding problem: Given some initial state, our goal is to move to the final state with as small a cost as possible.\nThe tricky thing is to find the neighboring positions that can be reached from a given position with a valid move. There are only two types of moves\n\nRoom to hallway\nHallway to room\n\nThe third type (room straight to final room) is just the composition of the above two moves.\nOnce we have a method for finding neighbors, actually running the pathfinding is comparatively simple. This could probably be improved by including a heuristic for how far away a given state is from the finish, but getting finding and calculating a suitable heuristic is fiddly.\n\n\nCode\nvalue_to_letter = {0: \" \", 1: \"A\", 10: \"B\", 100: \"C\", 1000: \"D\"}\nletter_to_value = {v: k for k, v in value_to_letter.items()}\nnumber_to_room = {10**i: i for i in range(4)}\nroom_to_number = {v: k for k, v in number_to_room.items()}\n\n\ndef find_blockers(room, n):\n    top_row = list(range(4 * n, 4 * n + 7))\n    distances = [1, 2, 2, 2, 2, 2, 1]\n    left = top_row[: room + 2][::-1], np.cumsum(distances[: room + 2][::-1])\n    right = top_row[room + 2 :], np.cumsum(distances[room + 2 :])\n    return left, right\n\n\ndef find_moves(position, n=2):\n    position = np.array(position)\n\n    def is_endgame(room):\n        return set(position[n * room : n * (room + 1)]) &lt;= set(\n            [0, room_to_number[room]]\n        )\n\n    possible_moves = []\n    for i in [idx + 4 * n for idx, val in enumerate(position[4 * n :]) if val != 0]:\n\n        room = number_to_room[position[i]]\n        if not is_endgame(room):\n            continue\n\n        left, right = find_blockers(room, n)\n        moves, costs = left if i in left[0] else right\n\n        index = moves.index(i)\n        if (position[moves[:index]] != 0).any():\n            continue\n\n        offset = np.argwhere(position[n * room : n * (room + 1)] == 0)[0][0]\n        new_position = n * room + offset\n        cost = costs[index] + n - 1 - offset\n        possible_moves.append((i, new_position, cost))\n    for room in range(4):\n        target = room * n\n        if is_endgame(room):\n            continue\n        offset = np.argwhere(position[target : target + n])[-1][-1]\n        moves, costs = [], []\n        for block, steps in find_blockers(room, n):\n            free = np.maximum.accumulate(position[block]) == 0\n            if not free.any():\n                continue\n            n_free = np.argwhere(free)[-1][-1] + 1\n            moves += block[:n_free]\n            costs += list(steps[:n_free] + n - offset - 1)\n        possible_moves += [\n            (target + offset, move, cost) for move, cost in zip(moves, costs)\n        ]\n    return possible_moves\n\n\ndef navigate(source, destination):\n    n = (len(source) - 7) // 4\n    q = queue.PriorityQueue()\n    q.put((0, source))\n    seen = set()\n    while q:\n        cost, position = q.get()\n        if position == destination:\n            return cost\n        if position in seen:\n            continue\n        seen.add(tuple(position))\n        for source_index, target_index, distance in find_moves(position, n):\n            new_position = list(position)\n            value = position[source_index]\n            new_position[source_index] = 0\n            new_position[target_index] = value\n            q.put((cost + value * distance, tuple(new_position)))\n    return np.inf\n\n\nWith all of that out of the way, actually solving the puzzle is just a question of calling the navigate function. First for part 1\n\n\nCode\nsource = tuple(letter_to_value[x] for x in \"CDCABABD       \")\ndestination = tuple(letter_to_value[x] for x in \"AABBCCDD       \")\nnavigate(source, destination)"
  },
  {
    "objectID": "qmd/2021.html#part-2-21",
    "href": "qmd/2021.html#part-2-21",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\nAnd then for part 2\n\n\nCode\ns = tuple(letter_to_value[x] for x in \"CDDDCBCABABABCAD       \")\nd = tuple(letter_to_value[x] for x in \"AAAABBBBCCCCDDDD       \")\nnavigate(s, d)"
  },
  {
    "objectID": "qmd/2021.html#part-1-22",
    "href": "qmd/2021.html#part-1-22",
    "title": "2021 Solutions",
    "section": "Part 1",
    "text": "Part 1\nRarely in AOC have I had a worse ratio of thinking employed to code written - this code looks way simpler than for day 23, but getting there was a real challenge.\nI think this is the intended approach, since it uses the realisation that if we multiply z by 26 6 times, then to get back below zero, we need to divide 7 times. So each time there’s a divide, the value of w is fixed.\n\n\nCode\ndata = load(24, \"raw\")\nchunks = [[y.split() for y in x.split(\"\\n\") if y] for x in data.split(\"inp w\\n\")][1:]\n\nindices = [3, 4, 14]\ntable = [[chunk[index][2] for index in indices] for chunk in chunks]\ntriples = [[int(n) for n in row] for row in table]\n\n\ndef run(triple, z, w):\n    a, b, c = triple\n    if w == z % 26 + b:\n        return z // a\n    return (z // a) * 26 + w + c\n\n\nzs = [[0, 0]]\nfor triple in triples:\n    new_zs = []\n    for prefix, z in zs:\n        if triple[0] == 26:\n            w = z % 26 + triple[1]\n            ws = [w] if 1 &lt;= w &lt; 10 else []\n        else:\n            ws = range(1, 10)\n        new_zs += [(10 * prefix + w, run(triple, z, w)) for w in ws]\n    zs = new_zs\nmax(x[0] for x in zs)\n\n\nWe can be slightly smarter with pen and paper. The test is always z % 26 + something, which means that we always get out wn + cn for some n, since (z // a) * 26 % 26 = 0. Keeping track of the order in which the a = 1 and a = 26 instructions arrive, we can match each of the 14 instructions to exactly one other, giving a series of relationships like w1 = w14 + 8. Then it’s just a question of forcing the early digit of each pair to the highest possible allowed value."
  },
  {
    "objectID": "qmd/2021.html#part-2-22",
    "href": "qmd/2021.html#part-2-22",
    "title": "2021 Solutions",
    "section": "Part 2",
    "text": "Part 2\nAfter all that, luckily part 2 is trivial\n\n\nCode\nmin(int(x[0]) for x in zs)"
  },
  {
    "objectID": "qmd/2016.html",
    "href": "qmd/2016.html",
    "title": "2016 Solutions",
    "section": "",
    "text": "Code\nimport functools\nimport hashlib\nimport itertools\nimport os\nimport re\nimport sys\nfrom collections import defaultdict, deque\nfrom pathlib import Path\nfrom queue import PriorityQueue\n\nimport more_itertools\nimport numpy as np\nimport pandas as pd\nimport scipy\n\nsys.path.insert(1, os.path.join(sys.path[0], \"..\"))\n\nimport utils\n\nload = utils.year_load(2016)"
  },
  {
    "objectID": "qmd/2016.html#part-1",
    "href": "qmd/2016.html#part-1",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\nHow many blocks away is Easter Bunny HQ?\n\n\nCode\ninstructions = load(1)[0].split(\", \")\nposition = np.array([0, 0])\ndirection = np.array([0, 1])\nrotations = {\n    \"R\": np.array([[0, 1], [-1, 0]], dtype=int),\n    \"L\": np.array([[0, -1], [1, 0]], dtype=int),\n}\nfor instruction in instructions:\n    direction = rotations[instruction[0]] @ direction\n    position += direction * int(instruction[1:])\nsum(abs(position))"
  },
  {
    "objectID": "qmd/2016.html#part-2",
    "href": "qmd/2016.html#part-2",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThen, you notice the instructions continue on the back of the Recruiting Document. Easter Bunny HQ is actually at the first location you visit twice.\n\n\nCode\nposition = np.array([0, 0])\ndirection = np.array([0, 1])\nseen = {tuple(position): True}\nfor instruction in instructions:\n    direction = rotations[instruction[0]] @ direction\n    for i in range(int(instruction[1:])):\n        position += direction\n        if tuple(position) in seen:\n            break\n        seen[tuple(position)] = True\n    else:\n        continue\n    break\nsum(abs(position))"
  },
  {
    "objectID": "qmd/2016.html#part-1-1",
    "href": "qmd/2016.html#part-1-1",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ncommands = {\"U\": -1j, \"D\": 1j, \"L\": -1, \"R\": 1}\ngrid = {(x % 3) + 1j * (x // 3): x + 1 for x in range(9)}\n\n\ndef update(point, grid, instructions):\n    for instruction in instructions:\n        new_point = point + commands[instruction]\n        if new_point in grid:\n            point = new_point\n    return point\n\n\npoint = 1 + 1j\npassword = \"\"\ninstructions = load(2)\nfor line in instructions:\n    point = update(point, grid, line)\n    password += str(grid[point])\npassword"
  },
  {
    "objectID": "qmd/2016.html#part-2-1",
    "href": "qmd/2016.html#part-2-1",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ngrid = {\n    0j + 2: 1,\n    1j + 1: 2,\n    1j + 2: 3,\n    1j + 3: 4,\n    2j: 5,\n    2j + 1: 6,\n    2j + 2: 7,\n    2j + 3: 8,\n    2j + 4: 9,\n    3j + 1: \"A\",\n    3j + 2: \"B\",\n    3j + 3: \"C\",\n    4j + 2: \"D\",\n}\npoint = 2j\npassword = \"\"\nfor line in instructions:\n    point = update(point, grid, line)\n    password += str(grid[point])\npassword"
  },
  {
    "objectID": "qmd/2016.html#part-1-2",
    "href": "qmd/2016.html#part-1-2",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = np.array(load(3, \"int\"), dtype=int)\n\n\ndef is_valid(triangle):\n    x, y, z = triangle\n    return x + y &gt; z and x + z &gt; y and y + z &gt; x\n\n\nsum(map(is_valid, data))"
  },
  {
    "objectID": "qmd/2016.html#part-2-2",
    "href": "qmd/2016.html#part-2-2",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsum(map(is_valid, data.T.ravel().reshape(-1, 3)))"
  },
  {
    "objectID": "qmd/2016.html#part-1-3",
    "href": "qmd/2016.html#part-1-3",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndef parse_line(room):\n    checksum = room[-6:-1]\n    sector_id = int(room[:-7].split(\"-\")[-1])\n    name = \"-\".join(room.split(\"-\")[:-1])\n    return name, sector_id, checksum\n\n\ndef calculate_checksum(name):\n    occurrences = list(zip(*np.unique(list(name.replace(\"-\", \"\")), return_counts=True)))\n    return \"\".join(x[0] for x in sorted(occurrences, key=lambda x: [-x[1], x[0]])[:5])\n\n\ndata = [parse_line(l) for l in load(4)]\nsum(\n    sector_id\n    for name, sector_id, checksum in data\n    if calculate_checksum(name) == checksum\n)"
  },
  {
    "objectID": "qmd/2016.html#part-2-3",
    "href": "qmd/2016.html#part-2-3",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nreal_rooms = [room[:2] for room in data if calculate_checksum(room[0]) == room[2]]\n\n\ndef decrypt(name, offset):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    shifted_alphabet = \"\".join(x for x in np.roll(list(alphabet), -offset % 26))\n    return name.translate(str.maketrans(alphabet, shifted_alphabet)), offset\n\n\n[answer for room in real_rooms if \"north\" in (answer := decrypt(*room))[0]]"
  },
  {
    "objectID": "qmd/2016.html#part-1-4",
    "href": "qmd/2016.html#part-1-4",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nimport hashlib\n\nh = hashlib.md5()\nprefix = \"wtnhxymk\"\npassword = \"\"\ni = 0\nwhile len(password) &lt; 8:\n    s = hashlib.md5((prefix + str(i)).encode(encoding=\"UTF-8\")).hexdigest()\n    if s[:5] == \"0\" * 5:\n        password = password + s[5]\n    i += 1\npassword"
  },
  {
    "objectID": "qmd/2016.html#part-2-4",
    "href": "qmd/2016.html#part-2-4",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\npassword = [None] * 8\ni = 0\nwhile any([x is None for x in password]):\n    s = hashlib.md5((prefix + str(i)).encode(encoding=\"UTF-8\")).hexdigest()\n    if s[:5] == \"0\" * 5 and s[5] in \"01234567\" and password[int(s[5])] is None:\n        password[int(s[5])] = s[6]\n    i += 1\n\"\".join(password)"
  },
  {
    "objectID": "qmd/2016.html#part-1-5",
    "href": "qmd/2016.html#part-1-5",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nmessages = load(6)\n\"\".join(pd.DataFrame([list(x) for x in messages]).mode().values[0])"
  },
  {
    "objectID": "qmd/2016.html#part-2-5",
    "href": "qmd/2016.html#part-2-5",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nfoo = np.array([list(x) for x in messages])\ns = \"\"\nfor i in range(foo.shape[1]):\n    letters, counts = np.unique(foo[:, i], return_counts=True)\n    s += letters[counts.argmin()]\ns"
  },
  {
    "objectID": "qmd/2016.html#part-1-6",
    "href": "qmd/2016.html#part-1-6",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(7)\nabba = re.compile(r\"(.)(?!\\1)(.)\\2\\1\")\nbracketed_abba = re.compile(r\"\\[[^]]*(.)(?!\\1)(.)\\2\\1.*?\\]\")\n\n\ndef supports_tls(haystack):\n    return bool(re.search(abba, haystack)) and not bool(\n        re.search(bracketed_abba, haystack)\n    )\n\n\nsum(supports_tls(line) for line in data)"
  },
  {
    "objectID": "qmd/2016.html#part-2-6",
    "href": "qmd/2016.html#part-2-6",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\nPart two is more regex wrangling, except the patterns can overlap now. We could spend time figuring out exactly how to account for that, or we can import the third party regex module which does it for us automagically.\n\n\nCode\nimport regex\n\n\ndef supports_ssl(haystack):\n    aba = regex.compile(r\"(.)(?!\\1)(.)\\1\")\n    bracket_split = [x.split(\"[\") for x in haystack.split(\"]\")]\n    outside, inside = itertools.zip_longest(*bracket_split, fillvalue=\"\")\n    abas = [\n        match\n        for fragment in outside\n        for match in regex.findall(aba, fragment, overlapped=True)\n    ]\n    for a, b in abas:\n        bab = f\"{b}{a}{b}\"\n        if any(bab in fragment for fragment in inside):\n            return True\n    return False\n\n\nsum(supports_ssl(line) for line in data)"
  },
  {
    "objectID": "qmd/2016.html#part-1-7",
    "href": "qmd/2016.html#part-1-7",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\narray = np.zeros((6, 50), dtype=int)\nlines = [x.split() for x in load(8)]\nfor instructions in lines:\n    if instructions[0] == \"rect\":\n        row, col = [int(a) for a in instructions[1].split(\"x\")]\n        array[:col, :row] = 1\n        continue\n    row = int(instructions[2].split(\"=\")[1])\n    amount = int(instructions[-1])\n    if instructions[1] == \"column\":\n        array = array.T\n    array[row] = np.roll(array[row], amount)\n    if instructions[1] == \"column\":\n        array = array.T\narray.sum()"
  },
  {
    "objectID": "qmd/2016.html#part-2-7",
    "href": "qmd/2016.html#part-2-7",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\n[[\"\".join(\"█\" if char else \" \" for char in line)] for line in array]"
  },
  {
    "objectID": "qmd/2016.html#part-1-8",
    "href": "qmd/2016.html#part-1-8",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(9)[0]\npart1 = data\n\n\ndef count(s, part2=False):\n    total = 0\n    while s:\n        if s[0] != \"(\":\n            total += 1\n            s = s[1:]\n            continue\n        end = s.index(\")\")\n        chars, repeat = map(int, s[1:end].split(\"x\"))\n        s = s[end + 1 :]\n        if part2:\n            total += repeat * count(s[:chars], True)\n        else:\n            total += repeat * chars\n        s = s[chars:]\n    return total\n\n\ncount(data)"
  },
  {
    "objectID": "qmd/2016.html#part-2-8",
    "href": "qmd/2016.html#part-2-8",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ncount(data, part2=True)"
  },
  {
    "objectID": "qmd/2016.html#part-1-9",
    "href": "qmd/2016.html#part-1-9",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(10)\nwiring = {}\nstate = defaultdict(list)\nfor line in data:\n    command = re.findall(\"(bot|value|output) (\\d+)\", line)\n    numbers = [int(x[1]) for x in command]\n    names = [x[0] for x in command]\n    if len(command) == 2:\n        state[numbers[1]].append(numbers[0])\n    else:\n        wiring[numbers[0]] = [x for x in zip(names[1:], numbers[1:])]\n\nqueue = deque([x for x in start if len(state[x]) == 2])\noutput = [0] * 21\n\n\ndef step():\n    current = queue.popleft()\n    values = sorted(state[current])\n    state[current] = []\n    left, right = wiring[current]\n    for idx, (name, value) in enumerate(wiring[current]):\n        if name == \"bot\":\n            state[value].append(values[idx])\n            if len(state[value]) == 2:\n                queue.append(value)\n        else:\n            output[value] = values[idx]\n    return current, values\n\n\nwhile True:\n    current, values = step()\n    if values == [17, 61]:\n        break\ncurrent"
  },
  {
    "objectID": "qmd/2016.html#part-2-9",
    "href": "qmd/2016.html#part-2-9",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWith Part 1 out of the way, part 2 is just\n\n\nCode\nwhile queue:\n    step()\nnp.product(output[:3])"
  },
  {
    "objectID": "qmd/2016.html#part-1-10",
    "href": "qmd/2016.html#part-1-10",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis one looks difficult, but I don’t think it is too tricky. Given that we are in floor \\(n\\), the valid next positions are us at floor \\(n+1\\) or \\(n - 1\\), with up to two items moved; with the items moved being subject to the puzzle constraints.\nSo I think the way to go is A*.\n\n\nCode\nfrom more_itertools import grouper\n\nn_floors = 4\n\n\ndef distance_estimate(state, end):\n    items = state[1]\n    return sum((val / 2) * (n_floors - i - 1) for i, val in enumerate(items))\n\n\ndef is_valid(items):\n    generators, chips = state[::2], state[1::2]\n    return all(\n        (chip == generator) or (chip not in generators)\n        for chip, generator in zip(chips, generators)\n    )\n\n\ndef normalize(items):\n    return tuple(x for pair in sorted(list(grouper(items, 2))) for x in pair)\n\n\ndef constrained_neighbors(state):\n    floor, items = state\n    active_indices = [index for index, val in enumerate(items) if val == floor]\n    neighbors = set()\n    for new_floor in [floor + 1, floor - 1]:\n        if not (0 &lt;= new_floor &lt; n_floors):\n            continue\n        moves = [[x] for x in active_indices]\n        if new_floor == floor + 1:\n            moves = itertools.chain(moves, itertools.combinations(active_indices, 2))\n        for move in moves:\n            new_items = list(items)\n            for index in move:\n                new_items[index] = new_floor\n            if is_valid(new_items):\n                neighbors.add((new_floor, normalize(new_items)))\n    return neighbors\n\n\nstate = 0, (0, 0, 0, 0, 1, 1, 1, 1, 1, 2)\ntarget = 3, (3,) * len(state[1])\nutils.astar(state, target, constrained_neighbors, distance_estimate)"
  },
  {
    "objectID": "qmd/2016.html#part-2-10",
    "href": "qmd/2016.html#part-2-10",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\nExtending this to part 2 without changing anything is possible, but the whole thing takes about a minute and a half to run. When I have time, I’ll come back and look at it again.\nReducing the search space by only letting the elevator move down with one item at a time reduced the runtime to about half. I’m not 100% convinced the restriction is always valid, but it did work in this case.\n\n\nCode\nstate = 0, (0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2)\ntarget = 3, (3,) * len(state[1])\nutils.astar(state, target, constrained_neighbors, distance_estimate)"
  },
  {
    "objectID": "qmd/2016.html#part-1-11",
    "href": "qmd/2016.html#part-1-11",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis is a fairly straightforward implementation of the problem description, with no particular cleverness going on. We have two types of instructions - ones that take two operands, and ones that take only one, and we can treat those together.\n\n\nCode\ndef run(program, registers=None):\n    if registers is None:\n        registers = defaultdict(int)\n    ip = 0\n    while ip &lt; len(program):\n        instruction = program[ip]\n        operator, operands = instruction[0], instruction[1:]\n        if operator in [\"cpy\", \"jnz\"]:\n            source, destination = operands\n            value = int(source) if source not in \"abcd\" else registers[source]\n            if operator == \"cpy\":\n                registers[destination] = value\n            if operator == \"jnz\" and value != 0:\n                ip += int(destination) - 1\n        elif operator in [\"inc\", \"dec\"]:\n            registers[operands[0]] += 2 * (operator == \"inc\") - 1\n        ip += 1\n    return registers[\"a\"]\n\n\ndata = [line.split(\" \") for line in load(12)]\nrun(data)"
  },
  {
    "objectID": "qmd/2016.html#part-2-11",
    "href": "qmd/2016.html#part-2-11",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nregisters = defaultdict(int)\nregisters[\"c\"] = 1\nrun(data, registers)"
  },
  {
    "objectID": "qmd/2016.html#part-1-12",
    "href": "qmd/2016.html#part-1-12",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nfrom utils import astar\n\n\ndef is_valid(x, y, secret=1362):\n    if x &lt; 0 or y &lt; 0:\n        return False\n    val = x * x + 3 * x + 2 * x * y + y + y * y + secret\n    ones = f\"{val:b}\".count(\"1\")\n    return (ones % 2) == 0\n\n\ndef neighbors(state):\n    x, y = state\n    candidates = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n    return [candidate for candidate in candidates if is_valid(*candidate)]\n\n\ndef distance_function(point, target):\n    return abs(point[0] - target[0]) + abs(point[1] - target[1])\n\n\nstart = (1, 1)\ntarget = 31, 39\nutils.astar(start, target, neighbors, distance_function)"
  },
  {
    "objectID": "qmd/2016.html#part-2-12",
    "href": "qmd/2016.html#part-2-12",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nlen(utils.bfs((1, 1), lambda cost, state: cost &gt; 50, neighbors, return_visited=True))"
  },
  {
    "objectID": "qmd/2016.html#part-1-13",
    "href": "qmd/2016.html#part-1-13",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nimport hashlib\n\n\ndef infinite_triples(prefix, part=1):\n    r1 = r\"(.)\\1\\1\"\n    r2 = r\"(.)\\1\\1\\1\\1\"\n    n = 1\n    while True:\n        s = hashlib.md5((prefix + str(n)).encode()).hexdigest()\n        if part == 2:\n            for i in range(2016):\n                s = hashlib.md5(s.encode()).hexdigest()\n        if r := re.search(r1, s):\n            yield (r.groups(1)[0], re.findall(r2, s))\n        else:\n            yield False\n        n += 1\n\n\ndef nth_key_index(prefix, n=64, part=1):\n    triples = filter(lambda x: x[1], enumerate(infinite_triples(prefix, part)))\n    window = [next(triples)]\n    current = 0\n    while current &lt; n:\n        idx, (triple, _) = window.pop(0)\n        while not window or window[-1][0] &lt; idx + 1000:\n            window.append(next(triples))\n        active_quints = [char for triple in window[:-1] for char in triple[1][1]]\n        if triple in active_quints:\n            current += 1\n    return idx + 1\n\n\nnth_key_index(\"yjdafjpo\")"
  },
  {
    "objectID": "qmd/2016.html#part-2-13",
    "href": "qmd/2016.html#part-2-13",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\nI was a little uncertain about how to write this cleanly – all of the logic from part one is the same, the only difference is how the hash is generated. In the end, I made a toggle in the infinite_triples function, which is why part 2 can be solved by writing just:\n\n\nCode\nnth_key_index(\"yjdafjpo\", part=2)"
  },
  {
    "objectID": "qmd/2016.html#part-1-14",
    "href": "qmd/2016.html#part-1-14",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\nAnother round of the chinese remainder theorem.\n\n\nCode\nfrom utils import crt\n\ndata = [[int(x) for x in re.findall(r\"\\d+\", line)] for line in load(15)]\nremainders = [(x[1], -(x[-1] + x[0])) for x in data]\ncrt(remainders)"
  },
  {
    "objectID": "qmd/2016.html#part-2-14",
    "href": "qmd/2016.html#part-2-14",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nremainders.append([11, -(len(remainders) + 1)])\ncrt(remainders)"
  },
  {
    "objectID": "qmd/2016.html#part-1-15",
    "href": "qmd/2016.html#part-1-15",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nstart = [1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1]\nlength = 272\n\n\ndef solve(prefix, length):\n    while len(prefix) &lt; length:\n        prefix = prefix + [0] + [1 ^ x for x in prefix[::-1]]\n    s = prefix[:length]\n    while len(s) % 2 == 0:\n        s = abs(np.diff(s))[::2] ^ 1\n    return s\n\n\nprint(*solve(start, length), sep=\"\")"
  },
  {
    "objectID": "qmd/2016.html#part-2-15",
    "href": "qmd/2016.html#part-2-15",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nprint(*solve(start, 35651584), sep=\"\")"
  },
  {
    "objectID": "qmd/2016.html#part-1-16",
    "href": "qmd/2016.html#part-1-16",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\nBFS to the rescue. I wanted to do A*, but the “distance from 3,3” heuristic didn’t seem like it would give much. Then I dropped to Dijkstra, but realised that if all steps cost the same, that’s just BFS.\n\n\nCode\nstart = (0, \"bwnlcvfs\")\n\n\ndef neighbors(position, path):\n    chars = hashlib.md5(path.encode()).hexdigest()[:4]\n    directions = \"UDLR\"\n    deltas = -1j, 1j, -1, 1\n    candidates = [\n        (position + delta, path + direction)\n        for delta, direction, char in zip(deltas, directions, chars)\n        if char in \"bcdef\"\n    ]\n    return [\n        candidate\n        for candidate in candidates\n        if 0 &lt;= candidate[0].real &lt; 4 and 0 &lt;= candidate[0].imag &lt; 4\n    ]\n\n\nq = deque([start])\nwhile q:\n    position, path = q.popleft()\n    if position == 3 + 3j:\n        result = path[len(start[1]) :]\n        break\n    q += deque(neighbors(position, path))\nresult"
  },
  {
    "objectID": "qmd/2016.html#part-2-16",
    "href": "qmd/2016.html#part-2-16",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nq = deque([start])\ni = 0\nwhile q:\n    position, path = q.popleft()\n    if position == 3 + 3j:\n        result = len(path) - len(start[1])\n        continue\n    q += deque(neighbors(position, path))\n    i += 1\nresult"
  },
  {
    "objectID": "qmd/2016.html#part-2-17",
    "href": "qmd/2016.html#part-2-17",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndata = np.array([1 if char == \"^\" else 0 for char in load(18)[0]], dtype=int)\nleft_right = [1, 0, 1]\nrows = []\nfor i in range(40):\n    rows.append(data)\n    data = (scipy.ndimage.convolve(data, left_right, mode=\"constant\") == 1).astype(int)\n(np.array(rows) == 0).sum()"
  },
  {
    "objectID": "qmd/2016.html#part-2-18",
    "href": "qmd/2016.html#part-2-18",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2 I should probably check to see if I ever hit a row that I’ve seen before, and then use the repeated cycle to avoid having to calculate that many rows. Or I can just brute force it and not care:\n\n\nCode\nfor i in range(400000 - 40):\n    rows.append(data)\n    data = (scipy.ndimage.convolve(data, left_right, mode=\"constant\") == 1).astype(int)\n(np.array(rows) == 0).sum()"
  },
  {
    "objectID": "qmd/2016.html#part-1-17",
    "href": "qmd/2016.html#part-1-17",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis problem – with rotations by 1 and deletions only of neighboring elves is definitely calling for a deque:\n\n\nCode\nlimit = 100\nnumbers = list(range(1, limit + 1))\nqueue = deque(numbers)\nwhile queue:\n    queue.rotate(-1)\n    s = queue.popleft()\ns"
  },
  {
    "objectID": "qmd/2016.html#part-2-19",
    "href": "qmd/2016.html#part-2-19",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\nUnfortunately, the same approach won’t work here, since the rotations to the middle of the queue really ruin everything.\nWhat we can do instead is notice that the pattern of deletions correspond to leaving every third elf alive, starting just after halfway around the circle. To avoid interference from potentially dead elves, we can play the game in rounds, with one round ending whenever an elf at the start of the line would have died. In each round then, a number of elves at the start of the line get to take presents, a number in the middle do nothing, and a number at the end are eliminated from the game. What each of these lists looks like is not too hard to determine:\n\n\nCode\ndef one_round(mylist):\n\n    l = len(mylist)\n    n = int((l + 2) / 3)\n    middle = mylist[int(l / 2) + 2 - l % 2 :: 3]\n    return mylist[n : int(l / 2)] + middle + mylist[:n]\n\n\ni = 3005290\nx = list(range(1, i + 1))\nwhile len(x) &gt; 1:\n    x = one_round(x)\nx[0]"
  },
  {
    "objectID": "qmd/2016.html#part-1-18",
    "href": "qmd/2016.html#part-1-18",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = sorted(\n    [[int(x) for x in line.split(\"-\")] for line in load(20)], key=lambda x: x[0]\n)\nlow, high = data[0]\nfor new_low, new_high in data[1:]:\n    if high + 1 &lt; new_low:\n        break\n    else:\n        high = max(high, new_high)\nhigh + 1"
  },
  {
    "objectID": "qmd/2016.html#part-2-20",
    "href": "qmd/2016.html#part-2-20",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWe’ll start by merging the overlapping banned ranges together. Then, the high point of one range and the low point of the next range define a range of allowed values (endpoints not included). We can sum the length of these to get the total number of allowed values.\n\n\nCode\ndef merge_ranges(data):\n    result = []\n    initial, final = data[0]\n    for low, high in data[1:]:\n        if final + 1 &gt;= low:\n            final = max(high, final)\n        else:\n            result += [initial, final]\n            initial, final = low, high\n    result += [initial, final]\n    return result\n\n\n(\n    0\n    - ranges[0]\n    + sum([high - low - 1 for low, high in zip(ranges[1::2], ranges[2::2])])\n    + 4294967295\n    - ranges[-1]\n)"
  },
  {
    "objectID": "qmd/2016.html#part-1-19",
    "href": "qmd/2016.html#part-1-19",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = [x.split() for x in load(21)]\ns = \"abcdefgh\"\n\n\ndef update(s, line, part=1):\n    operands = line[2], line[-1]\n    if line[0] == \"reverse\":\n        l, r = sorted(map(int, operands))\n        s = s[:l] + s[l : r + 1][::-1] + s[r + 1 :]\n    elif line[0] == \"swap\":\n        if line[1] == \"letter\":\n            l, r = map(lambda x: s.index(x), operands)\n        else:\n            l, r = map(int, operands)\n        l, r = sorted([l, r])\n        s = s[:l] + s[r] + s[l + 1 : r] + s[l] + s[r + 1 :]\n    elif line[0] == \"rotate\":\n        if line[1] == \"left\":\n            rotation = -int(operands[0])\n        elif line[1] == \"right\":\n            rotation = int(operands[0])\n        else:\n            if part == 1:\n                index = s.index(operands[1])\n                rotation = 1 + index + (index &gt;= 4)\n            if part == 2:\n                rotation = reverse_rotation(s, operands[1])\n        if part == 2:\n            rotation = -rotation\n        rotation = rotation % len(s)\n        s = s[-rotation:] + s[:-rotation]\n    elif line[0] == \"move\":\n        source, dest = map(int, operands)\n        if part == 2:\n            source, dest = dest, source\n        tmp = s[:source] + s[source + 1 :]\n        s = tmp[:dest] + s[source] + tmp[dest:]\n    return s\n\n\nfor line in data:\n    s = update(s, line)\n\ns"
  },
  {
    "objectID": "qmd/2016.html#part-2-21",
    "href": "qmd/2016.html#part-2-21",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\nOuch. move, swap and reverse should be easy to do backwards, since they’re self-inverses (potentially with the arguments swapped). The issue is rotate. When we have to go left/right a fixed number of steps there’s no problem, since we just go the other way. For the last one the issue is that the amount we have to rotate by depends on what the state was prior to the rotation. Luckily there aren’t that many possible rotations, so the best approach seems to be to just to see which potential preimage string gives the correct answer when rotated.\n\n\nCode\ndef rotate_based_on(s, char):\n    index = s.index(char)\n    rotation = 1 + index + (index &gt;= 4)\n    rotation = rotation % len(s)\n    return s[-rotation:] + s[:-rotation]\n\n\ndef reverse_rotation(s, char):\n    for i, original_string in [(i, s[-i:] + s[:-i]) for i in range(len(s))]:\n        if rotate_based_on(original_string, char) == s:\n            return -i\n\n\ns = \"fbgdceah\"\nfor line in data[::-1]:\n    s = update(s, line, part=2)\ns"
  },
  {
    "objectID": "qmd/2016.html#part-1-20",
    "href": "qmd/2016.html#part-1-20",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(22, \"int\")\ndata.sort(key=lambda x: x[-2])\n\n\ndef binary_search(key, haystack):\n    key = key[3]\n    left, right = 0, len(haystack)\n    while (right - left) &gt; 1:\n        midpoint = int((left + right) / 2)\n        if haystack[midpoint][-2] &gt;= key:\n            right = midpoint\n        else:\n            left = midpoint\n    return right\n\n\nresult = 0\nfor idx1, val in enumerate(data):\n    if val[3] == 0:\n        continue\n    idx2 = binary_search(val, data)\n    result += len(data[idx2:]) + (idx2 &lt;= idx1)\nresult"
  },
  {
    "objectID": "qmd/2016.html#part-2-22",
    "href": "qmd/2016.html#part-2-22",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\nJust another graph search. There’s only one empty space, so we can uniquely define the current state by the location of the empty space, and the location of the data we’re trying to move.\n\n\nCode\nsize = np.array(data)[:, :2].max(axis=0)\ngrid = np.ones(size + 1, dtype=int)\ndata = np.array(data)\ngrid[tuple(data[np.where(data[:, 2] &gt; 200)][:, :2].T)] = -1\nsource = tuple(data[-1][:2])\ngrid[source] = 0\ntarget = size[0], 0\n\n\ndef heuristic(x, y):\n    to_data = abs(x[0] - y[0]) + abs(x[1] - y[1])\n    return 4 * (abs(y[0]) + abs(y[1]) - 1) + to_data - 1\n\n\ndef neighbors(x, y):\n    new_states = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        new_x = x[0] + dx, x[1] + dy\n        if (\n            new_x[0] &lt; 0\n            or new_x[1] &lt; 0\n            or new_x[0] &gt; size[0]\n            or new_x[1] &gt; size[1]\n            or grid[new_x] == -1\n        ):\n            continue\n        if new_x == y:\n            new_states.append((new_x, (x[0], x[1])))\n        else:\n            new_states.append((new_x, y))\n    return new_states\n\n\nqueue = PriorityQueue()\nqueue.put((0, source, target))\ncosts = defaultdict(lambda: np.inf)\ncosts[source, target] = 0\ni = 0\nwhile queue.qsize() &gt; 0:\n    i += 1\n    _, x, y = queue.get()\n    if y == (0, 0):\n        result = costs[x, y]\n        break\n\n    for a, b in neighbors(x, y):\n        current_cost = costs[x, y] + 1\n        if current_cost &lt; costs[a, b]:\n            costs[a, b] = current_cost\n            queue.put((current_cost + heuristic(a, b), a, b))\nresult"
  },
  {
    "objectID": "qmd/2016.html#part-1-21",
    "href": "qmd/2016.html#part-1-21",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ntoggle_map = {\"inc\": \"dec\", \"tgl\": \"inc\", \"dec\": \"inc\", \"cpy\": \"jnz\", \"jnz\": \"cpy\"}\n\n\ndef run(program, registers=None):\n    if registers is None:\n        registers = {\"a\": 0, \"b\": 0, \"c\": 0, \"d\": 0}\n\n    def extract_operands(ip):\n        instruction = program[ip]\n        return instruction[0], instruction[1:]\n\n    def evaluate_operand(x):\n        return int(x) if x not in \"abcd\" else registers[x]\n\n    ip = 0\n    i = 0\n    while ip &lt; len(program):\n        i += 1\n        operator, operands = extract_operands(ip)\n        if operator in [\"cpy\", \"jnz\"]:\n            source, destination = operands\n            value = evaluate_operand(source)\n            if operator == \"cpy\":\n                registers[destination] = value\n            if operator == \"jnz\" and value != 0:\n                ip += evaluate_operand(destination) - 1\n        elif operator in [\"inc\", \"dec\"]:\n            registers[operands[0]] += 2 * (operator == \"inc\") - 1\n        elif operator == \"tgl\":\n            destination = ip + evaluate_operand(operands[0])\n            try:\n                operator, operands = extract_operands(destination)\n                operator = toggle_map[operator]\n                program[destination] = [operator] + operands\n            except IndexError:\n                pass\n        ip += 1\n    return registers[\"a\"]\n\n\ndata = [line.split(\" \") for line in load(\"23\")]\nregisters = {\"a\": 7, \"b\": 0, \"c\": 0, \"d\": 0}\nrun(data, registers)"
  },
  {
    "objectID": "qmd/2016.html#part-2-23",
    "href": "qmd/2016.html#part-2-23",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\nJust setting the registers to registers = {\"a\": 12, \"b\": 0, \"c\": 0, \"d\": 0} didn’t work, since the code was running incredibly slowly. I ended up analysing my input script instead. The first line copied a to b, and lines 2-16 multiplied a by (b - 1), decreased b by one and set c to 2b (ish). Then came the toggle instruction, and the two instructions after that sent us back to line 2.\nSome things that stood out here were that c was an even number, decreasing by 2 each iteration so tgl c tried to toggle every other instruction, starting at the end of the program and moving back towards the tgl instruction itself. That means that the loop before the toggle instruction is unaffected for a long time, and so after the ith iteration we have a = n * (n - 1) * (n - 2) * … * (n - i). This continues until b = 2, when the tgl instruction finally toggles the jnz on line 17. At that point we have a = factorial(n). The (now-toggled) last section of the program then just adds the product of the numeric arguments on line 21 and 22.\nAnd that’s the final answer."
  },
  {
    "objectID": "qmd/2016.html#part-1-22",
    "href": "qmd/2016.html#part-1-22",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis was a bit of a roller coaster. I originally used my pre-existing bfs code to search the maze, and it was unbelievably slow. Instead of investigating I decided to try and transform the maze, and found a conceptual approach which was horribly over-engineered, but probably would have worked. Before I finished implementing it, I thought of trying another BFS, less general and hence faster, and it ran more than fast enough. Oh well.\nI still liked the original approach though. The idea was to simplify the graph of the maze via the following transformations:\n\nDelete all empty (non-goal) nodes with only two neighbors by directly connecting their neighbors with a single edge, with a weight \\(w = w_1 + w_2\\)\nRecursively remove all empty dead ends.\nIdentify bottlenecks in the graph, i.e. nodes whose removal would disconnect the graph. From there, generate the block-cut tree of the graph, and simplify each component of the block-cut to just the cut vertices and the goal nodes. This basically means that the problem of finding the shortest path X-&gt;Y is reduced to finding the shortest path to and from a given bottleneck, and then stitching the paths together.\n\nIt was fun to think about even though I didn’t use it in the end.\n\n\nCode\nfrom scipy.cluster.hierarchy import DisjointSet\n\nparse = lambda x: -2 if x == \"#\" else -1 if x == \".\" else int(x)\ndata = np.array([[parse(char) for char in line] for line in load(24)])\n\n\ndef encode(mask):\n    return set([x + 1j * y for x, y in zip(*np.where(mask))])\n\n\nnodes = np.where(data &gt;= 0)\norder = data[nodes].argsort()\nnodes = [x + 1j * y for x, y in zip(*[index[order] for index in nodes])]\ndistances = np.ones((len(nodes), len(nodes))) * np.inf\nnode_indices = {n: idx for idx, n in enumerate(nodes)}\nopen_squares = encode(data &gt; -2)\ngraph = defaultdict(list)\n\nfor square in open_squares:\n    for delta in (1, 1j):\n        if square + delta in open_squares:\n            graph[square].append(square + delta)\n            graph[square + delta].append(square)\n\nfor node in nodes:\n    idx = node_indices[node]\n    queue = deque([(0, node)])\n    visited = set()\n    while queue and (distances[idx] == np.inf).any():\n        cost, state = queue.popleft()\n        if state in visited:\n            continue\n        visited.add(state)\n        if state in nodes:\n            new_idx = node_indices[state]\n            distances[idx, new_idx] = cost\n            distances[new_idx, idx] = cost\n        for neighbor in graph[state]:\n            if neighbor not in visited:\n                queue.append((cost + 1, neighbor))\n\nminval = np.inf\nfor permutation in itertools.permutations(range(1, len(nodes))):\n    indices = (0,) + permutation[:-1], permutation\n    if (total := sum(distances[indices])) &lt; minval:\n        minval = total\nint(minval)"
  },
  {
    "objectID": "qmd/2016.html#part-2-24",
    "href": "qmd/2016.html#part-2-24",
    "title": "2016 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nminval = np.inf\nfor permutation in itertools.permutations(range(1, len(nodes))):\n    indices = (0,) + permutation, permutation + (0,)\n    if (total := sum(distances[indices])) &lt; minval:\n        minval = total\nint(minval)"
  },
  {
    "objectID": "qmd/2016.html#part-1-23",
    "href": "qmd/2016.html#part-1-23",
    "title": "2016 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis is an interesting problem, because it requires more thinking and less coding. Blindly running the code provided in my input leads to infinite loops, and the question is then how to analyse these. In particular, we’re asked for an input that matches an infinite sequence of alternating ones and zeros, and we don’t really have any way of knowing that a sequence that looks promising doesn’t start to diverge after 100, 1000 or even 1,000,000 terms. Instead, I decided to analyse the provided code and understand what it was doing. After a bit of conversion, I found it to be equivalent to the following snippet:\ndef clock(start):\n    a = 0\n    while True:\n        if a == 0:\n            a = start + 2550\n        yield a % 2\n        a = a // 2\nBut that’s just the binary representation of (start + 2550) reversed and repeated endlessly. So we’re looking for the smallest number \\(n\\) such that n + 2550 has a binary representation of the form \\(101010\\ldots\\)\n\n\nCode\nx = 2\nwhile x &lt; 2550:\n    x = 4 * x + 2\nx - 2550"
  },
  {
    "objectID": "qmd/2023.html",
    "href": "qmd/2023.html",
    "title": "2023 Solutions",
    "section": "",
    "text": "Code\nimport dataclasses\nimport functools\nimport itertools\nimport os\nimport re\nimport sys\nfrom collections import defaultdict, deque, namedtuple\nfrom queue import PriorityQueue\n\nimport more_itertools\nimport numpy as np\nimport pandas as pd\nimport scipy\n\nsys.path.insert(1, \"..\")\n\nimport utils\n\nload = utils.year_load(2023)"
  },
  {
    "objectID": "qmd/2023.html#part-1",
    "href": "qmd/2023.html#part-1",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nNot much going on in part one. We need to extract the digits in each line and then add together \\(10\\times\\) all the first digits and all the last digits.\n\n\nCode\ndata = [[int(char) for char in line if char in \"0123456879\"] for line in load(1)]\n10 * sum(x[0] for x in data) + sum(x[-1] for x in data)"
  },
  {
    "objectID": "qmd/2023.html#part-2",
    "href": "qmd/2023.html#part-2",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part two, we need to work with the string representation of the numbers. The examples show that the numbers can overlap, so we want a string like “fiveight” to show a “5” first and then an “8”.\nWe are only interested in the first and last digits of the string, so this could be done using a sliding window. Or we could hack it by padding the string representation of the number and doing a search and replace:\n\n\nCode\nnumber_names = [\n    (\"one\", \"one1one\"),\n    (\"two\", \"two2two\"),\n    (\"three\", \"three3three\"),\n    (\"four\", \"four4four\"),\n    (\"five\", \"five5five\"),\n    (\"six\", \"six6six\"),\n    (\"seven\", \"seven7seven\"),\n    (\"eight\", \"eight8eight\"),\n    (\"nine\", \"nine9nine\"),\n]\ndata = load(1, \"raw\")\nfor pair in number_names:\n    data = data.replace(pair[0], pair[1])\n\ndata = data.split(\"\\n\")[:-1]\ndata = [[int(char) for char in line if char in \"0123456879\"] for line in data]\n10 * sum(x[0] for x in data) + sum(x[-1] for x in data)"
  },
  {
    "objectID": "qmd/2023.html#part-1-1",
    "href": "qmd/2023.html#part-1-1",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThe most fiddly task in part 1 is parsing the input. Each line is a single game, with the game id appearing first and then the game outcome, separated by a colon. Each game consists of multiple rounds (delimited by a semicolon) and each round reveals multiple colours (delimited by commas).\nSo we split on the colon to separate the game id from the outcome, then split the outcome on semicolons to get each round, and finally split each round on commas to find the colours. A bit of regex let’s us finally get to a list of three integers as the representation of a round.\nOnce we have that, we can compare each round in a game with the maximum number of [red, green, blue] cubes available and see if it is possible. A game fails if any single round is impossible.\n\n\nCode\ndef parse_game_round(game_round):\n    colormap = {\"red\": 0, \"green\": 1, \"blue\": 2}\n    regex = r\"([0-9]*) (red|green|blue)\"\n    result = [0, 0, 0]\n    for v, c in [re.search(regex, entry).groups() for entry in game_round.split(\",\")]:\n        result[colormap[c]] = int(v)\n    return result\n\n\ntotal = 0\ngames = [\n    np.array([parse_game_round(x) for x in line.split(\":\")[1].split(\";\")])\n    for line in load(2)\n]\n\nfor idx, game in enumerate(games):\n    if ((game - [12, 13, 14]) &lt;= 0).all():\n        total += idx + 1\ntotal"
  },
  {
    "objectID": "qmd/2023.html#part-2-1",
    "href": "qmd/2023.html#part-2-1",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWith part 1 out of the way, part 2 is trivial: we get the same representation for each game as before, and just calculate the maximum for each coordinate in any round, and then multiply those three numbers together.\n\n\nCode\nsum(np.product(game.max(axis=0)) for game in games)"
  },
  {
    "objectID": "qmd/2023.html#part-1-2",
    "href": "qmd/2023.html#part-1-2",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nIt seems the theme for AOC this year is “let’s make things annoying to parse”.\nWe’ll need to extract the values and locations of all the numbers in the grid, and then compare that with the locations of the symbols. To get the coordinates that neighbor a symbol we can use a neat convolution trick. To get the coordinates of each number we’ll loop over all the lines in the grid, and use a regex to find the numbers.\nOnce we have that, we can find the desired value by finding the set intersetion of the number-coordinates and the neighbor coordinates; if that’s non-empty, we add the number to a running total.\n\n\nCode\ndata = load(3)\nsymbols = np.array([[(c not in \"0123456789\") and c != \".\" for c in l] for l in data])\nw = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nneighbors = scipy.ndimage.convolve(symbols, w, mode=\"constant\")\nneighbors = set(zip(*np.where(neighbors)))\nnumbers = {}\nfor i, row in enumerate(data):\n    for n in re.finditer(\"\\d+\", row):\n        numbers[frozenset((i, j) for j in range(*n.span()))] = int(n.group())\nsum(numbers[key] if key & neighbors else 0 for key in numbers)"
  },
  {
    "objectID": "qmd/2023.html#part-2-2",
    "href": "qmd/2023.html#part-2-2",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nAfter part 1, part 2 is pretty simple. We can use the same (coordinates) -&gt; number mapping as before, and then just loop over all locations in the grid that have a value of “*”. We find the neighbors of each star, intersect with all the numbers coordinates, and only use the ones that intersect exactly two numbers\n\n\nCode\ntotal = 0\noffsets = np.array(list(zip(*np.where(w)))) - 1\nfor star in zip(*np.where(np.array([[c for c in l] for l in data]) == \"*\")):\n    neighbors = set([tuple(x) for x in star + offsets])\n    values = [numbers[key] for key in numbers if key & neighbors]\n    total += values[0] * values[1] if len(values) == 2 else 0\ntotal"
  },
  {
    "objectID": "qmd/2023.html#part-1-3",
    "href": "qmd/2023.html#part-1-3",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nAfter the interesting parsing tasks of the last few days, today was straightforward. Part one can be boiled down to this oneliner, which I don’t even think is completely illegible\n\n\nCode\nsum(int(2 ** (len(set(row[1:11]) & set(row[11:])) - 1)) for row in load(4, \"int\"))"
  },
  {
    "objectID": "qmd/2023.html#part-2-3",
    "href": "qmd/2023.html#part-2-3",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nI could have found some way of saving the intersections from part 1 so that I didn’t have to recalculate in part two, but it’s not that complicated.\n\n\nCode\ndata = load(4, \"int\")\ncounts = np.ones(len(data), dtype=int)\nfor i, row in enumerate(data):\n    wins = len(set(row[1:11]) & set(row[11:]))\n    counts[i + 1 : i + wins + 1] += counts[i]\nsum(counts)"
  },
  {
    "objectID": "qmd/2023.html#part-1-4",
    "href": "qmd/2023.html#part-1-4",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThe first part is a straightforward implementation of the requirements.\nTo parse the file, we first split on “” to get each of the sections separately, then for each line of each section, we extract all of the integers. These are all positive, so we can do that with the regex “(+̣)”. After skipping through lines which don’t contain integers, we have a sensible representation for our data.\nAfter that it’s just a question of following through what happens to each initial value: for each one we scan through the rulesets in order, and when we find a rule in a ruleset that matches we convert it to the new value and move on. If we don’t find a rule that matches we’re told that the converted value is the same as the original one.\n\n\nCode\n[seeds], *rules = [\n    [\n        [int(x) for x in ints]\n        for line in groups.split(\"\\n\")\n        if (ints := re.findall(\"(\\d+)\", line))\n    ]\n    for groups in load(5, \"raw\").split(\"\\n\\n\")\n]\n\nminval = np.inf\nfor seed in seeds:\n    current = seed\n    for ruleset in rules:\n        for destination, source, length in ruleset:\n            if source &lt;= current &lt; source + length:\n                current = current + destination - source\n                break\n    if current &lt; minval:\n        minval = current\nminval"
  },
  {
    "objectID": "qmd/2023.html#part-2-4",
    "href": "qmd/2023.html#part-2-4",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part two we need to be a bit cleverer. We know that each rule converts a specific source range to a specific destination range. So to apply a rule to an arbitrary range, we split the range into three: The parts of the range before the rule applies, the parts of the range that intersect the rule and the parts of the range after the rule. Some of these parts can be empty, but that’s OK.\nFrom there, building a routine to iteratively apply each ruleset to the original ranges is not too tricky.\n\n\nCode\ndef split_range(r, rule):\n    return [\n        x if x[0] &lt; x[1] else []\n        for x in [\n            (r[0], min(rule[0], r[1])),\n            (max(r[0], rule[0]), min(r[1], rule[1])),\n            (max(rule[1], r[0]), r[1]),\n        ]\n    ]\n\n\ndef split_ranges(ranges, rule):\n    dest, src, length = rule\n    done, todo = [], []\n    for l, m, r in [split_range(r, [src, src + length]) for r in ranges]:\n        todo += [l] if l else []\n        todo += [r] if r else []\n        done += [(m[0] + dest - src, m[1] + dest - src)] if m else []\n    return done, todo\n\n\nranges = [(start, start + l) for start, l in more_itertools.chunked(seeds, 2)]\nfor ruleset in rules:\n    todo = ranges\n    ranges = []\n    for rule in ruleset:\n        new_ranges, todo = split_ranges(todo, rule)\n        ranges += new_ranges\n    ranges += todo\nmin(x[0] for x in ranges)"
  },
  {
    "objectID": "qmd/2023.html#part-1-5",
    "href": "qmd/2023.html#part-1-5",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nWe can set up an equation for how far the boat will move in a given time, \\(t\\) when waiting for a given period \\(w\\) at the start, to wit \\[\nd(t, w) = w(t-w)\n\\]\nWe are interested in which values of \\(w\\) give \\(d(t_0, w) &gt; d_0\\), for the \\(d_0, t_0\\) pairs we are given in the input, which is the same as exploring when the parabola described by \\(-w^2 +wt_0 - d_0\\) is positive. This parabola has a maximum at \\(w = \\frac{t_0}{2}\\), and it’s positive region (if any) will lie between the two roots. The roots are given by\n\\[\nw_{1,2} = \\frac{t_0 \\mp \\sqrt{t_0^2 - 4d_0^2}}{2};\n\\]\nand for each \\((d_0, t_0)\\) pair we are interested in how many integers lie in the open interval \\((w_1, w_2)\\)\n\n\nCode\nts, ds = np.array(load(6, \"int\"))\nΔs = np.sqrt(ts**2 - 4 * ds)\nnp.prod(np.floor(ts / 2 + Δs / 2 - 1e-10) - np.ceil(ts / 2 - Δs / 2 + 1e-10) + 1)"
  },
  {
    "objectID": "qmd/2023.html#part-2-5",
    "href": "qmd/2023.html#part-2-5",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, we don’t need to change anything.\n\n\nCode\nt = int(\"\".join([str(x) for x in ts]))\nd = int(\"\".join([str(x) for x in ds]))\nΔ = np.sqrt(t**2 - 4 * d)\nnp.floor(t / 2 + Δ / 2 - 1e-10) - np.ceil(t / 2 - Δ / 2 + 1e-10) + 1"
  },
  {
    "objectID": "qmd/2023.html#part-1-6",
    "href": "qmd/2023.html#part-1-6",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis feels doable. The key is to find a method to compare two hands of cards. We can use np.unique to get the count of how many times each unique value appears in the hand, which is almost exactly what we need. If we sort this count, then two hands will compare correctly if we compare their count tuples, since tuples sort lexicographically. The final comparator is [counts, [card_value for card in hand]], to correctly sort hands of the same type but with different values.\n\n\nCode\ndef counts(hand, part=1):\n    hand = [x for x in hand if x != \"J\"] if part == 2 else hand\n    _, counts = np.unique([x for x in hand], return_counts=True)\n    counts = sorted(counts, reverse=True) if hand else [0]\n    counts[0] += 5 - len(hand)\n    return counts\n\n\ndata = [x.strip().split() for x in load(7)]\norder = sorted(\n    data, key=lambda row: [counts(row[0]), [\"23456789TJQKA\".index(c) for c in row[0]]]\n)\n\nsum([int(x[1]) for x in order] * np.arange(1, 1 + len(order)))"
  },
  {
    "objectID": "qmd/2023.html#part-2-6",
    "href": "qmd/2023.html#part-2-6",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nPart 2 was similar enough to part 1 that I just made a flag in the counts function and changed the order of the card values\n\n\nCode\norder = sorted(\n    data,\n    key=lambda row: [\n        counts(row[0], part=2),\n        [\"J23456789TQKA\".index(c) for c in row[0]],\n    ],\n)\n\nsum([int(x[1]) for x in order] * np.arange(1, 1 + len(order)))"
  },
  {
    "objectID": "qmd/2023.html#part-1-7",
    "href": "qmd/2023.html#part-1-7",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nFor part 1 we build a dictionary of left, right instructions for each node, which makes following a path from start to end easy.\n\n\nCode\ninstructions, lines = load(8, \"raw\").split(\"\\n\\n\")\ninstructions = instructions.strip()\ndata = [words for line in lines.split(\"\\n\") if (words := re.findall(\"[A-Z]+\", line))]\nnodes = {node: {\"L\": left, \"R\": right} for node, left, right in data}\nnode = \"AAA\"\ni = 0\nwhile node != \"ZZZ\":\n    node = nodes[node][instructions[i % len(instructions)]]\n    i += 1\ni"
  },
  {
    "objectID": "qmd/2023.html#part-2-7",
    "href": "qmd/2023.html#part-2-7",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nPart 2 screams cycle checking, and indeed it is. The state at any given time is given by the current node and the index of the instruction list. If we ever see the same state twice, we know we’re in a cycle, and can figure out the period. All of the cycles turn out to have periods that match the offset from the start, so we can just use the lcm to find the common period. If some of the cycles had had a different offset, we would have need the full chinese remainder theorem.\n\n\nCode\nimport math\n\ni = 0\nperiods = []\n\n\ndef find_cycle(node):\n    seen = {}\n    i = 0\n    z = None\n    while (node, i % len(instructions)) not in seen:\n        seen[node, i % len(instructions)] = i\n        node = nodes[node][instructions[i % len(instructions)]]\n        i += 1\n        if node[-1] == \"Z\":\n            z = i\n    period = i - seen[(node, i % len(instructions))]\n    return period, z % period\n\n\nperiods, congruences = list(\n    zip(*[find_cycle(node) for node in nodes if node[-1] == \"A\"])\n)\nmath.lcm(*periods)"
  },
  {
    "objectID": "qmd/2023.html#part-1-8",
    "href": "qmd/2023.html#part-1-8",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis one’s pretty straightforward: calculate all the needed differences; add the last element of each difference to the calculation.\n\n\nCode\ndef score(line, part=1):\n    total = 0\n    if part == 2:\n        line = line[::-1]\n    while any(line):\n        total += line[-1]\n        line = [line[i] - line[i - 1] for i in range(1, len(line))]\n    return total\n\n\nsum(score(line) for line in load(9, \"int\"))"
  },
  {
    "objectID": "qmd/2023.html#part-2-8",
    "href": "qmd/2023.html#part-2-8",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\n…and part 2 is simple enough that it can be included in part 1 with a flag\n\n\nCode\nsum(score(line, part=2) for line in load(9, \"int\"))"
  },
  {
    "objectID": "qmd/2023.html#part-1-9",
    "href": "qmd/2023.html#part-1-9",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nFor part 1 we find the two directions leading away from the starting point, and follow the path along each one at the same pace. The point where they overlap is the point furthest away from the start, so we return that.\n\n\nCode\ndata = np.pad(\n    np.array([[char for char in line.strip()] for line in load(10)]),\n    1,\n    constant_values=\".\",\n)\nconnections = {\n    \"-\": [(0, -1), (0, 1)],\n    \"|\": [(-1, 0), (1, 0)],\n    \"L\": [(-1, 0), (0, 1)],\n    \"J\": [(-1, 0), (0, -1)],\n    \"7\": [(1, 0), (0, -1)],\n    \"F\": [(1, 0), (0, 1)],\n    \".\": [],\n}\nΔs = np.array([[1, 0], [0, 1], [-1, 0], [0, -1]])\npoint = np.array(next(zip(*np.where(data == \"S\"))))\n(lx, lv), (rx, rv) = [\n    (point + Δ, Δ) for Δ in Δs if tuple(-Δ) in connections[data[tuple(point + Δ)]]\n]\n\n\ndef update(point, direction):\n    options = connections[data[tuple(point)]]\n    new_direction = np.array(\n        options[1] if tuple(-direction) == options[0] else options[0]\n    )\n    return point + new_direction, new_direction\n\n\ni = 1\nleft_path = [point, lx]\nright_path = [rx]\nwhile not np.allclose(lx, rx):\n    lx, lv = update(lx, lv)\n    left_path.append(lx)\n    rx, rv = update(rx, rv)\n    right_path.append(rx)\n    i += 1\ni"
  },
  {
    "objectID": "qmd/2023.html#part-2-9",
    "href": "qmd/2023.html#part-2-9",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, we need some way of distinguishing points inside from outside the circuit. Since the lines that make up the boundary of the circuit never cross, this is a point in polygon problem. We could solve it by raytracing: for every point in the polygon we can draw all rays to the outside edge and see if they cross the boundary of the polygon an odd number of times. If they do, the point is inside the polygon. We could also look at the winding number of the polygon with respect the the point: points inside will have a nonzero winding number, while points outside will have a positive winding number.\nUltimately, what I ended up doing was just blowing up the grid to double size, flood filling the outside and looking at the even coordinate values of whatever was left. It’s stupid, but it works.\n\n\nCode\nys, xs = zip(*(left_path + right_path[:-1][::-1]))\ndy, dx = np.diff([ys + (ys[0],), xs + (xs[0],)], axis=1)\nboard = np.ones((data.shape[0] * 2, data.shape[1] * 2))\nys, xs = map(np.array, [ys, xs])\nboard[2 * ys, 2 * xs] = 0\n\nboard[2 * ys + dy, 2 * xs + dx] = 0\nboard = np.pad(board[1:-1, 1:-1], 1, constant_values=0)\npoints = deque([(1, 1)])\nwhile points:\n    point = points.popleft()\n    if board[point] == 0:\n        continue\n    board[point] = 0\n    for Δ in Δs:\n        nb = tuple(Δ + point)\n        if board[nb]:\n            points.append(nb)\nint(board[::2, ::2].sum())"
  },
  {
    "objectID": "qmd/2023.html#part-1-10",
    "href": "qmd/2023.html#part-1-10",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nI liked this puzzle, and I feel that I managed to come up with an OK slick array solution. We can get the coordinates of the original galaxies and the empty rows using np.where. For each empty row we can increase the first coordinate of the galaxies below it by some amount, and, mutatis mutandis, we can do the same for the empty columns.\nThat gives us a set of new coordinates, and we need to find the sum of all the manhattan distances from one point to the others. for any pair of points \\(i, j\\), that’s \\(\\left|x_i - x_j\\right| +\\left|y_i - y_j\\right|\\); we can construct the entire matrix by taking the row vector of coordinates, and subtracting from it the column vector of the same coordinates and relying on numpy’s broadcasting magic.\n\n\nCode\ndef solve(s=1):\n    y, x = np.where(data == \"#\")\n\n    empty_r = [i for i in range(len(data)) if all(data[i] == \".\")]\n    empty_c = [i for i in range(len(data)) if all(data[:, i] == \".\")]\n    new_y = y + s * np.array([y &gt; empty_r[i] for i in range(len(empty_r))]).sum(axis=0)\n    new_x = x + s * np.array([x &gt; empty_c[i] for i in range(len(empty_c))]).sum(axis=0)\n    return (\n        abs(new_y - new_y.reshape(-1, 1)) + abs(new_x - new_x.reshape(-1, 1))\n    ).sum() // 2\n\n\ndata = load(11, \"chararray\")\nsolve()"
  },
  {
    "objectID": "qmd/2023.html#part-2-10",
    "href": "qmd/2023.html#part-2-10",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe second part is pretty trivially included in the first\n\n\nCode\nsolve(999_999)"
  },
  {
    "objectID": "qmd/2023.html#part-1-11",
    "href": "qmd/2023.html#part-1-11",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThe core of this solution is the count function, which takes a tuple of ints representing the three states (off, ambiguous and on), as well as a tuple of block lengths, and returns the number of assignments of the ambiguous values that work.\nIt’s recursive, with the following base cases; the third is checked last:\n\nIf the number of on values is more than the sum of block lengths, no assignments are possible\nIf the sum of the number of on values and ambiguous values is less than the sum of block lengths, no assignments are possible\nIf the sum of block lengths is zero, exactly one assignment is possible\n\nOtherwise, if the first character is off, then the count is the same as the count ignoring that assignment and we can recurse.\nIf the first character is on, we can check whether the first l characters would fit the first block, and the l+1’th character is either the end of the string or compatible with an off state. If it is, the count is the same as the count for the remainder of the string on the remainder of the blocks and we can recurse.\nFinally, if the first character is ambiguous, the count is the sum of the counts for the two possible assignments of the character, and we can recurse.\n\n\nCode\ndef parse(line):\n    s, groups = line.strip().split(\" \")\n    lookup = {\"#\": 2, \"?\": 1, \".\": 0}\n    return tuple(lookup[char] for char in s), tuple(int(g) for g in groups.split(\",\"))\n\n\ndata = [parse(x) for x in load(12)]\n\n\ndef match_beginning(data, length):\n    return all(x &gt; 0 for x in data[:length]) and (\n        (len(data) == length) or data[length] &lt; 2\n    )\n\n\n@functools.cache\ndef count(data, blocks):\n    total = sum(blocks)\n    minimum = sum(x == 2 for x in data)\n    maximum = sum(x &gt; 0 for x in data)\n    if minimum &gt; total or maximum &lt; total:\n        return 0\n    if total == 0:\n        return 1\n    if data[0] == 0:\n        return count(data[1:], blocks)\n    if data[0] == 2:\n        l = blocks[0]\n        if match_beginning(data, l):\n            if l == len(data):\n                return 1\n            return count(data[l + 1 :], blocks[1:])\n        return 0\n    return count(data[1:], blocks) + count((2,) + data[1:], blocks)\n\n\nsum(count(*line) for line in data)"
  },
  {
    "objectID": "qmd/2023.html#part-2-11",
    "href": "qmd/2023.html#part-2-11",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWith the memoization added to part 1, part 2 runs in 8s with no changes needed. Not great, but not terrible\n\n\nCode\nsum(count(((chars + (1,)) * 5)[:-1], blocks * 5) for chars, blocks in data)"
  },
  {
    "objectID": "qmd/2023.html#part-1-12",
    "href": "qmd/2023.html#part-1-12",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis wasn’t too tricky. The idea is that we test all horizontal lines of reflection to see if there are any that match the given condition; if none are found, we rotate the array by 90 degrees clockwise and try again. For part 1, the test is that the two halves should line up exactly after flipping.\nThe only bit that requires some thought is how to account for the points beyond the top/bottom edge. We do that by saying that the number of lines on either side of the mirror line is the shortest distance to the top/bottom edge, so that only relevant lines are compared.\n\n\nCode\ndef find_reflection(array, part=1):\n    if part == 1:\n        test = lambda a, b: (a == b[::-1]).all()\n    else:\n        test = lambda a, b: (a != b[::-1]).sum() == 1\n    for i in range(1, len(array)):\n        l = min(len(array) - i, i)\n        if test(array[i - l : i], array[i : i + l]):\n            return i\n    return None\n\n\narrays = [\n    np.array([[char for char in line.strip()] for line in array.split(\"\\n\")])\n    for array in load(13, \"raw\").split(\"\\n\\n\")\n]\n\nsum(\n    100 * y\n    if (y := find_reflection(array)) is not None\n    else find_reflection(np.rot90(array, -1))\n    for array in arrays\n)"
  },
  {
    "objectID": "qmd/2023.html#part-2-12",
    "href": "qmd/2023.html#part-2-12",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nPart 2 is so similar to part 1 that we can include it as a flag there; instead of a perfect match, the test is that exactly one pair of elements should be different on the two sides of the mirror line. Conceptually, that means that the sum of the differences should be exactly 1.\n\n\nCode\nsum(\n    100 * y\n    if (y := find_reflection(array, part=2)) is not None\n    else find_reflection(np.rot90(array, -1), part=2)\n    for array in arrays\n)"
  },
  {
    "objectID": "qmd/2023.html#part-1-13",
    "href": "qmd/2023.html#part-1-13",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nPart 1 needs a bit of thought. I’ll represent the data as a numpy array, with -1 corresponding to unmoveable rock, 0 to rolling rock, and 1 to empty space. To roll all the rocks northwards, we should focus one column at a time, and between every pair of unmoveable rocks, we sort the intervening data.\nOnce that’s done, we can just score the whole array\n\n\nCode\nmap_ = {\"#\": -1, \"O\": 0, \".\": 1}\narray = np.array([[map_[char] for char in line] for line in load(14)])\nnrows, ncols = array.shape\n\n\ndef score(array):\n    rolls = np.where(array == 0)[0]\n    return (nrows - rolls).sum()\n\n\ndef roll(array):\n    for i in range(ncols):\n        rocks = [-1] + list(np.where(array[:, i] == -1)[0]) + [None]\n        for j in range(len(rocks) - 1):\n            left, right = rocks[j] + 1, rocks[j + 1]\n            array[left:right, i] = np.sort(array[left:right, i])\n    return array\n\n\nscore(roll(array))"
  },
  {
    "objectID": "qmd/2023.html#part-2-13",
    "href": "qmd/2023.html#part-2-13",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe numbers in part 2 are ridiculous enough that we obviously have to hope for some pattern in how the rocks move. We’ll store a fingerprint of the current state, and after each cycle, check if we’re in a state we’ve seen before. If we are, we’ve found a cycle and can skip straight to the end.\n\n\nCode\ndef cycle(array):\n    for i in range(4):\n        array = roll(array)\n        array = np.rot90(array, -1)\n    return array\n\n\ndef hash_(array):\n    return tuple(array.ravel())\n\n\nseen, scores = {}, {}\nmaxval = 1_000_000_000\nfor i in range(maxval):\n    h = hash_(array)\n    if h in seen:\n        break\n    seen[h] = i\n    scores[i] = score(array)\n    array = cycle(array)\ncycle_length = i - seen[h]\nindex = seen[h] + (maxval - seen[h]) % cycle_length\nscores[index]"
  },
  {
    "objectID": "qmd/2023.html#part-1-14",
    "href": "qmd/2023.html#part-1-14",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nPart 1 can be done with a single expression. Always nice when that happens. I originally had both the hash function and the data loading directly in the sum generator expression, but I needed them for part two so I pulled them out to their own lines.\n\n\nCode\ndef hash_(s):\n    return functools.reduce(lambda x, y: (17 * (x + ord(y))) % 256, s, 0)\n\n\ninstructions = load(15, \"raw\").split(\",\")\nsum(hash_(i) for i in instructions)"
  },
  {
    "objectID": "qmd/2023.html#part-2-14",
    "href": "qmd/2023.html#part-2-14",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nPart 2 is fiddly and less fun. We need to run through each of the instructions and apply the procedure described. There might be better ways than this, but the below works:\n\n\nCode\nboxes = [{} for i in range(256)]\nfor instruction in instructions:\n    label, f = instruction.replace(\"-\", \"=\").split(\"=\")\n    destination = hash_(label)\n    if \"=\" in instruction:\n        boxes[destination][label] = int(f)\n    elif label in boxes[destination]:\n        del boxes[destination][label]\n\n\ndef score(box):\n    return (list(box.values()) * np.arange(1, len(box) + 1)).sum()\n\n\nint(sum(np.arange(1, 257) * [score(box) for box in boxes]))"
  },
  {
    "objectID": "qmd/2023.html#part-1-15",
    "href": "qmd/2023.html#part-1-15",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nPart 1 is fairly straightforward. We’ll need a way of tracking states we’ve already seen, and a recipe for moving from one state to the next. A state consists of a (position, direction) pair; if we ever hit a position and direction we’ve seen before we know we’re not going to do anything new (and that there’s an infinite loop in the light circuit).\nWe’ll store the grid as a dictionary of coordinates -&gt; value, with the x and y coordinates encoded as a single complex number. That makes checking for when we’ve left the edge of the grid easy; we just have to check if the current coordinates are in the dictionary.\nThe diagonal mirrors transpose the coordinates of our direction, so that horizontal movement becomes vertical and vice versa. The beam splitters force us into vertical/horizontal movement and make us add an extra beam to the queue we’re going through.\n\n\nCode\ndata = load(16, \"chararray\")\ngrid = {\n    1j * y + x: data[y, x] for x in range(data.shape[1]) for y in range(data.shape[0])\n}\n\n\ndef count_points(position, direction):\n    positions = deque([(position, direction)])\n    seen = set()\n    while positions:\n        position, direction = positions.popleft()\n        while position in grid:\n            if (position, direction) in seen:\n                break\n            seen.add((position, direction))\n            char = grid[position]\n            if char in \"/\\\\\":\n                direction = int(direction.imag) + 1j * int(direction.real)\n                direction *= -1 if char == \"/\" else 1\n            elif char == \"-\" and direction.imag:\n                positions.append((position - 1, -1))\n                direction = 1\n            elif char == \"|\" and direction.real:\n                positions.append((position - 1j, -1j))\n                direction = 1j\n            position += direction\n    return len(set(x[0] for x in seen))\n\n\ncount_points(0, 1)"
  },
  {
    "objectID": "qmd/2023.html#part-2-15",
    "href": "qmd/2023.html#part-2-15",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part two we could probably do some clever memoization by making the above function recurse on beam splitters.\nOne potential disadvantage of that is that the input might contain infinite loops of light which require global information to be discovered. Passing this information to the memoized function would mean that we almost never get a cache hit, while not passing it risks getting stuck in an infinite loop.\nFinally, brute force runs in an acceptable amount of time:\n\n\nCode\ndef starting_position(direction, length):\n    offset = data.shape[0] if (direction.imag + direction.real) &lt; 0 else 0\n    offset *= 1j if direction.imag else 1\n    return offset + (1j if direction.real else 1) * length\n\n\nmax(\n    count_points(starting_position(direction, x), direction)\n    for x in range(data.shape[0])\n    for direction in (-1, 1, -1j, 1j)\n)"
  },
  {
    "objectID": "qmd/2023.html#part-1-16",
    "href": "qmd/2023.html#part-1-16",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nOur first pathfinding task! I couldn’t think of a good & simple-to-calculate heuristic, so we’ll just go with Dijkstra instead of A*.\nWe’re given the restriction that a cart must turn after at most three moves. The cost for a move can just be read out from the input grid, so the only question is how we represent a state and what the neighbors of each state are.\nWith the turning restriction, it makes sense to focus on where the cart turns, rather than where it moves. This means that a state can be represented by a tuple of (y, x, direction), where direction is 0 if the cart is moving vertically after the turn and 1 if it’s moving horizontally. The neighbors of a state are then the places where the cart could have its next turn, i.e. the points up to three tiles away vertically or horizontally, with movement along the other axis after the turn.\nImplementing it looks like this:\n\n\nCode\ndef navigate(grid, minval=1, maxval=3):\n    q = PriorityQueue()\n    max_y, max_x = (v - 1 for v in grid.shape)\n    goal = max_y, max_x\n    q.put((0, (0, 0, 0)))\n    q.put((0, (0, 0, 1)))\n    seen = set()\n\n    while q:\n        cost, (y, x, direction) = q.get()\n        if (y, x) == goal:\n            break\n        if (y, x, direction) in seen:\n            continue\n        seen.add((y, x, direction))\n        original_cost = cost\n        for s in [-1, 1]:\n            cost = original_cost\n            new_y, new_x = y, x\n            for i in range(1, maxval + 1):\n                if direction == 1:\n                    new_x = x + i * s\n                else:\n                    new_y = y + i * s\n                if new_x &lt; 0 or new_y &lt; 0 or new_x &gt; max_x or new_y &gt; max_y:\n                    break\n                cost += grid[new_y, new_x]\n                if ((new_y, new_x, 1 - direction)) in seen:\n                    continue\n                if i &gt;= minval:\n                    q.put((cost, (new_y, new_x, 1 - direction)))\n    return cost\n\n\ngrid = np.array([[int(char) for char in line.strip()] for line in load(17)])\nnavigate(grid)"
  },
  {
    "objectID": "qmd/2023.html#part-2-16",
    "href": "qmd/2023.html#part-2-16",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nPart 2 can be incorporated into the above code by changing the maximum number of allowed moves before a turn, and by only allowing turns after the crucible has moved at least minval steps. That’s easy to incorporate into the function for part 1, so the code just looks like:\n\n\nCode\nnavigate(grid, 4, 10)"
  },
  {
    "objectID": "qmd/2023.html#part-1-17",
    "href": "qmd/2023.html#part-1-17",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\nWe’ll run through the list of instructions and make a list of the coordinates of all the vertices. Then we’ll use the shoelace formula to calculate the area of the described polygon. To account for the line of paint at the edge of the polygon, we’ll add half the perimeter of the polygon (which corresponds to increasing the total thickness of the polygon by 1 everywhere), and finally add one to correct for the missing paint in the exterior corners. There will always be four more exterior corners than interior corners, since going all the way around the polygon once is a 360 degree rotation.\n\n\nCode\nys, xs = [0], [0]\nposition = np.array([0, 0])\ndirections = {\"U\": [0, 1], \"R\": [1, 0], \"D\": [0, -1], \"L\": [-1, 0]}\nfor direction, count, _ in map(str.split, load(18)):\n    position += np.array(directions[direction]) * (int(count))\n    xs.append(position[0])\n    ys.append(position[1])\nint(\n    ((xs * (np.roll(ys, 1) - np.roll(ys, -1))).sum()) / 2\n    + sum(abs(np.diff(ys)) + abs(np.diff(xs))) / 2\n    + 1\n)"
  },
  {
    "objectID": "qmd/2023.html#part-2-17",
    "href": "qmd/2023.html#part-2-17",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nI was not expecting part 2 to go there! Luckily, nothing changes with respect to what we did above apart from how we build the path around the polygon\n\n\nCode\nys, xs = [0], [0]\nposition = np.array([0, 0])\norder = \"RDLU\"\nfor real_instruction in map(lambda x: x.split()[-1][2:-1], load(18)):\n    count, direction = real_instruction[:-1], real_instruction[-1]\n    position += np.array(directions[order[int(direction)]]) * int(count, 16)\n    xs.append(position[0])\n    ys.append(position[1])\nint(\n    ((xs * (np.roll(ys, 1) - np.roll(ys, -1))).sum()) / 2\n    + sum(abs(np.diff(ys)) + abs(np.diff(xs))) / 2\n    + 1\n)"
  },
  {
    "objectID": "qmd/2023.html#part-1-18",
    "href": "qmd/2023.html#part-1-18",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nworkflows, parts = [x.split(\"\\n\") for x in load(19, \"raw\").split(\"\\n\\n\")]\nPart = namedtuple(\"Part\", \"x m a s\")\nparts = [Part(*[int(x) for x in re.findall(r\"\\+?-?\\d+\", part)]) for part in parts]\nname, instructions = workflows[0][:-1].split(\"{\")\ninstruction_map = {}\nfor name, instructions in map(lambda x: x[:-1].split(\"{\"), workflows):\n    rules = [\n        rule.split(\":\") if \":\" in rule else [lambda y: True, rule]\n        for rule in instructions.split(\",\")\n    ]\n    rules = [\n        (eval(\"lambda y: y.\" + rule[0]), rule[1]) if isinstance(rule[0], str) else rule\n        for rule in rules\n    ]\n    instruction_map[name] = instructions, rules\n\n\ndef follow(part, state):\n    s, tests = instruction_map[state]\n    for test, output in tests:\n        if test(part):\n            if output == \"A\":\n                return True\n            if output == \"R\":\n                return False\n            return follow(part, output)\n\n\nsum(x.x + x.m + x.a + x.s for x in parts if follow(x, \"in\"))"
  },
  {
    "objectID": "qmd/2023.html#part-2-18",
    "href": "qmd/2023.html#part-2-18",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\nSo, I thought I was being clever above by eval’ing the instructions to convert them directly to python functions. Unfortunately we have to modify the above approach to work with ranges of values rather than specific values, which has the effect of converting the filters from pass/faill to ones that split ranges in two - the parts that pass the filter, and the parts that don’t. I could go back and rework how I parsed the instructions in part 1 to fit with what I need to do for part 2, or I could just redo the parsing.\nI’ll store each range as a dataclass of tuples, and each filter splits a range into at most two parts. The are half-open on the left, so that x = tuple(0, 5) represents the values [1, 2, 3, 4, 5]. The fact that they’re half-open lets us find the size of a range by just subtracting the endpoints, without having to fiddle with off-by one errors, and I chose to do it on the left so that the inital range can be represented by the pair of numbers (0, 4000) rather than the more ugly (1, 4001).\n\n\nCode\n@dataclasses.dataclass\nclass PartRange:\n    x: tuple[int]\n    m: tuple[int]\n    a: tuple[int]\n    s: tuple[int]\n\n\ndef is_valid(interval):\n    return interval[1] &gt; interval[0]\n\n\ndef split_coords(part_range, coordinate, cutoff, test):\n    coord_range = getattr(part_range, coordinate)\n    if test == \"&gt;\":\n        new_coords = ((cutoff, coord_range[1]), (coord_range[0], cutoff))\n    elif test == \"&lt;\":\n        new_coords = ((coord_range[0], cutoff - 1), (cutoff - 1, coord_range[1]))\n    else:\n        raise ValueError(\"This shouldn't be possible\")\n    result = []\n    for interval in new_coords:\n        if not is_valid(interval):\n            result.append(None)\n        else:\n            result.append(dataclasses.replace(part_range, **{coordinate: interval}))\n    return result\n\n\ndef size(part_range):\n    return np.product([np.diff(getattr(part_range, i)) for i in \"xmas\"])\n\n\ndef parse_rule_string(rule):\n    if \":\" not in rule:\n        return rule\n    coordinate = rule[0]\n    test = rule[1]\n    cutoff, destination = rule[2:].split(\":\")\n    return coordinate, int(cutoff), test, destination\n\n\ninstructions = {}\nfor name, rules in map(lambda x: x[:-1].split(\"{\"), workflows):\n    instructions[name] = [parse_rule_string(rule) for rule in rules.split(\",\")]\n\n\ndef follow(instructions):\n    def inner(part_range, state):\n        if state == \"R\":\n            return 0\n        if state == \"A\":\n            return size(part_range)\n        rules = instructions[state]\n        result = 0\n        remainder = part_range\n        for rule in rules:\n            if remainder is None:\n                break\n            if isinstance(rule, str):\n                result += inner(remainder, rule)\n                break\n            else:\n                coordinate, cutoff, test, destination = rule\n                passed, remainder = split_coords(remainder, coordinate, cutoff, test)\n                result += inner(passed, destination) if passed is not None else 0\n        return result\n\n    initial = PartRange((0, 4000), (0, 4000), (0, 4000), (0, 4000))\n    return inner(initial, \"in\")\n\n\nfollow(instructions)"
  },
  {
    "objectID": "qmd/2023.html#part-2-19",
    "href": "qmd/2023.html#part-2-19",
    "title": "2023 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\n# for module in modules:\n#     modules[module].reset()\nbus = [(\"button\", modules[\"broadcaster\"], 0)]\nwhile bus:\n    source, destination, signal = bus.pop(0)\n    print(\n        source,\n        destination.name,\n        signal,\n        \"conjunction\" if hasattr(destination, \"signals\") else \"flipflop\",\n    )\n    destination.recv(source, signal)\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\n\nG = nx.from_dict_of_lists(\n    {strip_prefix(k): v for k, v in network.items()}, create_using=nx.DiGraph\n)\nnodes, prefices = zip(*([(strip_prefix(k), k[0]) for k in network] + [(\"rx\", \"d\")]))\ncolormap = {\"%\": \"#1f77b4\", \"&\": \"#ff7f0e\", \"b\": \"#2ca02c\", \"d\": \"#d62728\"}\ncolors = [colormap[prefix] for prefix in prefices]\nnx.draw_networkx(\n    G, nodelist=nodes, node_color=colors, arrows=True, pos=nx.bfs_layout(G)\n)\nplt.tight_layout()\nplt.axis(\"off\")\n\n\n\n\nCode\nimport matplotlib\nfor c in plt.cm.tab10.colors: print(matplotlib.colors.to_hex(c))"
  },
  {
    "objectID": "qmd/2023.html#part-1-19",
    "href": "qmd/2023.html#part-1-19",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = np.array([list(line) for line in load(21)])\ndata = np.pad(data, 1, constant_values=\"#\")\ny, x = [x[0] for x in np.where(data == \"S\")]\ndata[y, x] = \".\"\n\n\ndef step(positions):\n    result = set()\n    for y, x in positions:\n        for dy in [-1, 1]:\n            if data[y + dy, x] == \".\":\n                result.add((y + dy, x))\n        for dx in [-1, 1]:\n            if data[y, x + dx] == \".\":\n                result.add((y, x + dx))\n    return result\n\n\npositions = [(y, x)]\nfor _ in range(64):\n    positions = step(positions)\nlen(positions)"
  },
  {
    "objectID": "qmd/2023.html#part-1-20",
    "href": "qmd/2023.html#part-1-20",
    "title": "2023 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(25)\nnetwork = defaultdict(list)\nfor line in data:\n    key, values = line.split(\":\")\n    values = values.split()\n    for value in values:\n        network[key].append(value)\n        network[value].append(key)\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport networkx as nx\nG = nx.from_dict_of_lists(network)\n# nx.draw_networkx(G)"
  },
  {
    "objectID": "qmd/2017.html",
    "href": "qmd/2017.html",
    "title": "2017 Solutions",
    "section": "",
    "text": "Code\nimport collections\nimport functools\nimport itertools\nimport os\nimport re\nimport sys\nfrom collections import defaultdict\nfrom pathlib import Path\n\nimport more_itertools\nimport numpy as np\nimport pandas as pd\n\nsys.path.insert(1, os.path.join(sys.path[0], \"..\"))\nimport utils\n\nload = utils.year_load(2017)"
  },
  {
    "objectID": "qmd/2017.html#part-1",
    "href": "qmd/2017.html#part-1",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = np.array([int(x) for x in load(1)[0]], dtype=int)\ndata[np.where(data == np.roll(data, 1))].sum()"
  },
  {
    "objectID": "qmd/2017.html#part-2",
    "href": "qmd/2017.html#part-2",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndata[np.where(data == np.roll(data, len(data) // 2))].sum()"
  },
  {
    "objectID": "qmd/2017.html#part-1-1",
    "href": "qmd/2017.html#part-1-1",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = [sorted(map(lambda x: int(x), x.split())) for x in load(2)]\nsum(a[-1] - a[0] for a in data)"
  },
  {
    "objectID": "qmd/2017.html#part-2-1",
    "href": "qmd/2017.html#part-2-1",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ntotal = 0\nfor line in data:\n    for idx, value in enumerate(line):\n        for j in range(idx + 1, len(line)):\n            total += line[j] // value if line[j] % value == 0 else 0\ntotal"
  },
  {
    "objectID": "qmd/2017.html#part-1-2",
    "href": "qmd/2017.html#part-1-2",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\npuzzle_input = 368078\ncompleted_squares = (int(np.sqrt(puzzle_input) - 1) // 2 * 2) + 1\nremainder = (puzzle_input - completed_squares**2) % (completed_squares + 1)\n(completed_squares // 2 + 1) + abs((completed_squares // 2) + 1 - remainder)"
  },
  {
    "objectID": "qmd/2017.html#part-2-2",
    "href": "qmd/2017.html#part-2-2",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ncoord, current_side, side_length, remainder = 0, 0, 0, 0\nspiral = defaultdict(int)\nspiral[coord] = 1\ndirection = 1\nwhile True:\n    if remainder == side_length:\n        if current_side % 4 == 0:\n            coord = coord + direction - 1j * direction\n            side_length += 2\n        direction = 1j * direction\n        coord = coord + direction\n        current_side += 1\n        remainder = 1\n    else:\n        coord = coord + direction\n        remainder += 1\n    tmp = 0\n    for x, y in itertools.product([-1, 0, 1], [-1j, 0, 1j]):\n        if not x and not y:\n            continue\n        target = coord + x + y\n        tmp += spiral[target]\n    if tmp &gt; puzzle_input:\n        break\n    spiral[coord] = tmp\ntmp"
  },
  {
    "objectID": "qmd/2017.html#part-1-3",
    "href": "qmd/2017.html#part-1-3",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nlines = [x.split() for x in load(4)]\nsum(len(l) == len(set(l)) for l in lines)"
  },
  {
    "objectID": "qmd/2017.html#part-2-3",
    "href": "qmd/2017.html#part-2-3",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsum(len(l) == len(set([\"\".join(sorted(w)) for w in l])) for l in lines)"
  },
  {
    "objectID": "qmd/2017.html#part-1-4",
    "href": "qmd/2017.html#part-1-4",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ninstructions = load(5, \"np\")\nip, count = 0, 0\nwhile ip &gt;= 0 and ip &lt; len(instructions):\n    instructions[ip] += 1\n    ip += instructions[ip] - 1\n    count += 1\ncount"
  },
  {
    "objectID": "qmd/2017.html#part-2-4",
    "href": "qmd/2017.html#part-2-4",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ninstructions = load(5, \"np\")\nip, count = 0, 0\nwhile ip &gt;= 0 and ip &lt; len(instructions):\n    instruction = instructions[ip]\n    instructions[ip] += 1 if instruction &lt; 3 else -1\n    ip += instruction\n    count += 1\ncount"
  },
  {
    "objectID": "qmd/2017.html#part-1-5",
    "href": "qmd/2017.html#part-1-5",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = np.array([0, 5, 10, 0, 11, 14, 13, 4, 11, 8, 8, 7, 1, 4, 12, 11])\nl = len(data)\nseen = {}\ni = 0\n\n\ndef step(data):\n    idx, maxval = data.argmax(), data.max()\n    data[idx] = 0\n    delta = np.ones(len(data), dtype=int) * (maxval // l)\n    delta[: maxval % l] += 1\n    data += np.roll(delta, idx + 1)\n    return data\n\n\nwhile tuple(data) not in seen:\n    seen[tuple(data)] = i\n    data = step(data)\n    i += 1\ni\n\n\nI was getting the wrong answer for this for the longest time until I realised I’d left off a “0” at the start of my input when I copied it over."
  },
  {
    "objectID": "qmd/2017.html#part-2-5",
    "href": "qmd/2017.html#part-2-5",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThis was made trivial by tracking when a given configuration was seen.\n\n\nCode\ni - seen[(tuple(data))]"
  },
  {
    "objectID": "qmd/2017.html#part-1-6",
    "href": "qmd/2017.html#part-1-6",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ntree = {}\nfor line in load(7):\n    name = line.split(\" \")[0]\n    children = line.split(\" -&gt; \")[1].split(\", \") if \" -&gt; \" in line else []\n    weight = int(re.findall(\"\\d+\", line)[0])\n    tree[name] = {\"weight\": weight, \"children\": children}\nparents = {}\nfor node in tree:\n    for child in tree[node][\"children\"]:\n        parents[child] = node\nnode = (set(tree.keys()) - set(parents.keys())).pop()\nnode"
  },
  {
    "objectID": "qmd/2017.html#part-2-6",
    "href": "qmd/2017.html#part-2-6",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef weight(node):\n    return tree[node][\"weight\"] + sum(map(weight, tree[node][\"children\"]))\n\n\ndef is_balanced(node):\n    return (\n        not tree[node][\"children\"] or len(set(map(weight, tree[node][\"children\"]))) == 1\n    )\n\n\nwhile not is_balanced(node):\n    weights = [weight(x) for x in tree[node][\"children\"]]\n    counts = collections.Counter(weights)\n    wrong_weight = min(counts, key=counts.get)\n    node = tree[node][\"children\"][weights.index(wrong_weight)]\n\ndelta = max(counts, key=counts.get) - wrong_weight\ntree[node][\"weight\"] + delta"
  },
  {
    "objectID": "qmd/2017.html#part-1-7",
    "href": "qmd/2017.html#part-1-7",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nimport operator as op\n\nregisters = defaultdict(int)\ninstructions = [x.split() for x in load(8)]\nops = {\"&lt;\": op.lt, \"&lt;=\": op.le, \"==\": op.eq, \"&gt;=\": op.ge, \"&gt;\": op.gt, \"!=\": op.ne}\nsigns = {\"dec\": -1, \"inc\": 1}\nfor target, sign, inc_amount, _, comparator, comparison, cmp_value in instructions:\n    if ops[comparison](registers[comparator], int(cmp_value)):\n        registers[target] += signs[sign] * int(inc_amount)\nmax(registers.values())"
  },
  {
    "objectID": "qmd/2017.html#part-2-7",
    "href": "qmd/2017.html#part-2-7",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nmaxval = 0\nregisters = defaultdict(int)\nfor target, sign, inc_amount, _, comparator, comparison, cmp_value in instructions:\n    if ops[comparison](registers[comparator], int(cmp_value)):\n        registers[target] += signs[sign] * int(inc_amount)\n    current_max = max(registers.values())\n    if current_max &gt; maxval:\n        maxval = current_max\nmaxval"
  },
  {
    "objectID": "qmd/2017.html#part-1-8",
    "href": "qmd/2017.html#part-1-8",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndef canonical_form(sequence):\n    count = 0\n    replacements = {\"{\": \"[\", \",\": \",\", \"}\": \"]\"}\n    mode = \"group\"\n    skip = False\n    result = \"\"\n    for char in sequence:\n        if skip:\n            skip = False\n        elif char == \"!\":\n            skip = True\n        elif mode == \"group\" and char == \"&lt;\":\n            mode = \"garbage\"\n        elif mode == \"garbage\" and char == \"&gt;\":\n            mode = \"group\"\n        elif mode == \"garbage\":\n            count += 1\n        elif mode == \"group\":\n            if char == \"}\":\n                result += replacements[char]\n            if char == \"{\":\n                result += replacements[char]\n    return result, count\n\n\ndata = load(9)[0]\ndata, count = canonical_form(data)\ntotal, counter = 0, 0\nfor char in data:\n    if char == \"[\":\n        counter += 1\n    else:\n        total += counter\n        counter -= 1\ntotal"
  },
  {
    "objectID": "qmd/2017.html#part-2-8",
    "href": "qmd/2017.html#part-2-8",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ncount"
  },
  {
    "objectID": "qmd/2017.html#part-1-9",
    "href": "qmd/2017.html#part-1-9",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = \"165,1,255,31,87,52,24,113,0,91,148,254,158,2,73,153\"\nlengths = [int(length) for length in data.split(\",\")]\n\n\ndef knot_hash1(lengths):\n    knots = collections.deque(range(256))\n    total = 0\n    for idx, length in enumerate(lengths):\n        new = collections.deque([knots.popleft() for _ in range(length)])\n        new.reverse()\n        knots = knots + new\n        knots.rotate(-idx)\n        total += length + idx\n    knots.rotate(total)\n    return knots\n\n\nknots = knot_hash1(lengths)\nknots.popleft() * knots.popleft()"
  },
  {
    "objectID": "qmd/2017.html#part-2-9",
    "href": "qmd/2017.html#part-2-9",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef knot_hash64(s):\n    numbers = [ord(x) for x in s] + [17, 31, 73, 47, 23]\n    lengths = itertools.chain.from_iterable(itertools.repeat(numbers, 64))\n    knots = list(knot_hash1(lengths))\n    digits = [\n        functools.reduce(lambda x, y: x ^ y, knots[16 * i : 16 * (i + 1)])\n        for i in range(16)\n    ]\n    return \"\".join([\"{:0&gt;2x}\".format(x) for x in digits])\n\n\nknot_hash64(data)"
  },
  {
    "objectID": "qmd/2017.html#part-1-10",
    "href": "qmd/2017.html#part-1-10",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\nTo describe the hexgrid we’ll use two basis vectors: x1, directed southeast, and x2, directed due north. All the other directions can be found as linear combinations of these, and the final position in this basis is just the sum of all the moves. Now, any move of the form (k, 1), with k in [-1, 0, 1] only takes one step, so the number of steps needed to reach the final position is just the value of whichever of the two basis vectors we have more of\n\n\nCode\ndata = open(load(11)[0].split(\",\")\ncoordinates = {\"se\": np.array((1, 0)),\n               \"s\": np.array((0, -1)),\n               \"sw\": np.array((-1, -1)),\n               \"nw\": np.array((-1, 0)),\n               \"n\": np.array((0, 1)),\n               \"ne\": np.array((1, 1))}\nmoves = np.array([coordinates[x] for x in data])\nmax(abs(moves.sum(axis=0)))"
  },
  {
    "objectID": "qmd/2017.html#part-2-10",
    "href": "qmd/2017.html#part-2-10",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, instead of finding just the sum of the moves, we look at the running total, and ask what the greatest value of any of the coefficients is at any point in the path.\n\n\nCode\nabs(moves.cumsum(axis=0)).max()"
  },
  {
    "objectID": "qmd/2017.html#part-1-11",
    "href": "qmd/2017.html#part-1-11",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nregex = \"(-?\\d+)\"\ndata = load(12, \"int\")\ngraph = {line[0]: line[1:] for line in data}\n\nneighbors = lambda state: graph[state]\nlen(utils.bfs(0, None, neighbors, return_visited=True))"
  },
  {
    "objectID": "qmd/2017.html#part-2-11",
    "href": "qmd/2017.html#part-2-11",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ni = 0\nwhile graph:\n    seed = list(graph.keys())[0]\n    visited = utils.bfs(seed, None, neighbors, return_visited=True)\n    for key in visited:\n        del graph[key]\n    i += 1\ni"
  },
  {
    "objectID": "qmd/2017.html#part-1-12",
    "href": "qmd/2017.html#part-1-12",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThe only slightly tricky thing here is that we have to convert a depth to a cycle length. In each cycle, a scanner of depth d moves down (d - 1) steps, and then back up (d - 1) steps, so the cycle length is 2 * d - 2.\n\n\nCode\ndata = load(13, \"int\")\nsum(map(lambda x: 0 if (x[0] % (x[1] * 2 - 2)) else x[0] * x[1], data))"
  },
  {
    "objectID": "qmd/2017.html#part-2-12",
    "href": "qmd/2017.html#part-2-12",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\nSo, this is another application of the chinese remainder theorem, after a bit of massaging. We have multiple scanners with the same depth at different positions; each such scanner invalidates a congruence class of the integers mod cycle length.\nIn my input, the depths were almost coprime in the sense that there was one of the scanner depths that divided all the others, and apart from that, the depths were either coprime, or divided one another exactly.\nThe depths that divide one another exactly can be handled by unfolding the restriction of the smaller number to its higher multiples, and then removing the smaller number from consideration. After that, we can find what numbers would be valid for each depth.\nFor most of these, there was only one such modulus. Taking all the ones for which that’s the case we can use the chinese remainder theorem to solve that system of congruences, and then manually move to higher congruences to satisfy the remaining scanners.\n\n\nCode\nimport math\n\nfrom utils import crt\n\nscanners = defaultdict(list)\nfor position, depth in data:\n    scanners[2 * depth - 2].append((-position) % (2 * depth - 2))\n    scanners[2 * depth - 2].sort()\nseen = []\nfor s1, s2 in itertools.combinations(scanners.keys(), 2):\n    s2, s1 = sorted([s1, s2])\n    if (s1 % s2) == 0:\n        seen.append(s2)\n        offsets = list(range(0, s1, s2))\n        new_restrictions = list(\n            map(sum, list(itertools.product(offsets, scanners[s2])))\n        )\n        restrictions = sorted(set(new_restrictions + scanners[s1]))\n        scanners[s1] = restrictions\nfor key in set(seen):\n    del scanners[key]\nvalid = {}\nfor scanner in scanners:\n    valid[scanner] = sorted(set(range(scanner)) - set(scanners[scanner]))\ng = math.gcd(\n    *(\n        list(valid.keys())\n        + [element for numbers in valid.values() for element in numbers]\n    )\n)\ncongruences = []\nremainder = {}\nfor modulus in valid:\n    if len(valid[modulus]) == 1:\n        congruences.append((int(modulus / g), int(valid[modulus][0] / g)))\n    else:\n        remainder[int(modulus / g)] = [int(x / g) for x in valid[modulus]]\nN = np.product([x[0] for x in congruences])\nx = crt(congruences) - N\nwhile True:\n    x += N\n    for v in remainder:\n        if (x % v) not in remainder[v]:\n            break\n    else:\n        break\ng * x"
  },
  {
    "objectID": "qmd/2017.html#part-1-13",
    "href": "qmd/2017.html#part-1-13",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nprefix = load(14)[0] + \"-\"\nhashes = [knot_hash64(prefix + str(i)) for i in range(128)]\nbitstrings = [f\"{int(h, 16):0128b}\" for h in hashes]\nsum(x.count(\"1\") for x in bitstrings)"
  },
  {
    "objectID": "qmd/2017.html#part-2-13",
    "href": "qmd/2017.html#part-2-13",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nfield = np.array([[ord(x) - ord(\"0\") for x in b] for b in bitstrings])\ngraph = defaultdict(list)\nfor i, j in itertools.product(range(128), range(128)):\n    neighbors = [(i, j + 1), (i + 1, j)]\n    neighbors = [(x, y) for x, y in neighbors if (x &lt; 128 and y &lt; 128)]\n    if not field[i, j]:\n        continue\n    for neighbor in neighbors:\n        if field[neighbor]:\n            graph[(i, j)].append(neighbor)\n            graph[neighbor].append((i, j))\ncount = field.sum() - len(graph)  # singletons\nneighbors = lambda x: graph[x]\nwhile graph:\n    seed = list(graph.keys())[0]\n    visited = utils.bfs(seed, None, neighbors, return_visited=True)\n    for node in visited:\n        del graph[node]\n    count += 1\ncount"
  },
  {
    "objectID": "qmd/2017.html#part-1-14",
    "href": "qmd/2017.html#part-1-14",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nA = 16807\nB = 48271\n\na = 116\nb = 299\ntotal = 0\nfor i in range(40_000_000):\n    a = (a * A) % 2147483647\n    b = (b * B) % 2147483647\n    total += (a % 2**16) == (b % 2**16)\ntotal"
  },
  {
    "objectID": "qmd/2017.html#part-2-14",
    "href": "qmd/2017.html#part-2-14",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\na = 116\nb = 299\ntotal = 0\n\n\ndef gen_a(start):\n    current = start\n    while True:\n        current = (current * A) % 2147483647\n        if current % 4 == 0:\n            yield current\n\n\ndef gen_b(start):\n    current = start\n    while True:\n        current = (current * B) % 2147483647\n        if current % 8 == 0:\n            yield current\n\n\na = gen_a(a)\nb = gen_b(b)\nfor i in range(5_000_000):\n    total += (next(a) % 2**16) == (next(b) % 2**16)\ntotal"
  },
  {
    "objectID": "qmd/2017.html#part-1-15",
    "href": "qmd/2017.html#part-1-15",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nmoves = load(16)[0].split(\",\")\npermutations = list(\"abcdefghijklmnop\")\n\n\ndef dance(permutations, n):\n    seen = []\n    for i in range(n):\n        s = \"\".join(permutations)\n        if s in seen:\n            return seen[n % i]\n        seen.append(s)\n\n        for move in moves:\n            if move[0] == \"s\":\n                i = int(move[1:])\n                permutations = permutations[-i:] + permutations[:-i]\n            else:\n                if move[0] == \"x\":\n                    a, b = map(int, move[1:].split(\"/\"))\n                    permutations[a], permutations[b] = permutations[b], permutations[a]\n                if move[0] == \"p\":\n                    a, b = move[1:].split(\"/\")\n                    A = permutations.index(a)\n                    B = permutations.index(b)\n                    permutations[A], permutations[B] = permutations[B], permutations[A]\n\n    return permutations\n\n\n\"\".join(dance(permutations[:], 1))"
  },
  {
    "objectID": "qmd/2017.html#part-2-15",
    "href": "qmd/2017.html#part-2-15",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, it would take too long to go through all the one billion cycles. But what if the dances hit a cycle at some point? That would make things a lot easier!\n\n\nCode\ndance(permutations[:], 1_000_000_000)"
  },
  {
    "objectID": "qmd/2017.html#part-1-16",
    "href": "qmd/2017.html#part-1-16",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nsteps = 386\nq = collections.deque([0])\nfor i in range(1, 2018):\n    q.rotate(-steps - 1)\n    q.appendleft(i)\nq[1]"
  },
  {
    "objectID": "qmd/2017.html#part-2-16",
    "href": "qmd/2017.html#part-2-16",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n50 million is at a level where the previous approach is becoming ineffective. The code below takes ~40 seconds to run. It could probably be improved, but that would take longer than 40 seconds.\n\n\nCode\nq = collections.deque([0])\nfor i in range(1, 50_000_000):\n    q.rotate(-steps - 1)\n    q.appendleft(i)\nq[q.index(0) + 1]"
  },
  {
    "objectID": "qmd/2017.html#part-1-17",
    "href": "qmd/2017.html#part-1-17",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nprogram = [x.split() for x in load(18)]\nip = 0\nregisters = defaultdict(int)\nbinops = {\n    \"set\": lambda x, y: y,\n    \"add\": lambda x, y: x + y,\n    \"mul\": lambda x, y: x * y,\n    \"mod\": lambda x, y: x % y,\n}\nmemory = 0\nwhile 0 &lt;= ip &lt; len(program):\n    instruction = program[ip]\n    instruction, register, argument = instruction[0], instruction[1], instruction[-1]\n    try:\n        argument = int(argument)\n    except ValueError:\n        argument = registers[argument]\n    if instruction in binops:\n        op = binops[instruction]\n        registers[register] = op(registers[register], argument)\n    elif instruction == \"jgz\":\n        if registers[register] &gt; 0:\n            ip += argument - 1\n    elif instruction == \"rcv\":\n        if registers[register] != 0:\n            print(memory)\n            break\n    elif instruction == \"snd\":\n        memory = argument\n    ip += 1"
  },
  {
    "objectID": "qmd/2017.html#part-2-17",
    "href": "qmd/2017.html#part-2-17",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThere’s a bunch of state to keep track of - let’s make a class to hold it.\n\n\nCode\nclass Program:\n    def __init__(self, program, program_id, inputs):\n        self.program = program.copy()\n        self.ram = defaultdict(int)\n        self.ram[\"p\"] = program_id\n        self.state = 1  # ready\n        self.count = 0\n        self.ip = 0\n        self.inputs = inputs\n\n    def __next__(self):\n        while 0 &lt;= self.ip &lt; len(self.program):\n            instruction = self.program[self.ip]\n            instruction, register, argument = (\n                instruction[0],\n                instruction[1],\n                instruction[-1],\n            )\n            try:\n                argument = int(argument)\n            except ValueError:\n                argument = self.ram[argument]\n            if instruction in binops:\n                op = binops[instruction]\n                self.ram[register] = op(self.ram[register], argument)\n            elif instruction == \"jgz\":\n                try:\n                    comparison = int(register)\n                except ValueError:\n                    comparison = self.ram[register]\n                if comparison &gt; 0:\n                    self.ip += argument - 1\n            elif instruction == \"rcv\":\n                if not self.inputs:\n                    self.state = 0  # Waiting\n                    return None\n                x = self.inputs.pop(0)\n                self.ram[register] = x\n            elif instruction == \"snd\":\n                self.count += 1\n                self.ip += 1\n                return argument\n            self.ip += 1\n        self.state = 2  # terminated\n        return None\n\n\nWith that out of the way we can implement the collaboration as follows: run program 0 until it’s asking for a non-existent value (or finishes), then do the same for program 1. Keep going until both programs are waiting for the other or p1 has finished.\n\n\nCode\nbus_one = []\nbus_two = []\np0 = Program(program, 0, bus_two)\np1 = Program(program, 1, bus_one)\nwhile p0.state == 1 and p1.state != 2:\n    while p0.state == 1:\n        n = next(p0)\n        if n is not None:\n            bus_one.append(n)\n    if bus_one and p1.state == 0:\n        p1.state = 1\n    while p1.state == 1:\n        n = next(p1)\n        if n is not None:\n            bus_two.append(n)\n    if bus_two and p0.state == 0:\n        p0.state = 1\np1.count"
  },
  {
    "objectID": "qmd/2017.html#part-1-18",
    "href": "qmd/2017.html#part-1-18",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThe hardest part for this was determining a sensible stopping condition – that is one that could tell the difference between wires randomly crossing, and actually being finished. Direct inspection of the input showed where there was a dead end, so that’s just hard-coded into the below:\n\n\nCode\ndata = load(19)\nx, y = len(data[0]), len(data)\ndirection = 1j\ndeltas = [(1j, \"|\"), (-1j, \"|\"), (1, \"-\"), (-1, \"-\")]\nposition = data[0].index(\"|\")\nresult, character = \"\", \"\"\ni = 1\nwhile character != \"L\":\n    position = position + direction\n    character = data[int(position.imag)][int(position.real)]\n    if character == \"+\":\n        for delta, char in deltas:\n            if delta == -direction:\n                continue\n            lookahead = position + delta\n            try:\n                next_char = data[int(lookahead.imag)][int(lookahead.real)]\n            except IndexError:\n                continue\n            if next_char == char:\n                direction = delta\n                break\n    elif character in string.ascii_letters:\n        result += character\n    i += 1\nresult"
  },
  {
    "objectID": "qmd/2017.html#part-2-18",
    "href": "qmd/2017.html#part-2-18",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\nI don’t know if this was intentional, but with the solution to part 1 above, counting the number of steps is trivial. Just add a loop variable to keep track of how many times we move\n\n\nCode\ni"
  },
  {
    "objectID": "qmd/2017.html#part-1-19",
    "href": "qmd/2017.html#part-1-19",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\nIt’s always nice to be able to come up with a one-liner to solve these.\n\n\nCode\ndata = np.array(load(20, \"int\"), dtype=int)\nabs(data[:, -3:]).sum(axis=1).argmin()"
  },
  {
    "objectID": "qmd/2017.html#part-2-19",
    "href": "qmd/2017.html#part-2-19",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part two we could do some clever work to figure out a stopping condition based on pairs of particles being reachable in each of three dimensions, with reachable defined by being potentially able to catch up. Or we can just pick an arbitrary upper bound and hope it’s good enough.\n\n\nCode\ns, v, dv = data[:, :3], data[:, 3:6], data[:, -3:]\nfor _ in range(1000):\n    v += dv\n    s += v\n    values, index, count = np.unique(s, return_counts=True, return_index=True, axis=0)\n    indices = index[np.where(count == 1)]\n    s, v, dv = s[indices], v[indices], dv[indices]\n\nlen(s)"
  },
  {
    "objectID": "qmd/2017.html#part-1-20",
    "href": "qmd/2017.html#part-1-20",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis feels like the triumph of brute force over elegance. The process involves exponential growth, where the array triples in size every three iterations, so brute forcing seems like an unlikely choice, but the numbers are small enough that it just about works.\n\n\nCode\ntranslation = str.maketrans(\".#/\", \"01\\n\")\ndata = [x.translate(translation).split(\" =&gt; \") for x in load(21)]\n\n\ndef hashed(array):\n    return tuple(array.ravel())\n\n\nreplacements = {}\nfor row in data:\n    src, dest = map(\n        lambda array: np.array(\n            [[int(x) for x in line] for line in array.split(\"\\n\")], dtype=bool\n        ),\n        row,\n    )\n    flipped = src[::-1]\n    for i in range(4):\n        replacements[hashed(flipped)] = dest\n        replacements[hashed(src)] = dest\n        src, flipped = np.rot90(src), np.rot90(flipped)\n\narray = np.reshape([int(x) for x in \".#...####\".translate(translation)], (-1, 3))\n\n\ndef solve(array, n):\n    for i in range(n):\n        s = array.shape[0]\n        step = 2 if s % 2 == 0 else 3\n        new_step = 3 if step == 2 else 4\n        new_size = (s // step) * new_step\n        new_array = np.zeros((new_size, new_size), dtype=bool)\n        for i in range(0, s, step):\n            for j in range(0, s, step):\n                square = array[i : i + step, j : j + step]\n                new_square = replacements[hashed(square)]\n                new_array[\n                    (i // step) * new_step : (i // step) * new_step + new_step,\n                    (j // step) * new_step : (j // step) * new_step + new_step,\n                ] = new_square\n        array = new_array\n    return (1 * array).sum()\n\n\nsolve(array, 5)"
  },
  {
    "objectID": "qmd/2017.html#part-2-20",
    "href": "qmd/2017.html#part-2-20",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsolve(array, 18)"
  },
  {
    "objectID": "qmd/2017.html#part-1-21",
    "href": "qmd/2017.html#part-1-21",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndirection = 1j\ndata = [[0 if char == \".\" else 1 for char in line] for line in load(22)]\nsize = len(data)\nposition = size // 2 + (size // 2) * 1j\nboard = defaultdict(int)\nfor y, line in enumerate(data):\n    for x, val in enumerate(line):\n        board[x + (size - y - 1) * 1j] = val\ntotal = 0\nfor idx in range(10000):\n    state = board[position]\n    total += state == 0\n    direction *= (1 - 2 * state) * 1j\n    board[position] = 1 - state\n    position += direction\ntotal"
  },
  {
    "objectID": "qmd/2017.html#part-2-21",
    "href": "qmd/2017.html#part-2-21",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe large number of iterations for part 2 seems to indicate that I should do something more clever here. But the following runs in about 20s on my machine, so nevermind.\n\n\nCode\ndirection = 1j\ndata = [[1j if char == \".\" else -1j for char in line] for line in load(22)]\nsize = len(data)\nposition = size // 2 + (size // 2) * 1j\nboard = defaultdict(lambda: 1j)\nfor y, line in enumerate(data):\n    for x, val in enumerate(line):\n        board[x + (size - y - 1) * 1j] = val\ntotal = 0\nfor idx in range(10000000):\n    state = board[position]\n    total += state == 1\n    direction *= state\n    board[position] = -state * 1j\n    position += direction\ntotal"
  },
  {
    "objectID": "qmd/2017.html#part-1-22",
    "href": "qmd/2017.html#part-1-22",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nprogram = [x.split() for x in load(23)]\nip = 0\nregisters = {x: 0 for x in \"abcdefgh\"}\nbinops = {\"set\": lambda x, y: y, \"mul\": lambda x, y: x * y, \"sub\": lambda x, y: x - y}\ncount = 0\nwhile 0 &lt;= ip &lt; len(program):\n    instruction = program[ip]\n    instruction, register, argument = instruction[0], instruction[1], instruction[-1]\n    argument = registers[argument] if argument in registers else int(argument)\n    if instruction in binops:\n        if instruction == \"mul\":\n            count += 1\n        op = binops[instruction]\n        registers[register] = op(registers[register], argument)\n    elif instruction == \"jnz\":\n        operand = registers[register] if register in registers else int(register)\n        if operand != 0:\n            ip += argument - 1\n    ip += 1\ncount"
  },
  {
    "objectID": "qmd/2017.html#part-2-22",
    "href": "qmd/2017.html#part-2-22",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe instructions warn you that trying to run part 2 as-is is a futile endeavour. And indeed, that is the case. Looking at the script there’s a very clear setup section to start with, where variables are set to values; these lines can never be reached again. After that there’s a huge loop which covers the rest of the program, and which basically says\n\n\nCode\nwhile b != 0:\n    ...\n    b += 17\n\n\nInside this huge loop, we find a section at the start with two nested loops, followed by a tiny bit of cleanup. The two nested loops only involve the d and e variables, and they have the effect of setting f to zero if ever d * e = b, and doing basically nothing else. In the cleanup after the loop, 1 is added to h if f is zero. So that means that whenever b is composite, h increases by 1. So the script is equivalent to:\n\n\nCode\ndef is_composite(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False\n\n\nb0 = 5700 + 100_000\nlen(list(filter(is_composite, range(b0, b0 + 17000 + 1, 17))))"
  },
  {
    "objectID": "qmd/2017.html#part-1-23",
    "href": "qmd/2017.html#part-1-23",
    "title": "2017 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nports = load(24, \"int\")\nports = set(map(tuple, ports))\n\n\ndef strongest_bridge(current, components, part=1):\n    strength = current if part == 1 else current[1]\n    bridges = []\n    for candidate in [x for x in components if strength in x]:\n        value = candidate[0] if candidate[1] == strength else candidate[1]\n        new_components = components - set([candidate])\n        new_state = value if part == 1 else (current[0] + 1, value)\n        bridges.append(strongest_bridge(new_state, new_components, part=part))\n    if bridges:\n        best_bridge = max(bridges)\n        return (\n            2 * current + best_bridge\n            if part == 1\n            else (best_bridge[0], 2 * strength + best_bridge[1])\n        )\n    else:\n        return current\n\n\nstrongest_bridge(0, ports)"
  },
  {
    "objectID": "qmd/2017.html#part-2-23",
    "href": "qmd/2017.html#part-2-23",
    "title": "2017 Solutions",
    "section": "Part 2",
    "text": "Part 2\nEnumerating all the bridges for part 2 is basically the same as in part 1, so I’ve incuded the code there with a flag. The only difference is how the bridges are scored - here length takes priority. We can still use the max function because tuples sort lexicographically. The solution then becomes\n\n\nCode\nstrongest_bridge((0, 0), ports, part=2)[1]"
  },
  {
    "objectID": "qmd/2019.html",
    "href": "qmd/2019.html",
    "title": "2019 Solutions",
    "section": "",
    "text": "Code\nimport collections\nimport functools\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nfrom collections import defaultdict, deque\nfrom pathlib import Path\nfrom queue import PriorityQueue\n\nimport more_itertools\nimport numpy as np\nimport pandas as pd\nimport scipy\n\nsys.path.insert(1, os.path.join(sys.path[0], \"..\"))\n\nimport utils\nfrom intcode import IntCodeProgram\n\nload = utils.year_load(2019)"
  },
  {
    "objectID": "qmd/2019.html#part-1",
    "href": "qmd/2019.html#part-1",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(1, \"np\")\n(data // 3 - 2).sum()"
  },
  {
    "objectID": "qmd/2019.html#part-2",
    "href": "qmd/2019.html#part-2",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ntotal = 0\ndata = list(data)\nfor val in data:\n    fuel = max(val // 3 - 2, 0)\n    total += fuel\n    if fuel:\n        data.append(fuel)\ntotal"
  },
  {
    "objectID": "qmd/2019.html#part-1-1",
    "href": "qmd/2019.html#part-1-1",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nprogram = IntCodeProgram([int(x) for x in load(2)[0].split(\",\")])\n\n\ndef solve(program, noun=12, verb=2):\n    program.reset()\n    program.program[1] = noun\n    program.program[2] = verb\n    try:\n        val = next(program.run())\n    except StopIteration:\n        return program.program[0]\n\n\nsolve(program)\n\n\n\n\nCode\nfor noun, verb in itertools.product(range(100), range(100)):\n    result = solve(program, noun, verb)\n    if result == 19690720:\n        result = 100 * noun + verb\n        break\nresult"
  },
  {
    "objectID": "qmd/2019.html#part-1-2",
    "href": "qmd/2019.html#part-1-2",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nlines = [x.split(\",\") for x in load(3)]\n\n\ndef path_to_segments(path):\n    directions = {\"U\": 1j, \"D\": -1j, \"R\": 1, \"L\": -1}\n    deltas = [int(p[1:]) * directions[p[0]] for p in path]\n    ends = np.cumsum(deltas)\n    lengths = np.cumsum(np.abs(deltas))\n    result = np.vstack([np.roll(ends, 1), ends, np.roll(lengths, 1)]).T\n    result[0, 0] = 0\n    result[0, 2] = 0\n    return result\n\n\ndef intersection(s1, s2):\n    if ((s1[1] - s1[0]) * (s2[1] - s2[0])).imag == 0:\n        return False\n    if (s1[0] - s1[1]).imag == 0:\n        s2, s1 = s1, s2\n    if (s1[0].real - s2[0].real) * (s1[1].real - s2[1].real) &lt; 0 and (\n        s1[0].imag - s2[0].imag\n    ) * (s1[1].imag - s2[1].imag) &lt; 0:\n        intersection_point = s1[0].real + 1j * s2[0].imag\n        total_length = (\n            s1[2]\n            + s2[2]\n            + abs((s1[0] - intersection_point).imag)\n            + abs((s2[0] - intersection_point).real)\n        )\n        return intersection_point, total_length\n    return False\n\n\nl1 = path_to_segments(lines[0])\nl2 = path_to_segments(lines[1])\nintersections = [\n    i for s1, s2 in itertools.product(l1, l2) if (i := intersection(s1, s2))\n]\nint(min(abs(x[0].real) + abs(x[0].imag) for x in intersections))"
  },
  {
    "objectID": "qmd/2019.html#part-2-1",
    "href": "qmd/2019.html#part-2-1",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nmin(x[1] for x in intersections)"
  },
  {
    "objectID": "qmd/2019.html#bonus",
    "href": "qmd/2019.html#bonus",
    "title": "2019 Solutions",
    "section": "Bonus",
    "text": "Bonus\nAs a bonus, we can visualize the walk through space\n\n\nCode\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set_theme()\n\n\ndef plot_path(segments, **kwargs):\n    x = segments[:, 0].real\n    y = segments[:, 0].imag\n    plt.plot(x, y, **kwargs)\n\n\nplot_path(l1)\nplot_path(l2)\nax = plt.gca()\n# plt.savefig(\"../graphs/2019-3.png\", bbox_inches=\"tight\")\n\n\n\n\n\nHow the two wires are arranged in space"
  },
  {
    "objectID": "qmd/2019.html#part-1-3",
    "href": "qmd/2019.html#part-1-3",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nlow = 231832\nhigh = 767346\ntotal = 0\nfor i in range(low, high + 1):\n    s = str(i)\n    if list(s) == sorted(s):\n        for digit in \"0123456789\":\n            if s.count(digit) &gt; 1:\n                total += 1\n                break\ntotal"
  },
  {
    "objectID": "qmd/2019.html#part-2-2",
    "href": "qmd/2019.html#part-2-2",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ntotal = 0\nfor i in range(low, high + 1):\n    s = str(i)\n    if list(s) == sorted(s):\n        if (s[0] == s[1] != s[2]) or (s[-1] == s[-2] != s[-3]):\n            total += 1\n            continue\n        for idx in range(1, len(s) - 2):\n            if s[idx - 1] != s[idx] == s[idx + 1] != s[idx + 2]:\n                total += 1\n                break\ntotal"
  },
  {
    "objectID": "qmd/2019.html#part-1-4",
    "href": "qmd/2019.html#part-1-4",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nprogram = IntCodeProgram(load(5, \"np\"), inputs=[1])\nlist(program.run())[-1]"
  },
  {
    "objectID": "qmd/2019.html#part-2-3",
    "href": "qmd/2019.html#part-2-3",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nprogram.reset()\nprogram.inputs = [5]\nnext(program.run())"
  },
  {
    "objectID": "qmd/2019.html#part-1-5",
    "href": "qmd/2019.html#part-1-5",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\nWe construct the DAG as a dictionary, where graph[node] corresponds to node.parent.\n\n\nCode\ndata = load(6)\ngraph = {child: parent for parent, child in map(lambda x: x.split(\")\"), data)}\n\n\n@functools.cache\ndef count_orbits(node):\n    if node == \"COM\":\n        return 0, ()\n    previous = count_orbits(graph[node])\n    return previous[0] + 1, (graph[node],) + previous[1]\n\n\nsum(count_orbits(x)[0] for x in graph)"
  },
  {
    "objectID": "qmd/2019.html#part-2-4",
    "href": "qmd/2019.html#part-2-4",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nMoving from orbit A to orbit B can be accomplished by moving to the last common ancestor of each node, and then switching branches. And that’s the same as getting the full ancestry of both nodes, minus anything they might have in common.\n\n\nCode\n_, p1 = count_orbits(\"YOU\")\n_, p2 = count_orbits(\"SAN\")\n\nlen(set(p1) ^ set(p2))"
  },
  {
    "objectID": "qmd/2019.html#part-1-6",
    "href": "qmd/2019.html#part-1-6",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nopcodes = load(7, \"np\")\nprogram = IntCodeProgram(opcodes)\nresults = []\nfor input_sequence in itertools.permutations(range(5)):\n    val = 0\n    for item in input_sequence:\n        program.reset()\n        program.inputs = [item, val]\n        val = next(program.run())\n    results.append(val)\nmax(results)"
  },
  {
    "objectID": "qmd/2019.html#part-2-5",
    "href": "qmd/2019.html#part-2-5",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nresults = []\nfor seq in itertools.permutations(range(5, 10)):\n    inputs = [[x] for x in seq]\n    inputs[0].append(0)\n    iterators = [IntCodeProgram(opcodes, inputs=inputs[i]).run() for i in range(5)]\n    i = 0\n    while True:\n        try:\n            val = next(iterators[i % 5])\n            inputs[(i + 1) % 5].append(val)\n            i += 1\n        except StopIteration:\n            break\n    results.append(val)\nmax(results)"
  },
  {
    "objectID": "qmd/2019.html#part-1-7",
    "href": "qmd/2019.html#part-1-7",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(8)[0]\nresult = []\nfor i in range(len(data) // (25 * 6))[::-1]:\n    substring = data[25 * 6 * i : 25 * 6 * (i + 1)]\n    result.append((substring.count(\"0\"), substring.count(\"1\") * substring.count(\"2\")))\nmin(result)[1]"
  },
  {
    "objectID": "qmd/2019.html#part-2-6",
    "href": "qmd/2019.html#part-2-6",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nresult = list(\"1\" * 25 * 6)\nfor i in range(len(data) // (25 * 6))[::-1]:\n    substring = data[25 * 6 * i : 25 * 6 * (i + 1)]\n    result = [bottom if top == \"2\" else top for top, bottom in zip(substring, result)]\n\nprint(\n    \"\\n\".join(\n        [\n            \"\".join([\"█\" if char != \"0\" else \" \" for char in line])\n            for line in np.array(result).reshape(6, 25)\n        ]\n    )\n)"
  },
  {
    "objectID": "qmd/2019.html#part-1-8",
    "href": "qmd/2019.html#part-1-8",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\nAdding the required functionality to the intcode compiler wasn’t too tricky. Opcodes which set values had to be modified a bit to account for the offset, but that was more or less it.\nAllowing arbitrary final addresses was accomplished by the very dirty hack of changing the program type in this problem from a list to defaultdict(int). If it works, it works.\n\n\nCode\nprogram = IntCodeProgram(load(9, \"np\"))\nprogram.inputs = [1]\nnext(program.run())"
  },
  {
    "objectID": "qmd/2019.html#part-2-7",
    "href": "qmd/2019.html#part-2-7",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nprogram.reset()\nprogram.inputs = [2]\nnext(program.run())"
  },
  {
    "objectID": "qmd/2019.html#part-1-9",
    "href": "qmd/2019.html#part-1-9",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nfrom math import gcd\n\n\ndef simplify(x, y):\n    if (x, y) == (0, 0):\n        return 0, 0\n    factor = gcd(x, y)\n    return int(x / factor), int(y / factor)\n\n\ndata = np.array(\n    [[0 if char == \".\" else 1 for char in line] for line in load(10)]\n).T\nones = np.array(np.where(data)).T\nscores = [\n    len(set(map(lambda x: simplify(*x), ones - ones[i]))) for i in range(len(ones))\n]\nposition = ones[np.argmax(scores)]\nprint(max(scores) - 1)\nprint(position)"
  },
  {
    "objectID": "qmd/2019.html#part-2-8",
    "href": "qmd/2019.html#part-2-8",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThere are more than 200 visible asteroids, so we only need to worry about the ones we meet on the first round - but that’s exactly the simplified asteroids, as seen from our position. We take these, and sort them according to the angle they make with the negative y axis (negative because we have y increasing as it goes down in this coordinate system). The one we’re interested in is the 201st asteroid according to this order (201st because the one we’re measuring from will automatically have an angle of zero and should not be counted)\n\n\nCode\n(\n    np.array(\n        sorted(\n            set([simplify(*x) for x in ones - position]),\n            key=lambda x: (np.arctan2(x[0], -x[1])) % (2 * np.pi),\n        )[200]\n    )\n    + position\n)"
  },
  {
    "objectID": "qmd/2019.html#part-1-10",
    "href": "qmd/2019.html#part-1-10",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nprogram = IntCodeProgram(load(11, \"np\"))\n\n\ndef solve(startval):\n    position, direction = 0 + 0j, 1j\n    program.reset()\n    field = defaultdict(int)\n    count = 0\n    program.inputs = [startval]\n    painted = set()\n    for colour, turn in more_itertools.chunked(program.run(), 2):\n        field[position] = colour\n        painted.add(position)\n        direction = direction * (1j * (1 - 2 * turn))\n        position += direction\n        program.inputs.append(field[position])\n    return painted, field\n\n\nlen(solve(0)[0])"
  },
  {
    "objectID": "qmd/2019.html#part-2-9",
    "href": "qmd/2019.html#part-2-9",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\n_, field = solve(1)\nones = np.array([x for x in field.keys() if field[x]])\noffset = ones.real.min() + 1j * ones.imag.min()\nones = ones - offset\nfield = np.zeros((int(ones.real.max()) + 1, int(ones.imag.max()) + 1))\nfor value in ones:\n    field[int(value.real), int(value.imag)] = 1\nprint(\n    \"\\n\".join(\n        [\"\".join([\"█\" if char else \" \" for char in line]) for line in np.rot90(field)]\n    )\n)"
  },
  {
    "objectID": "qmd/2019.html#part-1-11",
    "href": "qmd/2019.html#part-1-11",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(12, \"int\")\npositions = np.array(data, dtype=int)\nvelocities = np.zeros(positions.shape, dtype=int)\nindices = [0, 1, 2, 3]\nfor i in range(1000):\n    for m1, m2 in itertools.combinations([0, 1, 2, 3], 2):\n        dv = 1 * (positions[m2] &gt; positions[m1]) - 1 * (positions[m2] &lt; positions[m1])\n        velocities[m1] += dv\n        velocities[m2] -= dv\n    positions += velocities\n(np.abs(positions).sum(axis=1) * np.abs(velocities).sum(axis=1)).sum()"
  },
  {
    "objectID": "qmd/2019.html#part-2-10",
    "href": "qmd/2019.html#part-2-10",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nI don’t know what optimizations are possible here, but an obvious one is to realise that the three different directions (x,y and z) are completely independent, and that instead of searching for one global cycle, we can ask if there are shorter cycles for the coordinates separately. The global cycle length is then the lcm of the individual cycle lengths, as long as each cycle starts at the initial state.\n\n\nCode\ndata = load(12, \"int\")\npositions = np.array(data, dtype=int)\nvelocities = np.zeros(positions.shape, dtype=int)\nseen_x = {}\nseen_y = {}\nseen_z = {}\nfor axis, seen in zip([0, 1, 2], [seen_x, seen_y, seen_z]):\n    seen[tuple(np.hstack([positions[:, axis], velocities[:, axis]]))] = 0\ncycles = [False, False, False]\nfor i in range(1_000_000):\n    for m1, m2 in itertools.combinations([0, 1, 2, 3], 2):\n        dv = 1 * (positions[m2] &gt; positions[m1]) - 1 * (positions[m2] &lt; positions[m1])\n        velocities[m1] += dv\n        velocities[m2] -= dv\n    positions += velocities\n    for axis, seen in zip([0, 1, 2], [seen_x, seen_y, seen_z]):\n        if cycles[axis]:\n            continue\n        state = tuple(np.hstack([positions[:, axis], velocities[:, axis]]))\n        if state in seen:\n            cycles[axis] = i + 1\n    if all(cycles):\n        break\nmath.lcm(*cycles)"
  },
  {
    "objectID": "qmd/2019.html#part-1-12",
    "href": "qmd/2019.html#part-1-12",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nprogram = IntCodeProgram(load(13, \"np\"))\ntiles = set()\nfor x, y, kind in more_itertools.chunked(program.run(), 3):\n    if kind == 2:\n        tiles.add((x, y))\nlen(tiles)"
  },
  {
    "objectID": "qmd/2019.html#part-2-11",
    "href": "qmd/2019.html#part-2-11",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nprogram.set(0, 2)\nball, paddle = 0, 0\nresult = 0\n\n\ndef ai():\n    global ball\n    global paddle\n    return (ball &gt; paddle) - (ball &lt; paddle)\n\n\nprogram.set_input(ai)\nvalues = more_itertools.chunked(program.run(), 3)\nfor x, y, kind in values:\n    result = result if (x != -1) else kind\n    paddle = paddle if (kind != 3) else x\n    ball = ball if (kind != 4) else x\nresult"
  },
  {
    "objectID": "qmd/2019.html#part-1-13",
    "href": "qmd/2019.html#part-1-13",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ngraph = {}\nfor line in load(14):\n    inputs, output = line.split(\" =&gt; \")\n    output_amount, output_resource = output.split()\n    output_amount = int(output_amount)\n    inputs = [pair.split() for pair in inputs.split(\", \")]\n    graph[output_resource] = (\n        output_amount,\n        [x[1] for x in inputs],\n        [int(x[0]) for x in inputs],\n    )\n\n\ndef topological_sort(graph):\n    if not graph:\n        return []\n    dependencies = functools.reduce(lambda x, y: x | set(y[1]), graph.values(), set())\n    ready = []\n    for key in graph:\n        if key not in dependencies:\n            ready.append(key)\n    assert ready\n    new_graph = {k: v for k, v in graph.items() if k not in ready}\n    return ready + topological_sort(new_graph)\n\n\ndef part1(n):\n    order = topological_sort(graph)\n    requirements = defaultdict(int)\n    requirements[\"FUEL\"] = n\n    for resource in order:\n        production, kinds, amounts = graph[resource]\n        if resource in requirements:\n            n = int(np.ceil(requirements[resource] / production))\n            for kind, amount in zip(kinds, amounts):\n                requirements[kind] += n * amount\n        del requirements[resource]\n    return requirements[\"ORE\"]\n\n\npart1(1)"
  },
  {
    "objectID": "qmd/2019.html#part-2-12",
    "href": "qmd/2019.html#part-2-12",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWe need to somehow reverse the relationship we found above. There are probably smarter ways of doing things, but a binary search works fine:\n\n\nCode\ntarget = 1_000_000_000_000\nlower_limit = target // part1(1)\nupper_limit = lower_limit * 2\nwhile part1(upper_limit) &lt; target:\n    lower_limit *= 2\n    upper_limit *= 2\nwhile (upper_limit - lower_limit) != 1:\n    midpoint = int((upper_limit + lower_limit) / 2)\n    if part1(midpoint) &gt; target:\n        upper_limit = midpoint\n    else:\n        lower_limit = midpoint\nlower_limit"
  },
  {
    "objectID": "qmd/2019.html#part-1-14",
    "href": "qmd/2019.html#part-1-14",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\nI really liked this puzzle! The approach I took is to first map out the entire area by giving the droid the necessary instructions, and then using a path finding algorithm to get from start to finish.\n\n\nCode\nprogram = IntCodeProgram(load(15, \"np\"))\nf = program.run()\ndirections = {1: 1j, 2: -1j, 3: -1, 4: 1}\nreverse_directions = {v: k for k, v in directions.items()}\n\n\ndef neighbors(state, edges=None):\n    if edges is None:\n        return []\n    return [state + directions[neighbor] for neighbor in edges[state]]\n\n\ndef update(steps, state, neighbor):\n    return steps + [reverse_directions[neighbor - state]]\n\n\nqueue = deque([(0, 0)])\nold_position = 0\nvisited = set()\nedges = defaultdict(set)\ni = 0\nwhile queue:\n    i += 1\n    steps, position = queue.popleft()\n    visited.add(position)\n    instructions = utils.bfs(old_position, position, neighbors, [], update, edges=edges)\n    program.set_input(instructions)\n    while program.state != 1:\n        _ = next(f)\n    for direction in directions:\n        new_position = position + directions[direction]\n        opposite_direction = direction + 2 * (direction % 2) - 1\n        program.set_input([direction])\n        val = next(f)\n        if val == 0:\n            continue\n        program.set_input([opposite_direction])\n        _ = next(f)\n        edges[position].add(direction)\n        edges[new_position].add(opposite_direction)\n        if val == 2:\n            target = new_position\n        if new_position not in visited:\n            # append left to make it a dfs, so that the droid doesn't have to\n            # run from one side of the board to the other all the time\n            queue.appendleft((steps + 1, new_position))\n    old_position = position\nutils.bfs(0, target, neighbors, edges=edges)"
  },
  {
    "objectID": "qmd/2019.html#part-2-13",
    "href": "qmd/2019.html#part-2-13",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWe mapped out the whole area for part 1, so part 2 is just a bfs with no stopping condition\n\n\nCode\nutils.bfs(target, None, neighbors, edges=edges)"
  },
  {
    "objectID": "qmd/2019.html#part-1-15",
    "href": "qmd/2019.html#part-1-15",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\nFor the first part all the numbers are small, so we don’t need to be particularly clever\n\n\nCode\ninitial_data = [int(x) for x in load(16)[0]]\ndata = initial_data.copy()\nbase_pattern = np.array([0, 1, 0, -1])\nfactors = []\nfor i in range(1, len(data) + 1):\n    pattern = base_pattern.repeat(i)\n    repeats = int(np.ceil((len(data) + 1) / len(pattern)))\n    factors.append(np.tile(pattern, repeats)[1 : len(data) + 1])\nfactors = np.array(factors)\nfor i in range(100):\n    data = abs(factors @ data) % 10\nprint(*data[:8], sep=\"\", end=\"\\n\")"
  },
  {
    "objectID": "qmd/2019.html#part-2-14",
    "href": "qmd/2019.html#part-2-14",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, the numbers get so big that this approach is impossible (just the transition matrix has \\(\\textrm{len(data)}^2 \\times10^8\\) elements, so that’s not going to work).\nThe first optimization we can make is to realise that calculating the \\(k\\)-th from last digit of the output only requires knowledge of the last \\(k\\) digits of the input. So the last digit is always unchanged, the last-but-one digit is always the sum of the previous last two digits etc.\nIn fact, we can explicitly solve this reccurrence for the second half of the input data, and looking at the data provided, that’s where the relevant digits are located! Denoting the \\(k\\)-th digit from the end after the \\(n\\)-th iteration as \\(d_k^n\\), we can verify that\n\\[\\begin{align*}\nd^n_0 &= d^{n-1}_0 = \\ldots = d^0_0 \\\\\nd^n_1 &= d^{n-1}_1 + (d^{n-1}_0) = d^0_1 + nd^0_0 \\\\\nd^n_2 &= d^{n-1}_2 + (d^{n-1}_1 + d^{n-1}_0) = d^0_2 + nd^0_1 + \\frac12n(n+1)d^0_0 \\\\\n\\end{align*}\\]\nExplicitly solving the recurrences for all the digits in the second half is certainly possible, but it’s going to be very tedious. Instead, we can notice that the middle expression is always \\(d^{n-1}_k + d^n_{k -1}\\) . That means that to calculate \\(d^{100}_k\\) we only need to know \\(d^0_k\\) and \\(d^1_{k-1}, d^2_{k-1}, \\ldots, d^{100}_{k-1}\\), which translates to the following short routine:\n\n\nCode\nactive = 101 * [0]\nresults = []\nindex = functools.reduce(lambda x, y: 10 * x + y, initial_data[:7])\ndata = np.tile(initial_data, 10_000)\ncounter_index = len(data) - index\nfor i in range(counter_index):\n    active[0] = data[-1 - i]\n    active = np.cumsum(active) % 10\n    results.append(active[-1])\nfunctools.reduce(lambda x, y: 10 * x + y, results[::-1][:8])"
  },
  {
    "objectID": "qmd/2019.html#part-1-16",
    "href": "qmd/2019.html#part-1-16",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nopcodes = load(17, \"np\")\nprogram = IntCodeProgram(opcodes)\ndata = \"\".join(chr(val) for val in program.run()).split(\"\\n\")[:-2]\nboard = np.array([[1 if char == \"#\" else 0 for char in line] for line in data])\nneighbors = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\nintersections = np.where(\n    (scipy.ndimage.convolve(board, neighbors, mode=\"constant\") &gt; 2) & board\n)\nnp.product(intersections, axis=0).sum()"
  },
  {
    "objectID": "qmd/2019.html#part-2-15",
    "href": "qmd/2019.html#part-2-15",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor this one I solved the path by hand, and then ran the input through the black box program to get the actual output.\n\n\nCode\nA = \"R,6,L,12,R,6\"\nB = \"L,12,R,6,L,8,L,12\"\nC = \"R,12,L,10,L,10\"\nmain = \"A,A,B,C,B,C,B,C,B,A\"\nshow_output = \"n\\n\"\nprogram_input = \"\\n\".join(x for x in [main, A, B, C, show_output])\nencoded_input = [ord(x) for x in program_input]\nprogram.set(0, 2)\nprogram.set_input(encoded_input)\n[x for x in program.run()][-1]"
  },
  {
    "objectID": "qmd/2019.html#part-1-17",
    "href": "qmd/2019.html#part-1-17",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThe maze we are looking at is fairly large, but it only has a few interesting points. Most of the maze is corridors of width 1; and on these stretches there are no choices about where to go, since backtracking is not an option. Instead of working with the grid we are given, we can extract the points of interest, and store the distance from each point to its neighbors.\nThe points of interest are:\n\nKeys\nDoors\nJunctions\n\nThe numbers here are barely small enough that the straightforward approach works: A BFS with a different visited list for each possible set of collected keys. To slightly improve the runtime, we’ll start by eliminating dead ends so the BFS never has to consider them.\n\n\nCode\ndata = np.array([[ord(c) for c in line] for line in load(18)])\nindices = np.where(data == ord(\"@\"))\nstart = list(zip(*indices))[0]\nwall = ord(\"#\")\nfree = ord(\".\")\ndata[indices] = free\nwindow = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\nwalls = (data == wall) * 1\nwalls\ns = 1\nwhile s &gt; 0:\n    walls = (data == wall) * 1\n    dead_ends = (scipy.ndimage.convolve(walls, window, mode=\"constant\") &gt; 2) & (\n        (data == free) | ((data &gt;= ord(\"A\")) & (data &lt;= ord(\"Z\")))\n    )\n    s = dead_ends.sum()\n    data[dead_ends] = wall\nnw = 1 * (data != wall)\njunctions = (scipy.ndimage.convolve(nw, window, mode=\"constant\") &gt; 2) & nw\n\ndata[np.where(junctions)] = ord(\"9\")\nqueue = deque()\nconnections = defaultdict(dict)\npainted = {}\nwidth = data.shape[1]\n\n\ndef label(position):\n    if data[position] == ord(\"9\"):\n        return str(position[0] * width + position[1])\n    else:\n        return chr(data[position])\n\n\n# print(*[\"\".join(chr(x) for x in line) for line in data], sep=\"\\n\")\nfor start in list(zip(*np.where(data &gt; max(free, wall)))):\n    queue.append((0, start, start))\nwhile queue:\n    steps, position, origin = queue.popleft()\n    if position in painted:\n        other, other_steps = painted[position]\n        if other != origin:\n            s = steps + other_steps\n            connections[label(other)][label(origin)] = s\n            connections[label(origin)][label(other)] = s\n        continue\n    painted[position] = origin, steps\n    y, x = position\n    for neighbor in [(y - 1, x), (y, x - 1), (y, x + 1), (y + 1, x)]:\n        if data[neighbor] == wall:\n            continue\n        queue.append((steps + 1, neighbor, origin))\nstate = frozenset()\nstart = 0, label((40, 40)), state\nq = PriorityQueue()\nq.put(start)\nvisited = defaultdict(set)\nwhile q.qsize() &gt; 0:\n    steps, l, state = q.get()\n    if len(state) == 26:\n        break\n    if l in visited[state]:\n        continue\n    visited[state].add(l)\n    for neighbor in connections[l]:\n        new_state = state.copy()\n        if neighbor in visited[state]:\n            continue\n        elif \"A\" &lt;= neighbor &lt;= \"Z\" and neighbor.lower() not in state:\n            continue\n        elif \"a\" &lt;= neighbor &lt;= \"z\":\n            new_state = state | frozenset(neighbor)\n        s = steps + connections[l][neighbor]\n        q.put((s, neighbor, new_state))\nsteps"
  },
  {
    "objectID": "qmd/2019.html#part-2-16",
    "href": "qmd/2019.html#part-2-16",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2 we need to keep track of four different robots, which increases the number of neighbors available at each stage. However, direct inspection of the graph of the problem for this specific input reveals that the robots are never waiting for each other, so the shortest amount of steps is just the sum of the individual shortest steps to clear each subgraph. It feels a bit cheesy to completely ignore the doors in the puzzle, but it works here.\n\n\nCode\nx = 40\nstarts = [(x - 1, x - 1), (x - 1, x + 1), (x + 1, x - 1), (x + 1, x + 1)]\ndead_positions = [(x - 1, x), (x, x - 1), (x, x), (x, x + 1), (x + 1, x)]\ndead_labels = [label(_) for _ in dead_positions]\npart2 = {\n    k: {p: q for p, q in v.items() if p not in dead_labels}\n    for k, v in connections.items()\n    if k not in dead_labels\n}\ntotal = 0\nfor start in map(label, starts):\n    nodes = deque([start])\n    seen = set()\n    while nodes:\n        current = nodes.popleft()\n        if current in seen:\n            continue\n        seen.add(current)\n        for neighbor in part2[current]:\n            if neighbor not in seen:\n                nodes.append(neighbor)\n    targets = [x for x in seen if \"a\" &lt;= x &lt;= \"z\"]\n    state = frozenset()\n    q = PriorityQueue()\n    q.put((0, start, state))\n    visited = defaultdict(set)\n    while q.qsize() &gt; 0:\n        steps, position, state = q.get()\n        if len(state) == len(targets):\n            break\n        if position in visited[state]:\n            continue\n        visited[state].add(position)\n        for neighbor in part2[position]:\n            new_state = state.copy()\n            if neighbor in visited[state]:\n                continue\n            if neighbor in targets:\n                new_state = state | frozenset(neighbor)\n            q.put((steps + part2[position][neighbor], neighbor, new_state))\n    total += steps\ntotal"
  },
  {
    "objectID": "qmd/2019.html#part-1-18",
    "href": "qmd/2019.html#part-1-18",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nopcodes = load(19, \"np\")\nprogram = IntCodeProgram(opcodes)\ninputs = []\nprogram.set_input(inputs)\nsize = 50\nboard = np.zeros((size, size), dtype=int)\nfor i in range(size):\n    for j in range(size):\n        program.reset()\n        inputs += [j, i]\n        board[i, j] = next(program.run())\nboard.sum()"
  },
  {
    "objectID": "qmd/2019.html#part-2-17",
    "href": "qmd/2019.html#part-2-17",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ntop_edge = []\nbottom_edge = []\ncurrent_top = 0\ncurrent_bottom = 0\nfor j in range(1000):\n    bottom_val = 1\n    top_val = 0\n    current_top -= 1\n    while top_val == 0 and current_top &lt;= 2 * j:\n        current_top += 1\n        program.reset()\n        program.set_input([j, current_top])\n        top_val = next(program.run())\n    if not top_val:\n        current_top = 0\n    if not current_bottom:\n        current_bottom = current_top\n    while bottom_val == 1:\n        current_bottom += 1\n        program.reset()\n        program.set_input([j, current_bottom])\n        bottom_val = next(program.run())\n    top_edge.append(current_top)\n    bottom_edge.append(current_bottom - 1)\n\naxis = np.arange(len(bottom_edge))\ntop_slope = np.polyfit(axis, top_edge, 1)[0]\nw = 99\ndy = (top_slope + 1) * w\nx = (np.array(bottom_edge) - np.array(top_edge) &gt;= dy).argmax()\ny = bottom_edge[x] - w\nwhile top_edge[x + w] &lt;= (bottom_edge[x] - w):\n    x -= 1\n    y = bottom_edge[x] - w\nx += 1\ny = bottom_edge[x] - w\n10000 * x + y"
  },
  {
    "objectID": "qmd/2019.html#part-1-19",
    "href": "qmd/2019.html#part-1-19",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis can be done with a fairly simple BFS. The only added difficulty is that we need some way of specifying that two portals of the same letter neighbor each other.\nIn terms of the number of lines, that’s what most of the following code is doing.\n\n\nCode\ndata = np.array([[ord(char) for char in line[:-1]] for line in load(20)], dtype=int)\nportals = ((ord(\"A\") &lt;= data) & (data &lt;= ord(\"Z\"))) * 1\n\n\ndef label(item):\n    if isinstance(item, str):\n        item = np.array([ord(x) for x in item])\n    return functools.reduce(lambda x, y: -(26 * x + y), item - ord(\"A\") + 1)\n\n\nymax, xmax = data.shape\nverticals = np.where(scipy.ndimage.correlate(portals, [[1], [1]], mode=\"constant\") == 2)\nhorizontals = np.where(scipy.ndimage.correlate(portals, [[1, 1]], mode=\"constant\") == 2)\n\n\ndef vertical_neighbors(y, x):\n    return [\n        [y - 2, x],\n        [y - 1, x - 1],\n        [y - 1, x + 1],\n        [y, x - 1],\n        [y, x + 1],\n        [y + 1, x],\n    ]\n\n\ndef horizontal_neighbors(y, x):\n    return [\n        [y, x - 2],\n        [y - 1, x - 1],\n        [y + 1, x - 1],\n        [y - 1, x],\n        [y + 1, x],\n        [y, x + 1],\n    ]\n\n\ndef horizontal_window(y, x):\n    return np.array((y, y)), np.array((x - 1, x))\n\n\ndef vertical_window(y, x):\n    return np.array((y - 1, y)), np.array((x, x))\n\n\nfor portals, neighbors, window in zip(\n    [verticals, horizontals],\n    [vertical_neighbors, horizontal_neighbors],\n    [vertical_window, horizontal_window],\n):\n    for portal in sorted(zip(*portals)):\n        w = window(*portal)\n        n = [\n            i for i in neighbors(*portal) if data[i[0] % ymax, i[1] % xmax] == ord(\".\")\n        ][0]\n        data[tuple(n)] = label(data[w])\n        data[w] = ord(\"#\")\nstart = next(zip(*np.where(data == label(\"AA\"))))\ndestination = next(zip(*np.where(data == label(\"ZZ\"))))\npaths = deque([(start, 0)])\nseen = set()\nwhile paths:\n    (y, x), distance = paths.popleft()\n    if (y, x) in seen:\n        continue\n    if (y, x) == destination:\n        break\n    seen.add((y, x))\n    neighbors = [\n        c\n        for c in [(y - 1, x), (y, x - 1), (y, x + 1), (y + 1, x)]\n        if (data[c] == ord(\".\")) or data[c] &lt; 0\n    ]\n    if data[y, x] &lt; 0:\n        neighbors += sorted(zip(*np.where(data == data[y, x])))\n    for neighbor in neighbors:\n        if neighbor in seen:\n            continue\n        paths.append((neighbor, distance + 1))\ndistance"
  },
  {
    "objectID": "qmd/2019.html#part-2-18",
    "href": "qmd/2019.html#part-2-18",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, we basically just need to add a level coordinate to our state, and change the way we enumerate neighbors to account for the fact that moving through a portal changes the levels\n\n\nCode\nlevel_change = defaultdict(lambda: 1)\nportals = np.where(data &lt; 0)\nfor y, x in zip(*portals):\n    if x == 2 or y == 2 or x == xmax - 3 or y == ymax - 3:\n        level_change[y, x] = -1\nstart = next(zip(*np.where(data == label(\"AA\")))) + (0,)\ndestination = next(zip(*np.where(data == label(\"ZZ\")))) + (0,)\npaths = deque([(start, 0)])\nseen = set()\nwhile paths:\n    (y, x, level), distance = paths.popleft()\n    if (y, x, level) in seen:\n        continue\n    if (y, x, level) == destination:\n        break\n    seen.add((y, x, level))\n    neighbors = [\n        c + (level,)\n        for c in [(y - 1, x), (y, x - 1), (y, x + 1), (y + 1, x)]\n        if (data[c] == ord(\".\")) or data[c] &lt; 0\n    ]\n    if data[y, x] &lt; 0:\n        new_level = level + level_change[y, x]\n        if new_level &gt;= 0:\n            other_neighbors = set(zip(*np.where(data == data[y, x]))) - set([(y, x)])\n            for neighbor in other_neighbors:\n                neighbors += [neighbor + (new_level,)]\n    for neighbor in neighbors:\n        if neighbor in seen:\n            continue\n        paths.append((neighbor, distance + 1))\ndistance"
  },
  {
    "objectID": "qmd/2019.html#part-1-20",
    "href": "qmd/2019.html#part-1-20",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\nPart 1 is possible to brute force, even if a bit of thought is needed to do it. With 3 different commands available, with six options for their first argument and 2 for their second, there are are 36 possible SPRINGSCRIPT instructions; each program is a max of 15 instructions, so there are more than \\(2\\times10^{23}\\) possible programs. That’s not the right way to go.\nOn the other hand, there are only four inputs at any given stage, so there are only 16 distinct inputs to our assignments. The program we have to supply is just a way of mapping each input to either 0 or 1, and there are only \\(2^{16}\\) of those.\nAdditionally, we are told that jumping when there is a hole 4 tiles away will result in automatic loss, since that’s how far we jump. Similarly, not jumping when there is a hole right in front of us will result in a loss. So any valid rule has to have the following structure (0 as input is hole, 1 is ground; 0 as output is don’t jump, 1 is jump)\n\n0BCD -&gt; 1\nABC0 -&gt; 0\n\n(this reveals that the input 0BC0 is an automatic loss)\nThat also means that for anything else we can assume A = 1 and D = 1, since otherwise the output is fixed. So really we just have to map the four BC states. That means there are only 16 possible programs, so we can enumerate them all. Especially since 8 of them are mirrors of the other 8.\n\n\nCode\nspringscript_programs = [\n    [],\n    [\"NOT B T\", \"NOT C J\", \"OR T J\", \"NOT J J\"],\n    [\"NOT C J\", \"AND B J\"],\n    [\"NOT B J\", \"NOT J J\"],\n    [\"NOT B J\", \"AND C J\"],\n    [\"NOT C J\", \"NOT J J\"],\n    [\"NOT B J\", \"AND C J\", \"NOT C T\", \"AND B T\", \"OR T J\"],\n    [\"NOT B T\", \"NOT C J\", \"AND T J\", \"NOT J J\"],\n]\n\n\ndef invert(program):\n    try:\n        if program[-1] == \"NOT J J\":\n            return program[:-1]\n    except:\n        pass\n    return program + [\"NOT J J\"]\n\n\nfooter = [\"NOT A T\", \"OR T J\", \"AND D J\", \"WALK\"]\nspringscript_programs += [invert(p) for p in springscript_programs]\nspringscript_programs = [p + footer for p in springscript_programs]\nencoded = [\n    [ord(char) for char in \"\\n\".join(program) + \"\\n\"]\n    for program in springscript_programs\n]\nprogram = IntCodeProgram(load(21, \"np\"))\nfor p in springscript_programs:\n    encoded_program = [ord(char) for char in \"\\n\".join(p) + \"\\n\"]\n    program.reset()\n    program.set_input(encoded_program)\n    for value in program.run():\n        if value &gt; 255:\n            break\n    else:\n        continue\n    break\nvalue"
  },
  {
    "objectID": "qmd/2019.html#part-2-19",
    "href": "qmd/2019.html#part-2-19",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWell.\nFor part 2 we get five more registers, for a total of 7 that are allowed to vary state. That makes 128 possible inputs, and \\(\\approx10^{38}\\) possible mappings. The total number of 15-line springscript programs is only \\(\\left(3\\times11\\times2\\right)^{15} \\approx 2\\times10^{27}\\), so a different approach is going to be needed\nSome thoughts:\n\nIf all of ABCD are ground there is no reason to jump, since we can just move forward. If A is a hole we have to jump, and if D is a hole we cannot jump. In general, if the landing is safe, we should try and jump early, since that’ll give us more time to think on the other side. So if either B or C is a hole and D is safe we should jump. The exception is when H is a hole since then we cannot jump from D, and would be better off waiting to see what happens\n\n\n\nCode\nspringscript_program = [\n    \"NOT B J\",\n    \"NOT C T\",\n    \"OR T J\",\n    \"AND D J\",  # if d is ground and there's a hole at B or C, we can jump to D\n    \"AND H J\",  # but only if H is also ground\n    \"NOT A T\",  # if next tile is a hole we have to jump\n    \"OR T J\",\n    \"RUN\",\n]\nencoded_program = [ord(char) for char in \"\\n\".join(springscript_program) + \"\\n\"]\nprogram.reset()\nprogram.set_input(encoded_program)\nfor value in program.run():\n    if value &gt; 255:\n        break\n    print(chr(value), end=\"\")\nvalue"
  },
  {
    "objectID": "qmd/2019.html#part-1-21",
    "href": "qmd/2019.html#part-1-21",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\nWe are asked to follow how a single number moves - the one initally at position 2019. So if we build the operations so that they take an old position and return the new position, we can completely avoid dealing with the rest of the array.\n\n\nCode\ninstructions = [str.split(x) for x in load(22)]\nlookup = {\"cut\": 1, \"deal\": 2}\ninstructions = [\n    (0,)\n    if instruction[-1] == \"stack\"\n    else (lookup[instruction[0]], int(instruction[-1]))\n    for instruction in instructions\n]\n\nl = 10007\np = 2019\nfor instruction in instructions:\n    if instruction[0] == 0:\n        p = (l - p - 1) % l\n    elif instruction[0] == 1:\n        p = (p - instruction[1]) % l\n    else:\n        p = (p * instruction[1]) % l\np"
  },
  {
    "objectID": "qmd/2019.html#part-2-20",
    "href": "qmd/2019.html#part-2-20",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nTo nobody’s great surprise, part 2 ups the difficulty significantly, with the usual trick of increasing the numbers of cards and rounds significantly.\nAdditionally, since we’re tracking what card ends up at a given spot rather than what spot a given card ends up at, we’ll need to reverse the operations defined above, and apply them in reverse order. For the first two that’s not a big issue, since the reversal is trivial. For the last one, we’ll need a way to find multiplicative inverses in the modular group. We’ll use the extended euclidean algorithm for that; it’s already implemented in the utils file.\nEven with those optimizations, doing as many rounds as required isn’t possible. Instead, we can realise that each of the three operations on the position is linear, and therefore so is their composition. That means that we can model the result of each round as\n\\(p \\rightarrow ap + b \\qquad \\mod l\\)\nfor some constants a and b. We can find these constants, and thus reduce the work needed for each round to calculating a multiplication, an addition and a remainder; making each round much faster.\nThe number of rounds is still prohibitive if we’re stuck doing them one at a time, but once we know the coefficients for doing one round, we can easily find the coefficients for doing 2 rounds. That lets us use a multiplication by squaring approach to getting the answer.\n\n\nCode\nl = 119315717514047\nstate = (1, 0)\nfor instruction in instructions[::-1]:\n    if instruction[0] == 0:\n        state = -state[0], l - state[1] - 1\n    elif instruction[0] == 1:\n        state = state[0], state[1] + instruction[1]\n    else:\n        state = [x * inverses[instruction[1]] for x in state]\n    state = [x % l for x in state]\n\n\ndef compose(c1, c2):\n    return (c1[0] * c2[0]) % l, (c2[0] * c1[1] + c2[1]) % l\n\n\np = 2020\ni = 101741582076661\nwhile i:\n    if i % 2:\n        p = (p * state[0] + state[1]) % l\n        i -= 1\n    else:\n        state = compose(state, state)\n        i = i &gt;&gt; 1\np"
  },
  {
    "objectID": "qmd/2019.html#part-1-22",
    "href": "qmd/2019.html#part-1-22",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(23, \"np\")\nbus = [[x] for x in list(range(50))]\n\nprograms = []\nfor i in range(50):\n    program = IntCodeProgram(data, inputs=bus[i])\n    programs.append(program)\n\nidx = 0\ndone = False\nwhile True:\n    program = programs[idx]\n    values = program.run()\n    outputs = []\n    count = 0\n    for value in values:\n        if value == 255 and (count % 3) == 0:\n            done = True\n            break\n        if program.state == 1:\n            bus[idx].append(-1)\n            break\n        outputs += [value]\n    if done:\n        x = next(values)\n        y = next(values)\n        break\n    for destination, x, y in more_itertools.chunked(outputs, 3):\n        bus[destination] += [x, y]\n    idx = (idx + 1) % 50 if not outputs else destination\n\ny"
  },
  {
    "objectID": "qmd/2019.html#part-2-21",
    "href": "qmd/2019.html#part-2-21",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndata = load(23, \"np\")\nbus = [[x] for x in list(range(50))]\n\nprograms = []\nfor i in range(50):\n    program = IntCodeProgram(data, inputs=bus[i])\n    programs.append(program)\n\nidx = 0\ndone = False\ndef is_idle(bus):\n    return all(i == [-1] for i in bus)\nnat = [x, y]\nold_y = -1\nwhile True:\n    if is_idle(bus):\n        if nat[1] == old_y:\n            break\n        new_input = nat.copy()\n        bus[0] = new_input\n        programs[0].set_input(new_input)\n        old_y = nat[1]\n        idx = 0\n    program = programs[idx]\n    values = program.run()\n    outputs = []\n    for value in values:\n        if program.state == 1:\n            bus[idx].append(-1)\n            break\n        outputs += [value]\n    for destination, x, y in more_itertools.chunked(outputs, 3):\n        if destination == 255:\n            nat = [x, y]\n        else:\n            bus[destination] += [x, y]\n    idx = (idx + 1) % 50\nold_y"
  },
  {
    "objectID": "qmd/2019.html#part-1-23",
    "href": "qmd/2019.html#part-1-23",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ninitial_state = np.array(\n    [[0 if char == \".\" else 1 for char in line] for line in load(24)]\n)\nstate = initial_state.copy()\nweights = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\nseen = {}\nwhile tuple(state.ravel()) not in seen:\n    seen[tuple(state.ravel())] = True\n    bugs = scipy.ndimage.convolve(state, weights, mode=\"constant\")\n    changes = bugs != 1\n    empty = np.where(state == 0)\n    changes[empty] = ((bugs == 1) | (bugs == 2))[empty]\n    state = (state + changes) % 2\nx = state.ravel()\n(x * (2 ** np.arange(len(x)))).sum()"
  },
  {
    "objectID": "qmd/2019.html#part-2-22",
    "href": "qmd/2019.html#part-2-22",
    "title": "2019 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, we need to figure out how to account for the different levels and how to account for the new neighbors.\nWe’ll add the different recursion levels as a new first axis in our array, and we know that it takes at least two steps before an initially empty layer can affect it’s neighbor: one to reach the layer, and one to spread to the edge/centre of the layer. That means that instead of expanding the first axis at every step, we can precompute how many we’ll need and fill with zeros.\nWe can get the in-plane neighbors exactly as before, and after far too much thought, we can get the new neighbors with some clever numpy indexing. This could possibly be shortened even further, but tbh it’s concise enough as it is.\n\n\nCode\nlength = 200\nstate = np.zeros((length + 3, *initial_state.shape), dtype=int)\nstate[int(length // 2) + 1] = initial_state\nfor i in range(length):\n    neighbors = scipy.ndimage.convolve(state, [weights], mode=\"constant\")\n    neighbors[:, (0, -1), :] += np.roll(state[:, (1, 3), 2], 1, axis=0)[:, :, None]\n    neighbors[:, :, (0, -1)] += np.roll(state[:, 2, (1, 3)], 1, axis=0)[:, None, :]\n    neighbors[:, (1, 3), 2] += np.roll(state[:, (0, -1), :], -1, axis=0).sum(axis=2)\n    neighbors[:, 2, (1, 3)] += np.roll(state[:, :, (0, -1)], -1, axis=0).sum(axis=1)\n    changes = neighbors != 1\n    empty = np.where(state == 0)\n    changes[empty] = ((neighbors == 1) | (neighbors == 2))[empty]\n    state = (state + changes) % 2\n    state[:, 2, 2] = 0\n\nstate.sum()"
  },
  {
    "objectID": "qmd/2019.html#part-1-24",
    "href": "qmd/2019.html#part-1-24",
    "title": "2019 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nprogram = IntCodeProgram(load(25, \"np\"), inputs=[])\n\n\ndef run():\n    for char in program.run():\n        if program.state != 1:\n            print(chr(char), end=\"\")\n        else:\n            s = input().strip()\n            program.inputs += [ord(x) for x in s + \"\\n\"]"
  },
  {
    "objectID": "qmd/2024.html",
    "href": "qmd/2024.html",
    "title": "2024 Solutions",
    "section": "",
    "text": "Code\nimport dataclasses\nimport functools\nimport itertools\nimport os\nimport re\nimport sys\nfrom collections import defaultdict, deque, namedtuple\nfrom queue import PriorityQueue\n\nimport more_itertools\nimport numpy as np\nimport operator\nimport pandas as pd\nimport scipy\n\nsys.path.insert(1, \"..\")\n\nimport utils\n\nload = utils.year_load(2024)"
  },
  {
    "objectID": "qmd/2024.html#part-1",
    "href": "qmd/2024.html#part-1",
    "title": "2024 Solutions",
    "section": "Part 1",
    "text": "Part 1\nLoad the data, sort the two columns, find the absolute difference between them and sum the result.\n\n\nCode\ndata = np.sort(load(1, \"int\"), axis=0)\nabs(np.diff(data)).sum()"
  },
  {
    "objectID": "qmd/2024.html#part-2",
    "href": "qmd/2024.html#part-2",
    "title": "2024 Solutions",
    "section": "Part 2",
    "text": "Part 2\nnumpy has a handy method to find the unique values in an array, and their counts. Let’s use that to make a dictionary of value -&gt; count pairs for the right list with a default value of zero, and then just look up that value for each element of the left list.\n\n\nCode\nlookup = defaultdict(int)\nlookup.update(\n    {value: count for value, count in zip(*np.unique(data[:, 1], return_counts=True))}\n)\nsum(x * lookup[x] for x in data[:, 0])"
  },
  {
    "objectID": "qmd/2024.html#part-1-1",
    "href": "qmd/2024.html#part-1-1",
    "title": "2024 Solutions",
    "section": "Part 1",
    "text": "Part 1\nNothing too complicated going on here: load the data, and find the difference between successive values. To account for decreasing sequences, multiply by the sign of the first difference and then require that all the differences be greater than one and less than or equal to three.\n\n\nCode\ndata = load(2, \"int\")\n\n\ndef is_safe(line):\n    diff = np.diff(line)\n    diff = diff * np.sign(diff[0])\n    return int(((diff &gt; 0) & (diff &lt;= 3)).all())\n\n\nsum(is_safe(line) for line in data)"
  },
  {
    "objectID": "qmd/2024.html#part-2-1",
    "href": "qmd/2024.html#part-2-1",
    "title": "2024 Solutions",
    "section": "Part 2",
    "text": "Part 2\nI spent a bit of time trying to see if there was a neat way of incorporating the “is valid if any one number is deleted” requirement, but I couldn’t immediately see it, so I ended up just iterating over all the possible deletions instead.\n\n\nCode\ntotal = 0\nfor line in data:\n    for idx in range(len(line)):\n        if is_safe(line[:idx] + line[idx + 1 :]):\n            total += 1\n            break\ntotal"
  },
  {
    "objectID": "qmd/2024.html#part-1-2",
    "href": "qmd/2024.html#part-1-2",
    "title": "2024 Solutions",
    "section": "Part 1",
    "text": "Part 1\nWe get to play with regex! Well, I do – there might be better ways of tackling this. The format for a valid mul instruction is quite strict, encoding that as a regex is fairly straightforward. Once we have that, we can use re.findall to find all the occurrences and extract the integers.\n\n\nCode\ndata = load(3, \"raw\")\nmul = r\"mul\\((\\d{1,3}),(\\d{1,3})\\)\"\nsum(int(pair[0]) * int(pair[1]) for pair in re.findall(mul, data))"
  },
  {
    "objectID": "qmd/2024.html#part-2-2",
    "href": "qmd/2024.html#part-2-2",
    "title": "2024 Solutions",
    "section": "Part 2:",
    "text": "Part 2:\nI’m pretty happy with my part two, which I managed to do fairly elegantly. We can ignore all the sections immediately after a don't() instruction by splitting the string on those, and then discarding the start of each substring up to the first do() instruction. Concatenating all the substrings gives us a clean string with just the segments we are interested in, and we can proceed as before.\n\n\nCode\nclean = \"\".join(\n    [segment[segment.find(\"do()\") :] for segment in (\"do()\" + data).split(\"don't()\")]\n)\nsum(int(pair[0]) * int(pair[1]) for pair in re.findall(mul, clean))"
  },
  {
    "objectID": "qmd/2024.html#part-1-3",
    "href": "qmd/2024.html#part-1-3",
    "title": "2024 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = np.array([[ord(char) for char in line] for line in load(4)])\nmask = np.array([ord(char) for char in \"XMAS\"])\n\n\ndef xmas(chararray):\n    return (chararray == mask).all() or (chararray == mask[::-1]).all()\n\n\nfootprints = [np.eye(4), np.fliplr(np.eye(4)), [[1, 1, 1, 1]], [[1], [1], [1], [1]]]\n\nsum(\n    scipy.ndimage.generic_filter(data, xmas, footprint=footprint, mode=\"constant\").sum()\n    for footprint in footprints\n)"
  },
  {
    "objectID": "qmd/2024.html#part-2-3",
    "href": "qmd/2024.html#part-2-3",
    "title": "2024 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nmasks = [\"MMASS\", \"SMASM\", \"MSAMS\", \"SSAMM\"]\nencoded_masks = [np.array([ord(char) for char in mask]) for mask in masks]\nfootprint = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\ndef x_mas(chararray):\n    for mask in encoded_masks:\n        if (chararray == mask).all():\n            return 1\n    return 0\nscipy.ndimage.generic_filter(data, x_mas, footprint=footprint, mode=\"constant\").sum()"
  },
  {
    "objectID": "qmd/2024.html#part-1-4",
    "href": "qmd/2024.html#part-1-4",
    "title": "2024 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nrules, updates = [x.split(\"\\n\") for x in load(5, \"raw\").split(\"\\n\\n\")]\nupdates = [[int(x) for x in line.split(\",\")] for line in updates]\nancestors = defaultdict(list)\ndescendents = defaultdict(list)\nfor rule in rules:\n    first, last = map(int, rule.split(\"|\"))\n    ancestors[last].append(first)\n    descendents[first].append(last)\n\n\ndef restriction(rules, keys):\n    return {key: [x for x in rules[key] if x in keys] for key in keys}\n\n\ndef is_sorted(keys):\n    keys = keys.copy()\n    pre = restriction(ancestors, keys)\n    post = restriction(descendents, keys)\n    while keys:\n        current = keys.pop(0)\n        if pre[current]:\n            return False\n        del pre[current]\n        for item in post[current]:\n            pre[item] = [x for x in pre[item] if x != current]\n    return True\n\n\nsum(update[len(update) // 2] for update in updates if is_sorted(update))"
  },
  {
    "objectID": "qmd/2024.html#part-2-4",
    "href": "qmd/2024.html#part-2-4",
    "title": "2024 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2 we’ll actually implement the topological sort. I vaguely remembered how to do this, but it took a couple of iterations to get right.\nThe idea is that we start by scanning the rules dictionary for items which are eligible for immediate placement, and remove them from the list.\nWe then iteratively place these items, and for each item we place, we remove any blocks that they might have placed on later items. That might mean that new items are eligible for placement, and in this way we iterate through the entire list and output an order compatible with the rules.\n\n\nCode\ndef topological_sort(keys):\n    pre = restriction(ancestors, keys)\n    post = restriction(descendents, keys)\n    result = []\n    to_delete = [key for key in pre if not pre[key]]\n    for key in to_delete:\n        del pre[key]\n    while to_delete:\n        n = to_delete.pop()\n        result.append(n)\n        for item in post[n]:\n            pre[item] = [x for x in pre[item] if x != n]\n            if not pre[item]:\n                to_delete.append(item)\n                del pre[item]\n    return result\n\n\nsum(topological_sort(line)[len(line) // 2] for line in updates if not is_sorted(line))"
  },
  {
    "objectID": "qmd/2024.html#part-1-5",
    "href": "qmd/2024.html#part-1-5",
    "title": "2024 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nobstacles = set()\nfor y, line in enumerate(load(6)):\n    for x, char in enumerate(line.strip()):\n        if char == \"^\":\n            position = x + 1j * y\n        if char == \"#\":\n            obstacles.add(x + 1j * y)\nymax, xmax = y, x\n\n\ndef is_valid(position):\n    x, y = position.real, position.imag\n    return 0 &lt; y &lt; ymax and 0 &lt; x &lt; xmax\n\ndirection = -1j\npath = [(position, direction)]\nwhile is_valid(position):\n    while position + direction in obstacles:\n        direction *= 1j\n    position += direction\n    path.append((position, direction))\nlen(set(x[0] for x in path))"
  },
  {
    "objectID": "qmd/2024.html#part-2-5",
    "href": "qmd/2024.html#part-2-5",
    "title": "2024 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part two, we should realise that only obstacles placed on the path have any chance of affecting what the guard does, so the relevant search space is significantly smaller than “every vacant square on the board”. There’s also no need to start the guard from the initial position for every new obstacle; we can just start her on the path right in front of the new obstacle. Similarly, if she ever gets back on her original path before the obstacle, we know she must be in a loop, so we can start with a visited set that covers the whole pwth right up to the new obstruction.\n\n\nCode\nattempted_positions = set([path[0][0]])\ntotal = 0\nfor idx in range(1, len(path)):\n    obstacle, _ = path[idx]\n    if obstacle in attempted_positions:\n        continue\n    position, direction = path[idx - 1]\n\n    obstacles.add(obstacle)\n    seen = set(path[:idx - 1])\n    while is_valid(position):\n        seen.add((position, direction))\n        while position + direction in obstacles:\n            direction *= 1j\n        while is_valid(position) and position + direction not in obstacles:\n            position += direction\n        if (position, direction) in seen:\n            total += 1\n            break\n    attempted_positions.add(obstacle)\n    obstacles.remove(obstacle)\ntotal"
  },
  {
    "objectID": "qmd/2024.html#part-1-6",
    "href": "qmd/2024.html#part-1-6",
    "title": "2024 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(7)\ndata = [\n    [int((parts := line.split(\":\"))[0]), [int(i) for i in parts[1].split()]]\n    for line in data\n]\noperators = [operator.mul, operator.add]\n\n\ndef possible_values(operands, current=None, ops=operators):\n    if current is None:\n        current = operands[0]\n        operands = operands[1:]\n    if not operands:\n        yield current\n    else:\n        for op in ops:\n            yield from possible_values(operands[1:], op(current, operands[0]), ops)\n\n\nsum(\n    result\n    for result, operands in data\n    if any(value == result for value in possible_values(operands))\n)"
  },
  {
    "objectID": "qmd/2024.html#part-2-6",
    "href": "qmd/2024.html#part-2-6",
    "title": "2024 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThis is horribly slow, but has the advantage of being an incredibly fast modification of part 1. A bit of thought shows that backtracking would make things run much faster, since it would let us prune the state space much faster, so that’s one easy option for speeding things up.\n\n\nCode\ndef concat(x, y):\n    return int(str(x) + str(y))\nops = [operator.mul, operator.add, concat]\nsum(\n    result\n    for result, operands in data\n    if any(value == result for value in possible_values(operands, ops=ops))\n)"
  },
  {
    "objectID": "qmd/2024.html#part-1-7",
    "href": "qmd/2024.html#part-1-7",
    "title": "2024 Solutions",
    "section": "Part 1",
    "text": "Part 1\nNothing too complicated going on here. For every symbol on the map that’s not a ., we find all its locations, and then we use itertools.combinations to loop over all pairs of symbols.\n\n\nCode\ndata = load(8, \"chararray\")\nresult = set()\nfor value in np.unique(data):\n    if value == \".\":\n        continue\n    points = np.array(np.where(data == value)).T\n    for p1, p2 in itertools.combinations(points, 2):\n        result.add(tuple(2 * p1 - p2))\n        result.add(tuple(2 * p2 - p1))\nsum(1 for x in result if 0 &lt;= x[0] &lt; data.shape[0] and 0 &lt;= x[1] &lt; data.shape[1])"
  },
  {
    "objectID": "qmd/2024.html#part-2-7",
    "href": "qmd/2024.html#part-2-7",
    "title": "2024 Solutions",
    "section": "Part 2",
    "text": "Part 2\nIn python, the int function automatically rounds towards zero, so we can explicitly work out the number of steps we can take in the x and y directions before going off the map.\n\n\nCode\nresult = set()\nfor value in np.unique(data):\n    if value == \".\":\n        continue\n    points = np.array(np.where(data == value)).T\n    for p1, p2 in itertools.combinations(points, 2):\n        dx = (p2 - p1)[1]\n        dy = (p2 - p1)[0]\n        Δ = np.array([dy, dx])\n        ymin, ymax = -np.inf, np.inf\n        xmin, xmax = -np.inf, np.inf\n        if dy != 0:\n            ymin, ymax = sorted([int((y - p1[0]) / dy) for y in [0, data.shape[0] - 1]])\n        if dx != 0:\n            xmin, xmax = sorted([int((x - p1[1]) / dx) for x in [0, data.shape[1] - 1]])\n        minval = max(ymin, xmin)\n        maxval = min(ymax, xmax)\n        points = [tuple(p1 + k * Δ) for k in range(minval, maxval + 1)]\n        result |= set(points)\nlen(result)"
  },
  {
    "objectID": "qmd/2024.html#part-1-8",
    "href": "qmd/2024.html#part-1-8",
    "title": "2024 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = np.array([[int(char) for char in line] for line in load(10)])\n\n\ndef neighbors(y, x):\n    result = []\n    val = data[y, x]\n    for dy, dx in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n        new_y, new_x = y + dy, x + dx\n        if (\n            0 &lt;= new_y &lt; data.shape[0]\n            and 0 &lt;= new_x &lt; data.shape[1]\n            and data[new_y, new_x] == val + 1\n        ):\n            result.append((new_y, new_x))\n    return result\n\n\n@functools.cache\ndef p1(y, x):\n    r = set()\n    if data[y, x] == 9:\n        return set([(y, x)])\n    return r.union(*[p1(*neighbor) for neighbor in neighbors(y, x)])\n\n\nstarts = np.array(np.where(data == 0)).T\nsum(len(p1(y, x)) for y, x in starts)"
  },
  {
    "objectID": "qmd/2024.html#part-2-8",
    "href": "qmd/2024.html#part-2-8",
    "title": "2024 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\n@functools.cache\ndef p2(y, x):\n    if data[y, x] == 9:\n        return 1\n    return sum(p2(*neighbor) for neighbor in neighbors(y, x))\n\n\nsum(p2(y, x) for y, x in starts)"
  },
  {
    "objectID": "qmd/2015.html",
    "href": "qmd/2015.html",
    "title": "2015 Solutions",
    "section": "",
    "text": "Code\nimport functools\nimport itertools\nimport os\nimport re\nimport sys\nfrom collections import defaultdict\nfrom queue import PriorityQueue\n\nimport more_itertools\nimport numpy as np\nimport pandas as pd\nimport scipy\n\nsys.path.insert(1, os.path.join(sys.path[0], \"..\"))\nimport utils\n\nload = utils.year_load(2015)"
  },
  {
    "objectID": "qmd/2015.html#part-1",
    "href": "qmd/2015.html#part-1",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nline = load(1)[0]\nline.count(\"(\") - line.count(\")\")"
  },
  {
    "objectID": "qmd/2015.html#part-2",
    "href": "qmd/2015.html#part-2",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nposition = 0\nfor idx, character in enumerate(line):\n    position = position + (1 if character == \"(\" else -1)\n    if position &lt; 0:\n        break\nidx + 1"
  },
  {
    "objectID": "qmd/2015.html#part-1-1",
    "href": "qmd/2015.html#part-1-1",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(2)\nboxes = [[int(x) for x in line.split('x')] for line in data]\nsum([(3*x*y + 2*x*z + 2*y*z) for x,y,z in map(sorted, boxes)])"
  },
  {
    "objectID": "qmd/2015.html#part-2-1",
    "href": "qmd/2015.html#part-2-1",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsum([ x * y * z + 2 * (x + y) for x,y,z in map(sorted, boxes)])"
  },
  {
    "objectID": "qmd/2015.html#part-1-2",
    "href": "qmd/2015.html#part-1-2",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ninstructions = load(3)[0]\ncommands = {\"^\": lambda x, y: (x, y + 1), \"v\": lambda x, y: (x, y - 1),\n            \"&gt;\": lambda x, y: (x + 1, y), \"&lt;\": lambda x, y: (x - 1, y),}\n\ndef execute_instructions(instructions, houses=None):\n    position = 0, 0\n    if houses is None:\n        houses = {(0, 0): 1}\n    for instruction in instructions:\n        position = commands[instruction](*position)\n        houses[position] = 1\n    return houses\n\nlen(execute_instructions(instructions))"
  },
  {
    "objectID": "qmd/2015.html#part-2-2",
    "href": "qmd/2015.html#part-2-2",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nhouses = execute_instructions(instructions[::2])\nlen(execute_instructions(instructions[1::2], houses))"
  },
  {
    "objectID": "qmd/2015.html#part-1-3",
    "href": "qmd/2015.html#part-1-3",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nimport hashlib\nh = hashlib.md5()\nprefix = \"iwrupvqb\"\ndef brute_force(n):\n    i = 0\n    while i := i + 1:\n        md5 = hashlib.md5((prefix + str(i)).encode(encoding=\"UTF-8\")).hexdigest()\n        if md5[:n] == n * \"0\":\n            return i\nbrute_force(5)"
  },
  {
    "objectID": "qmd/2015.html#part-2-3",
    "href": "qmd/2015.html#part-2-3",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nbrute_force(6)"
  },
  {
    "objectID": "qmd/2015.html#part-1-4",
    "href": "qmd/2015.html#part-1-4",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndef is_nice(s):\n    sufficient_vowels = len(re.findall(\"[aeiou]\", s)) &gt;= 3\n    contains_double = (np.array(list(s))[1:] == np.roll(list(s), 1)[1:]).any()\n    contains_forbidden = any(val in s for val in [\"ab\", \"cd\", \"pq\", \"xy\"])\n    return sufficient_vowels and contains_double and not contains_forbidden\nsum(is_nice(x) for x in load(5))"
  },
  {
    "objectID": "qmd/2015.html#part-2-4",
    "href": "qmd/2015.html#part-2-4",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef is_nice(s):\n    contains_double = (np.array(list(s))[2:] == np.roll(list(s), 2)[2:]).any()\n    contains_double_pair = bool(re.findall(\"(..).*\\\\1\", s))\n    return contains_double and contains_double_pair\nsum(is_nice(x) for x in load(5))"
  },
  {
    "objectID": "qmd/2015.html#part-1-5",
    "href": "qmd/2015.html#part-1-5",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nlines = load(6)\nnumbers = [[int(x) for x in re.findall(\"\\d+\", line)] for line in lines]\ninstructions = [line.replace(\"turn \", \"\").split()[0] for line in lines]\nfield = np.zeros([1000, 1000], dtype=int)\nfor (x1, y1, x2, y2), instruction in zip(numbers, instructions):\n    if instruction == \"toggle\":\n        field[x1:x2 + 1, y1:y2 + 1] ^= 1\n    else:\n        field[x1:x2 + 1, y1:y2 + 1] = int(instruction == \"on\")\nfield.sum()"
  },
  {
    "objectID": "qmd/2015.html#part-2-5",
    "href": "qmd/2015.html#part-2-5",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nfield = np.zeros([1000, 1000], dtype=int)\nfor (x1, y1, x2, y2), instruction in zip(numbers, instructions):\n    if instruction == \"toggle\":\n        field[x1:x2 + 1, y1:y2 + 1] += 2\n    else:\n        field[x1:x2 + 1, y1:y2 + 1] += 2 * int(instruction == \"on\") - 1\n    field[np.where(field &lt; 0)] = 0\nfield.sum()"
  },
  {
    "objectID": "qmd/2015.html#part-1-6",
    "href": "qmd/2015.html#part-1-6",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ncircuit = {target: source for source, target in map(lambda x: x.split(\" -&gt; \"), load(7))}\nbinops = {\"AND\": lambda x, y: x & y,\n          \"OR\": lambda x, y: x | y,\n          \"LSHIFT\": lambda x, y: x &lt;&lt; y,\n          \"RSHIFT\": lambda x, y: x &gt;&gt; y}\n\n@functools.cache\ndef evaluate(symbol):\n    try:\n        result = int(symbol)\n        return result\n    except ValueError:\n        pass\n    operation = circuit[symbol].split()\n    if len(operation) == 1:\n        return evaluate(operation[0])\n    elif len(operation) == 2:\n        return evaluate(operation[1]) ^ (2**16 - 1)\n    else:\n        arg1, op, arg2 = operation\n        return binops[op](evaluate(arg1), evaluate(arg2))\nevaluate(\"a\")"
  },
  {
    "objectID": "qmd/2015.html#part-2-6",
    "href": "qmd/2015.html#part-2-6",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWe can reset everything by clearing out the cache, and setting a wire to a specific value (or expression) can be accomplished by modifying the circuit.\nThat gives\n\n\nCode\nevaluate.cache_clear()\ncircuit[\"b\"] = str(evaluate(\"a\"))\nevaluate(\"a\")"
  },
  {
    "objectID": "qmd/2015.html#part-1-7",
    "href": "qmd/2015.html#part-1-7",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nlines = [x[:-1] for x load(8)]\nsum(len(line) - len(eval(line)) for line in lines)"
  },
  {
    "objectID": "qmd/2015.html#part-2-7",
    "href": "qmd/2015.html#part-2-7",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsum(2 + len([x for x in line if x in [\"\\\"\", \"\\\\\"]]) for line in lines)"
  },
  {
    "objectID": "qmd/2015.html#part-1-8",
    "href": "qmd/2015.html#part-1-8",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nd = {}\ndata = [x.split() for x in load(9)]\nfor source, _, destination, __, distance in data:\n    d[(source, destination)] = int(distance)\n    d[(destination, source)] = int(distance)\ncities = set(x[0] for x in d.keys())\ntours = [sum(d[route[start], route[start + 1]] for start in range(len(cities) - 1))\n         for route in itertools.permutations(cities)]\nmin(tours)"
  },
  {
    "objectID": "qmd/2015.html#part-2-8",
    "href": "qmd/2015.html#part-2-8",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nmax(tours)"
  },
  {
    "objectID": "qmd/2015.html#part-1-9",
    "href": "qmd/2015.html#part-1-9",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nmessage = \"3113322113\"\nregex = re.compile(r\"(([123])\\2*)\")\nfor _ in range(40):\n    runs = re.findall(regex, message)\n    message = ''.join([str(len(run)) + run[0] for run in map(lambda x: x[0], runs)])\nlen(message)"
  },
  {
    "objectID": "qmd/2015.html#part-2-9",
    "href": "qmd/2015.html#part-2-9",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nfor _ in range(10):\n    runs = re.findall(regex, message)\n    message = ''.join([str(len(run)) + run[0] for run in map(lambda x: x[0], runs)])\nlen(message)"
  },
  {
    "objectID": "qmd/2015.html#part-1-10",
    "href": "qmd/2015.html#part-1-10",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\nSo there are two jobs here:\n\nDetermine whether a candidate password is valid\nIterate over candidate passwords in order, starting with the puzzle input\n\nIs valid is not too difficult to accomplish. The “straight” condition can be rewritten as “1, 1” appears somewhere in the list of differences between neighboring characters. The “double pair” condition can be shortly expressed as matching a simple regex. Forbidding certain characters outright is most easily accomplished by never generating them as candidates\nTo iterate over candidate passwords, we first construct a helper method to iterate over candidate passwords that keep some prefix string fixed. The full iterator is then a chain over all these with successively shorter prefix strings.\n\n\nCode\ndef has_straight(password):\n    if isinstance(password, str):\n        password = np.array([ord(x) for x in password], dtype=int)\n    differences = np.diff(password)\n    return (1, 1) in zip(differences, differences[1:])\n\n\nr = re.compile(r\"(.)\\1.*(.)\\2\")\n\n\ndef has_double_pair(password):\n    return bool(re.search(r, \"\".join(chr(x) for x in password)))\n\n\ndef is_valid_password(password):\n    return has_double_pair(password) and has_straight(password)\n\n\npuzzle_input = tuple(ord(x) for x in \"hxbxwxba\")\npassword = puzzle_input\ncharacters = tuple(ord(x) for x in \"abcdefghjkmnpqrstuvwxyz\")\n\n\ndef iterate(string, prefix_length):\n    n_free = len(string) - prefix_length - 1\n    first = characters[characters.index(string[prefix_length]) + 1 :]\n\n    suffixes = itertools.product(first, *([characters] * n_free))\n    for suffix in suffixes:\n        yield string[:prefix_length] + suffix\n\n\npassword_iterator = itertools.chain.from_iterable(\n    [iterate(password, l) for l in range(len(password))][::-1]\n)\nwhile not is_valid_password(password):\n    password = next(password_iterator)\nprint(\"\".join(chr(x) for x in password))"
  },
  {
    "objectID": "qmd/2015.html#part-2-10",
    "href": "qmd/2015.html#part-2-10",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\npassword = next(password_iterator)\nwhile not is_valid_password(password):\n    password = next(password_iterator)\nprint(\"\".join(chr(x) for x in password))"
  },
  {
    "objectID": "qmd/2015.html#part-1-11",
    "href": "qmd/2015.html#part-1-11",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\nFor the first part, we’ve been promised that integers only appear as integers. So there’s no reason to try and read in the json properly - a simple regex does the trick\n\n\nCode\ns = load(12, \"int\")\nsum([n for line in s for n in line])"
  },
  {
    "objectID": "qmd/2015.html#part-2-11",
    "href": "qmd/2015.html#part-2-11",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThat approach obviously doesn’t work for the second part, so we’ll need a json library\n\n\nCode\nimport json\ns = json.loads(load(12, \"raw\"))\ndef find_value(structure):\n    if isinstance(structure, str):\n        return 0\n    if isinstance(structure, int):\n        return structure\n    if isinstance(structure, list):\n        return(sum(find_value(x) for x in structure))\n    if \"red\" in structure.values():\n        return 0\n    return sum(find_value(x) for x in structure.values())\nfind_value(s)"
  },
  {
    "objectID": "qmd/2015.html#part-1-12",
    "href": "qmd/2015.html#part-1-12",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(13)\n\n\ndef parse(line):\n    words = line.split()\n    people = tuple(sorted([words[0], words[-1][:-1]]))\n    amount = int(re.search(\"(\\d+)\", line).groups(0)[0])\n    sign = 2 * (\"gain\" in words) - 1\n    return people, amount * sign\n\n\nscores = defaultdict(int)\nfor line in load(13):\n    people, score = parse(line)\n    scores[people] += score\n\npeople = sorted(set([person for pair in scores.keys() for person in pair]))\n\n\ndef calculate_score(permutation):\n    score = 0\n    n = len(permutation)\n    for i in range(n):\n        score += scores[tuple(sorted([permutation[i], permutation[(i + 1) % n]]))]\n    return score\n\n\nmaxval = 0\nfor permutation in itertools.permutations(people[1:]):\n    score = calculate_score((people[0],) + permutation)\n    if score &gt; maxval:\n        maxval = score\nmaxval"
  },
  {
    "objectID": "qmd/2015.html#part-2-12",
    "href": "qmd/2015.html#part-2-12",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\nHere we see the magic of the defaultdict - since all of the pairs involving “You” have a net score of zero, we don’t need to change the scoring dictionary at all. We just add “You” to the people we are permuting over, and run everything exactly as before.\n\n\nCode\nmaxval = 0\nfor permutation in itertools.permutations(people[1:] + [\"You\"]):\n    score = calculate_score((people[0],) + permutation)\n    if score &gt; maxval:\n        maxval = score\nmaxval"
  },
  {
    "objectID": "qmd/2015.html#part-1-13",
    "href": "qmd/2015.html#part-1-13",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nreindeer = load(14, \"int\")\ndef score(time, speed, on, off):\n    cycle_length = on + off\n    n_cycles = time // (cycle_length)\n    offset = min(on, n_cycles % cycle_length)\n    return speed * (n_cycles * on + offset)\nmax(map(lambda x: score(2503, *x), reindeer))"
  },
  {
    "objectID": "qmd/2015.html#part-2-13",
    "href": "qmd/2015.html#part-2-13",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nwins = np.zeros(len(numbers))\npositions = np.zeros(len(numbers))\nfor i in range(2503):\n    for idx, (speed, on, off) in enumerate(reindeer):\n        cycle_length = on + off\n        if i % cycle_length &lt; on:\n            positions[idx] += speed\n    wins += (positions == max(positions))\nmax(wins)"
  },
  {
    "objectID": "qmd/2015.html#part-1-14",
    "href": "qmd/2015.html#part-1-14",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\nSince each of the values has to be positive, we can derive some constraints on how much of each ingredient we can use. We know there are 100 of each in total, so letting the four variables be \\(w, x, y, z\\), we have \\(w + x + y + z = 100\\). Additionally, since only one ingredient contributes a positive value to any given quantitity we have to use at least one of each. With that out of the way we can use the matrix to set up the following system of inequalities:\n\\[\\begin{align*}\n3w - 3x - y &&gt; 0 \\\\\n4y - 3z &&gt; 0 \\\\\n-3w + 2z &&gt; 0\n\\end{align*}\\]\nFrom that we can derive the following bounds for the amount of each ingredient\n\\[\\begin{align*}\n1 &\\leq w\\leq 39\\\\\n1 &\\leq x\\leq 39\\\\\n1 &\\leq y\\leq 72\\\\\n1 &\\leq z\\leq 65\n\\end{align*}\\]\nFor example, the upper bound on \\(w\\) follows from the last inequality, which implies that \\(z &gt; 1.5 w\\). The one on \\(x\\) comes from the first inequality, which implies that \\(x &lt; w\\).\nThe last thing to consider is that once three of the values are fixed, the fourth is known. Together, these optimizations let us reduce the cases we have to consider from 1 million to less than 50k.\n\n\nCode\ndata = np.array(load(15, \"int\")).T\ninitial_bounds = [[1, 39 + 1], [1, 39 + 1], [1, 72 + 1], [1, 65 + 1]]\ndef calculate(part=1):\n    maxval = 0\n    for w in range(*initial_bounds[0]):\n        for x in range(1, w):\n            left, right = initial_bounds[2]\n            new_y = 3 * (w - x)\n            for y in range(left, min(right, new_y)):\n                z = 100 - x - y - w\n                score = (data @ (w, x, y, z))\n                if (score &lt;= 0).any() or (part == 2 and (score[-1] != 500)):\n                    continue\n                val = np.product(score[:-1])\n                if val &gt; maxval:\n                    maxval = val\n    return maxval\ncalculate()"
  },
  {
    "objectID": "qmd/2015.html#part-2-14",
    "href": "qmd/2015.html#part-2-14",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ncalculate(2)"
  },
  {
    "objectID": "qmd/2015.html#part-1-15",
    "href": "qmd/2015.html#part-1-15",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(16)\nsues = {}\nfor line in data:\n    sep = line.index(\":\")\n    sue, info = line[:sep], line[sep + 1 :]\n    sues[int(sue.split()[1])] = {\n        k: int(v) for k, v in map(lambda x: x.split(\": \"), info.split(\", \"))\n    }\nmatch = {\n    \"children\": 3,\n    \"cats\": 7,\n    \"samoyeds\": 2,\n    \"pomeranians\": 3,\n    \"akitas\": 0,\n    \"vizslas\": 0,\n    \"goldfish\": 5,\n    \"trees\": 3,\n    \"cars\": 2,\n    \"perfumes\": 1,\n}\nfor sue in sues:\n    comparison = sues[sue]\n    for key in match:\n        if key not in comparison:\n            continue\n        if match[key] != comparison[key]:\n            break\n    else:\n        print(sue)\n        break"
  },
  {
    "objectID": "qmd/2015.html#part-2-15",
    "href": "qmd/2015.html#part-2-15",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nfor sue in sues:\n    comparison = sues[sue]\n    for key in match:\n        if key not in comparison:\n            continue\n        f = lambda known, measured: known == measured\n        if key in [\"cats\", \"trees\"]:\n            f = lambda known, measured: measured &gt; known\n        elif key in [\"pomeranians\", \"goldfish\"]:\n            f = lambda known, measured: measured &lt; known\n        if not f(match[key], comparison[key]):\n            break\n    else:\n        print(sue)\n        break"
  },
  {
    "objectID": "qmd/2015.html#part-1-16",
    "href": "qmd/2015.html#part-1-16",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndef count(value, containers):\n    if value == 0:\n        return 1\n    if value &lt; 0 or len(containers) == 0:\n        return 0\n    return count(value - containers[0], containers[1:]) + count(value, containers[1:])\n\n\ncount(150, load(17, \"np\"))"
  },
  {
    "objectID": "qmd/2015.html#part-2-16",
    "href": "qmd/2015.html#part-2-16",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef count(value, containers):\n    result = defaultdict(int)\n    def inner(value, containers, depth):\n        if value == 0:\n            result[depth] += 1\n            return\n        if value &lt; 0 or len(containers) == 0:\n            return\n        inner(value - containers[0], containers[1:], depth + 1)\n        inner(value, containers[1:], depth)\n    inner(value, containers, 0)\n    return result\nresult = count(150, load(17, \"np\"))\nresult[min(result.keys())]"
  },
  {
    "objectID": "qmd/2015.html#part-1-17",
    "href": "qmd/2015.html#part-1-17",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nweights = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\ninitial_board = np.array(\n    [[0 if char == \".\" else 1 for char in line] for line in load(18)]\n)\nboard = initial_board.copy()\nfor i in range(100):\n    mask = scipy.ndimage.convolve(board, weights, mode=\"constant\")\n    board = ((mask == 3) | ((mask - board) == 3)).astype(int)\nboard.sum()"
  },
  {
    "objectID": "qmd/2015.html#part-2-17",
    "href": "qmd/2015.html#part-2-17",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef fix_corners(board):\n    board = np.roll(board, 1, axis=[0,1])\n    board[:2, :2] = 1\n    return np.roll(board, -1, axis=[0,1])\n\nboard = fix_corners(initial_board)\nfor i in range(100):\n    mask = scipy.ndimage.convolve(board, weights, mode='constant')\n    board = fix_corners(((mask == 3) | ((mask - board) == 3)).astype(int))\nboard.sum()"
  },
  {
    "objectID": "qmd/2015.html#part-1-18",
    "href": "qmd/2015.html#part-1-18",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(19)\ntransitions, initial_string = data[:-2], data[-1]\ntransitions = [x.split(\" =&gt; \") for x in transitions]\ntransformations = defaultdict(list)\nfor source, dest in transitions:\n    transformations[source].append(dest)\nelement_regex = \"[A-Z][a-z]?\"\nelements = re.findall(element_regex, initial_string)\nresult = set()\nfor idx, element in enumerate(elements):\n    prefix = ''.join(elements[:idx])\n    suffix = ''.join(elements[idx+1:])\n    for transformation in transformations[element]:\n        result.add(prefix + transformation + suffix)\nlen(result)"
  },
  {
    "objectID": "qmd/2015.html#part-2-18",
    "href": "qmd/2015.html#part-2-18",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\nInstead of trying to make the final string starting from “e” and using the given transformations, we can equivalently try to reduce the final string to “e” using the reverse transformations - that should be the same thing.\nIf we’re naive about this, it’s going to take a very long time. One thing to notice is that “Ca” only appears on the right hand side of our transformation rules as “X =&gt; XCa” or “X =&gt; CaX”. So generating one unit of “Ca” always takes one step, and we can pretend there’s a rule of the form “’∅ =&gt; Ca”.\nThat still leaves us with more than 100k candidates for shortening after only 4 reverse substitutions, which is less than ideal. Luckily, there’s a pen and paper solution!\nLooking further at the list of reactions given, all the ones that don’t produce Rn are of the form “A =&gt; BC”, and thus always take exactly one step to increase the length of the molecule by one.\nThe only remaining question is how efficiently we can use the Rn we have available. Now, some of the “Rn” reactions give a “C” to start with, but “C” is not the source of any reaction and it’s not present in our string, so we can completely ignore these. Looking at the remainder, all the reactions convert one element into four, apart from “H =&gt; NRnFYFAr” and “Ca =&gt; SiRnFYFAr”, which convert one to six. There are only 6 Ys in the initial string, so these reactions have to run exactly six times, and the others run 30 times (There are 36 Rns in my input)\nThere are 292 elements in the initial string. After getting rid of Rns I have 292 - 5 * 6 - 3 * 30 = 172 elements left, and have spent 36 reactions. Getting to one electron requires a further 171 reactions for a total of 207."
  },
  {
    "objectID": "qmd/2015.html#part-1-19",
    "href": "qmd/2015.html#part-1-19",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\nWe’re looking for numbers that have lots of divisors compared to how big they are. A bit of ass-pulling lets me guess that they have to be divisible by 60.\n\n\nCode\ntarget = 33100000\ndef sum_of_factors(n, part=1):\n    result = 0\n    for i in range(1, int(np.sqrt(n)) + 1):\n        if n % i == 0:\n            if part == 1:\n                result += i + int(n // i)\n            else:\n                div = n // i\n                result += (i if div &lt;= 50 else 0) + (div if i &lt;= 50 else 0)\n    return result\n\ndef run(target, part=1):\n    i, total = 0, 0\n    while total &lt; target:\n        i += 60\n        total = sum_of_factors(i, part)\n    return i\nrun(target / 10)"
  },
  {
    "objectID": "qmd/2015.html#part-2-19",
    "href": "qmd/2015.html#part-2-19",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe only things that change for part 2 are the target, and the calculation of the sum of factors. That’s most easily done by passing a “part” flag to the sum of factors function, and a “target” parameter to run. Of course, that makes the following look fairly boring:\n\n\nCode\nrun(target / 11, 2)"
  },
  {
    "objectID": "qmd/2015.html#part-1-20",
    "href": "qmd/2015.html#part-1-20",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = {k: int(v) for k, v in map(lambda x: x.split(\":\"), load(20))}\nturns = [(armor, np.ceil(100 / (data[\"Damage\"] - armor)) - 1) for armor in range(8)]\nattack_needed = [\n    np.ceil(data[\"Hit Points\"] / (x[1] + 1)) + data[\"Armor\"] for x in turns\n]\n\nequipment = load(\"20_auxiliary\", \"int\")\nequipment = equipment[:10] + [x[1:] for x in equipment[10:]]\nweapons = equipment[:5]\narmor = equipment[5:10]\nrings = equipment[10:]\n\n# Use itertools to select one weapon, at most one armor and at most two rings\noptions = itertools.product(\n    weapons,\n    itertools.chain([[0, 0, 0]], armor),\n    itertools.chain([[0, 0, 0]], rings, itertools.combinations(rings, 2)),\n)\n\n# The two ring case has to be flattened\noptions = [\n    list(option[:-1]) + list(option[-1]) if isinstance(option[-1], tuple) else option\n    for option in options\n]\n\n# Then we have regular data and can just convert to a numpy array and sum\nsums = [np.array(option, dtype=int).sum(axis=0) for option in options]\n\n# We need the smallest gold value that has enough (damage, armor)\nmin(s[0] for s in sums if s[1] &gt;= attack_needed[min(s[2], 7)])"
  },
  {
    "objectID": "qmd/2015.html#part-2-20",
    "href": "qmd/2015.html#part-2-20",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWith all that in place, part 2 is just inverting an inequality and changing a min to a max:\n\n\nCode\nmax(s[0] for s in sums if s[1] &lt; attack_needed[min(s[2], 7)])"
  },
  {
    "objectID": "qmd/2015.html#part-1-21",
    "href": "qmd/2015.html#part-1-21",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nimport queue\ndef update_effects(effects):\n    return tuple([max(x - 2, 0) for x in effects])\n\ndef apply_effects(state, part=1):\n    own_hp, boss_hp, mana, shield, poison, recharge = state\n    return (own_hp - (2 if shield else 9) - (1 if part == 2 else 0),\n            boss_hp - (6 if poison else 0),\n            mana + (202 if recharge &gt; 1 else 101 if recharge else 0))\n\ndef neighbors(state, part=1):\n    if state[0] &lt;= 0:\n        return []\n    new_hp, new_boss_hp, new_mana = apply_effects(state, part=part)\n    new_effects = update_effects(state[-3:])\n    neighbors = [(53, (new_hp, new_boss_hp - 4, new_mana - 53) + new_effects),\n                 (73, (new_hp + 2, new_boss_hp - 2, new_mana - 73) + new_effects)]\n    costs = [113, 173, 229]\n    durations = [6, 6, 5]\n    for idx, (cost, duration) in enumerate(zip(costs, durations)):\n        if state[2] &lt; cost or new_effects[idx] != 0:\n            continue\n        new_state = list(state).copy()\n        new_state[idx + 3] = duration\n        new_hp, new_boss_hp, new_mana = apply_effects(new_state, part=part)\n        new_effects = update_effects(new_state[-3:])\n        neighbors.append((cost, (new_hp, new_boss_hp, new_mana - cost) + new_effects))\n    return [neighbor for neighbor in neighbors if neighbor[1][2] &gt;= 0]\ninitial_state = (50, 58, 500, 0, 0, 0)\nq = PriorityQueue()\nq.put((0, initial_state))\n\nwhile q.qsize() &gt; 0:\n    cost, state = q.get()\n    if state[1] &lt;= 0:\n        break\n    for neighbor in neighbors(state):\n        extra_cost, new_state = neighbor\n        q.put((cost + extra_cost, new_state))\ncost"
  },
  {
    "objectID": "qmd/2015.html#part-2-21",
    "href": "qmd/2015.html#part-2-21",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ninitial_state = (49, 58, 500, 0, 0, 0)\nq = PriorityQueue()\nq.put((0, initial_state))\n\nwhile q.qsize() &gt; 0:\n    cost, state = q.get()\n    if state[1] &lt;= 0:\n        break\n    for neighbor in neighbors(state, part=2):\n        extra_cost, new_state = neighbor\n        q.put((cost + extra_cost, new_state))\ncost"
  },
  {
    "objectID": "qmd/2015.html#part-1-22",
    "href": "qmd/2015.html#part-1-22",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\narithmetics = {\n    \"inc\": lambda x: x + 1,\n    \"tpl\": lambda x: x * 3,\n    \"hlf\": lambda x: int(x // 2),\n}\njumps = {\"jmp\": lambda x: True, \"jie\": lambda x: (x % 2) == 0, \"jio\": lambda x: x == 1}\nknown_tokens = list(arithmetics.keys()) + list(jumps.keys()) + [\"a\", \"b\"]\ndata = [line.replace(\",\", \"\").split() for line in load(23)]\ndata = [\n    [token if token in known_tokens else int(token) for token in line] for line in data\n]\n\n\ndef run(program, part=1):\n    ip = 0\n    registers = defaultdict(int)\n    registers[\"a\"] = int(part == 2)\n    while ip &lt; len(program):\n        instruction = program[ip]\n        if instruction[0] in arithmetics:\n            registers[instruction[1]] = arithmetics[instruction[0]](\n                registers[instruction[1]]\n            )\n        else:\n            if jumps[instruction[0]](registers[instruction[1]]):\n                ip += instruction[-1] - 1\n        ip += 1\n    return registers\n\n\nrun(data)[\"b\"]"
  },
  {
    "objectID": "qmd/2015.html#part-2-22",
    "href": "qmd/2015.html#part-2-22",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\nA flag in the “run” function lets us change the relevant register for part 2\n\n\nCode\nrun(data, 2)[\"b\"]"
  },
  {
    "objectID": "qmd/2015.html#part-1-23",
    "href": "qmd/2015.html#part-1-23",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\nHere’s a buggy implementation of part 1. It only looks at the smallest sets that can make the first compartment and completely ignores the others. For the first part that’s semi justifiable, since the amount of small numbers in the input make it very likely that the leftover set can be partitioned into two.\n\n\nCode\ndata = load(24, \"np\")\ndef run(splits = 3):\n    target = data.sum() / splits\n    i = 1\n    while True:\n        for combination in itertools.combinations(data[::-1], i):\n            if sum(combination) == target:\n                break\n        else:\n            i += 1\n            continue\n        break\n    return min(map(lambda x: np.product(x),\n                   filter(lambda x: sum(x) == target,\n                          itertools.combinations(data[::-1], i))))\nrun()"
  },
  {
    "objectID": "qmd/2015.html#part-2-23",
    "href": "qmd/2015.html#part-2-23",
    "title": "2015 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor the second part, the same cheat works, but is less justifiable, since I don’t actually check that the remaining set can be partitioned into three.\n\n\nCode\nrun(4)"
  },
  {
    "objectID": "qmd/2015.html#part-1-24",
    "href": "qmd/2015.html#part-1-24",
    "title": "2015 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndef coordinates_to_n(row, column):\n    n = row + column\n    complete_triangles = (n - 1) * (n - 2) / 2\n    return int(complete_triangles) + column\nrow, column = 3010, 3019\nn = coordinates_to_n(row, column)\ns = 20151125\nfor i in range(n - 1):\n    s = (s * (252533)) % 33554393\ns"
  },
  {
    "objectID": "qmd/2018.html",
    "href": "qmd/2018.html",
    "title": "2018 Solutions",
    "section": "",
    "text": "Code\nimport functools\nimport itertools\nimport os\nimport re\nimport string\nimport sys\nfrom collections import defaultdict, deque\nfrom pathlib import Path\nfrom queue import PriorityQueue\n\nimport more_itertools\nimport numpy as np\nimport pandas as pd\nimport scipy\nfrom IPython.display import HTML\n\nsys.path.insert(1, os.path.join(sys.path[0], \"..\"))\nimport utils\n\nload = utils.year_load(2018)"
  },
  {
    "objectID": "qmd/2018.html#part-1",
    "href": "qmd/2018.html#part-1",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(1, \"np\")\ndata.sum()"
  },
  {
    "objectID": "qmd/2018.html#part-2",
    "href": "qmd/2018.html#part-2",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ni = 0\nvalue = 0\nseen = {}\nwhile True:\n    if value in seen:\n        break\n    seen[value] = 1\n    value += data[i % len(data)]\n    i += 1\nvalue"
  },
  {
    "objectID": "qmd/2018.html#part-1-1",
    "href": "qmd/2018.html#part-1-1",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nlines = [np.array([ord(y) for y in x]) for x in load(2)]\ntwos = sum([2 in np.unique(list(line), return_counts=True)[1] for line in lines])\ntwos * sum([3 in np.unique(list(line), return_counts=True)[1] for line in lines])"
  },
  {
    "objectID": "qmd/2018.html#part-2-1",
    "href": "qmd/2018.html#part-2-1",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\n  for s1 in lines:\n      for s2 in lines:\n          if len(s2) != len(s1): continue\n          if (s2 - s1 != 0).sum() == 1:\n              result = ''.join(chr(x) for x in s1[np.where(s1 == s2)])\n              break\n      else:\n          continue\n      break\nresult"
  },
  {
    "objectID": "qmd/2018.html#part-1-2",
    "href": "qmd/2018.html#part-1-2",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nnum = re.compile(r\"\\d+\")\ndata = np.array([[int(x) for x in re.findall(num, line)] for line in load(3)])\nfield = np.zeros([1000, 1000])\nfor pid, x, y, w, h in data:\n    field[x : x + w, y : y + h] += 1\n(field &gt; 1).sum()"
  },
  {
    "objectID": "qmd/2018.html#part-2-2",
    "href": "qmd/2018.html#part-2-2",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nfor pid, x, y, w, h in data:\n    if (field[x : x + w, y : y + h] == 1).all():\n        break\npid"
  },
  {
    "objectID": "qmd/2018.html#part-1-3",
    "href": "qmd/2018.html#part-1-3",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nfrom time import strptime\n\nevents = [event[1:].split(\"] \") for event in load(4)]\ndate_format = \"%Y-%m-%d %H:%M\"\nevents = sorted(events, key=lambda event: strptime(event[0], date_format))\nguards = {}\nwhile events:\n    event = events.pop(0)\n    if \"Guard\" in event[1]:\n        active_guard = event[1][7:-13]\n        if active_guard not in guards:\n            guards[active_guard] = np.zeros(60)\n        continue\n    end = events.pop(0)\n    guards[active_guard][int(event[0][-2:]) : int(end[0][-2:])] += 1\n\nsleepiest_guard = sorted(guards.keys(), key=lambda x: -guards[x].sum())[0]\nint(sleepiest_guard) * guards[sleepiest_guard].argmax()"
  },
  {
    "objectID": "qmd/2018.html#part-2-3",
    "href": "qmd/2018.html#part-2-3",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsleepiest_guard = sorted(guards.keys(), key=lambda x: -max(guards[x]))[0]\nint(sleepiest_guard) * guards[sleepiest_guard].argmax()"
  },
  {
    "objectID": "qmd/2018.html#part-1-4",
    "href": "qmd/2018.html#part-1-4",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ns = load(5)[0]\n\n\ndef reduce(s):\n    l = len(s)\n    for char in string.ascii_lowercase:\n        s = s.replace(f\"{char + char.swapcase()}\", \"\")\n        s = s.replace(f\"{char.swapcase() + char}\", \"\")\n    return l if l == len(s) else reduce(s)\n\n\nreduce(s)"
  },
  {
    "objectID": "qmd/2018.html#part-2-4",
    "href": "qmd/2018.html#part-2-4",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nmin(reduce(s.replace(c, \"\").replace(c.upper(), \"\")) for c in string.ascii_lowercase)"
  },
  {
    "objectID": "qmd/2018.html#part-1-5",
    "href": "qmd/2018.html#part-1-5",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThe numbers involved are small enough that brute force is a viable approach. It’s ugly, but it works. The question is basically asking for the voronoi diagram of the initial points using the L1 metric, but I’m too slow to see an efficient way of calculating that. The approach would have to be something like determining the boundary line between each pair of points, and then intersecting all of those half planes to get the voronoi cell.\n\n\nCode\ndata = load(6)\ncoordinates = np.array([list(map(int, re.findall(\"\\d+\", line))) for line in data])\nxmax, ymax = coordinates.max(axis=0)\nboard = np.zeros([xmax, ymax], dtype=int)\nfor x, y in itertools.product(range(xmax), range(ymax)):\n    distances = (np.abs(coordinates - np.array([x, y]))).sum(axis=1)\n    values, counts = np.unique(distances, return_counts=True)\n    board[x, y] = distances.argmin() if counts[0] == 1 else -1\ninfinite = functools.reduce(\n    lambda x, y: set(x) | set(y), [board[0], board[:, 0], board[-1], board[:, -1]]\n)\nmax(\n    [\n        (board == seed).sum() if seed not in infinite else 0\n        for seed in range(len(coordinates))\n    ]\n)"
  },
  {
    "objectID": "qmd/2018.html#part-2-5",
    "href": "qmd/2018.html#part-2-5",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nboard = np.zeros([xmax, ymax], dtype=int)\nfor x, y in itertools.product(range(xmax), range(ymax)):\n    board[x, y] = (np.abs(coordinates - np.array([x, y]))).sum()\n\n(board &lt; 10000).sum()"
  },
  {
    "objectID": "qmd/2018.html#bonus",
    "href": "qmd/2018.html#bonus",
    "title": "2018 Solutions",
    "section": "Bonus",
    "text": "Bonus\nI haven’t figured out the cleanest way of solving part 1, but here’s an approach that’s slightly better than brute force. We can basically flood fill the grid, starting with the seed locations given in the input, and then expanding one step at a time. That way we end up considering the effect of at most four (and usually only one or two) seeds on each location, and we avoid having to calculate the distance from the point to every single seed.\n\n\nCode\nimport matplotlib.pyplot as plt\n\nboard = np.zeros([xmax + 1, ymax + 1], dtype=int)\n\n\ndef expand_one(cells, idx, to_paint):\n    new_cells = []\n    for neighbor in get_neighbors(cells):\n        if board[neighbor] == 0:\n            if neighbor in to_paint:\n                del to_paint[neighbor]\n                board[neighbor] = -1\n            else:\n                to_paint[neighbor] = idx + 1\n                new_cells.append(neighbor)\n\n    return new_cells\n\n\ndef get_neighbors(cells):\n    neighbors = []\n    for x, y in cells:\n        candidates = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n        neighbors += [\n            (x, y) for x, y in candidates if (0 &lt;= x &lt;= xmax) and (0 &lt;= y &lt;= ymax)\n        ]\n    return set(neighbors)\n\n\nWe can animate the process of expanding each seed\n\n\nCode\nto_paint = {tuple(x): idx + 1 for idx, x in enumerate(coordinates)}\nsystem = [[x] for x in to_paint.keys()]\nboards = []\nwhile to_paint:\n    for key in to_paint:\n        board[key] = to_paint[key]\n    to_paint = {}\n    for idx, cells in enumerate(system):\n        system[idx] = expand_one(cells, idx, to_paint)\n    image = board.astype(float).copy()\n    image[image == 0] = np.nan\n    boards.append(image)\n\nimport matplotlib.animation as animation\n\ns = 3.0\nfig = plt.figure(figsize=(s, s * ymax / xmax))\nl = len(boards)\ni = 0\nim = plt.imshow(boards[0], animated=True, cmap=\"inferno\")\nplt.xticks([])\nplt.yticks([])\n\n\ndef updatefig(*args):\n    global i\n    if i &lt; len(boards) - 1:\n        i += 1\n    else:\n        i = 0\n    im.set_array(boards[i])\n    return (im,)\n\n\na = animation.FuncAnimation(fig, updatefig, blit=True, frames=len(boards), interval=10)\nplt.close(fig)\nHTML(a.to_jshtml())\n\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\nHow each seed expands to fill its own area"
  },
  {
    "objectID": "qmd/2018.html#part-1-6",
    "href": "qmd/2018.html#part-1-6",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nconstraints = {}\nlines = load(7)\nfor tokens in map(str.split, lines):\n    parent, child = tokens[1], tokens[-3]\n    if parent not in constraints:\n        constraints[parent] = [\"\", \"\"]\n    if child not in constraints:\n        constraints[child] = [\"\", \"\"]\n    constraints[parent][0] += child\n    constraints[child][1] += parent\nexecuted = \"\"\navailable = []\n\n\ndef pop_node(node, ordering):\n    for child in ordering[node][0]:\n        idx = ordering[child][1].index(node)\n        ordering[child] = [\n            ordering[child][0],\n            ordering[child][1][:idx] + ordering[child][1][idx + 1 :],\n        ]\n    del ordering[node]\n\n\npart1 = constraints.copy()\nwhile part1:\n    available = sorted(set(available + [key for key in part1 if not part1[key][1]]))\n    current = available.pop(0)\n    executed += current\n    pop_node(current, part1)\n\nexecuted"
  },
  {
    "objectID": "qmd/2018.html#part-2-6",
    "href": "qmd/2018.html#part-2-6",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nactive = []\nn_workers = 5\npart2 = constraints.copy()\ntime = -1\nwhile part2:\n    new_active = []\n    for key, count in active:\n        if count:\n            new_active += [[key, count - 1]]\n        else:\n            pop_node(key, part2)\n    active = new_active\n    available = sorted(\n        set(key for key in part2 if not part2[key][1]) - set(x[0] for x in active)\n    )\n    while available and len(active) &lt; n_workers:\n        key = available.pop(0)\n        active += [[key, ord(key) - ord(\"A\") + 60]]\n    time += 1\ntime"
  },
  {
    "objectID": "qmd/2018.html#part-1-7",
    "href": "qmd/2018.html#part-1-7",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(8, \"int\")[0]\n\n\ndef parse(tree_list):\n    result = {\"children\": []}\n    n_children, n_metadata = tree_list[:2]\n    tree_list = tree_list[2:]\n    for _ in range(n_children):\n        tree_list, child = parse(tree_list)\n        result[\"children\"] += [child]\n    result[\"metadata\"] = tree_list[:n_metadata]\n    return tree_list[n_metadata:], result\n\n\ndef weigh(tree):\n    if not tree[\"children\"]:\n        return sum(tree[\"metadata\"])\n    return sum(tree[\"metadata\"]) + sum(map(weigh, tree[\"children\"]))\n\n\ntree = parse(data)[1]\nweigh(tree)"
  },
  {
    "objectID": "qmd/2018.html#part-2-7",
    "href": "qmd/2018.html#part-2-7",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef value(node):\n    children = node[\"children\"]\n    if not children:\n        return sum(node[\"metadata\"])\n    return sum(\n        value(children[idx - 1]) for idx in node[\"metadata\"] if idx &lt;= len(children)\n    )\n\n\nvalue(tree)"
  },
  {
    "objectID": "qmd/2018.html#part-1-8",
    "href": "qmd/2018.html#part-1-8",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nn_players = 419\nn_marbles = 72164\n\n\ndef run(n_players, n_marbles):\n    scores = defaultdict(int)\n    circle = deque([0])\n    for marble in range(1, n_marbles + 1):\n        if marble % 23 == 0:\n            circle.rotate(7)\n            scores[marble % n_players] += marble + circle.pop()\n            circle.rotate(-1)\n        else:\n            circle.rotate(-1)\n            circle.append(marble)\n    return max(scores.values())\n\n\nrun(n_players, n_marbles)"
  },
  {
    "objectID": "qmd/2018.html#part-2-8",
    "href": "qmd/2018.html#part-2-8",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nrun(n_players, n_marbles * 100)"
  },
  {
    "objectID": "qmd/2018.html#part-1-9",
    "href": "qmd/2018.html#part-1-9",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\narray = np.array(load(10, \"int\"))\npositions = array[:, :2].copy()\nvelocities = array[:, 2:]\nbounding_box = np.product(positions.max(axis=0) - positions.min(axis=0))\nold_bounding_box = np.inf\nwhile bounding_box &lt; old_bounding_box:\n    positions += velocities\n    old_bounding_box = bounding_box\n    bounding_box = np.product(positions.max(axis=0) - positions.min(axis=0))\npositions -= velocities\nboard = np.zeros(positions.max(axis=0) - positions.min(axis=0) + 1)\nboard[\n    (positions[:, 0] - positions[:, 0].min(), positions[:, 1] - positions[:, 1].min())\n] = 1\nprint(\"\\n\".join([\"\".join(\"█\" if char else \" \" for char in line) for line in board.T]))"
  },
  {
    "objectID": "qmd/2018.html#part-2-9",
    "href": "qmd/2018.html#part-2-9",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nint(((positions[0] - array[0, :2]) / velocities[0])[0])"
  },
  {
    "objectID": "qmd/2018.html#part-1-10",
    "href": "qmd/2018.html#part-1-10",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ns = 8772\nboard = np.zeros((300, 300), dtype=int)\nfor row, col in itertools.product(range(300), range(300)):\n    score = ((row + 1 + 10) * (col + 1) + s) * (row + 1 + 10)\n    board[row, col] = (score // 100) % 10\nboard -= 5\nbest = 0\nfor row, col in itertools.product(range(300 - 2), range(300 - 2)):\n    total = board[row : row + 3, col : col + 3].sum()\n    if total &gt; best:\n        best = total\n        result = row + 1, col + 1\nprint(\",\".join(str(x) for x in result))"
  },
  {
    "objectID": "qmd/2018.html#part-2-10",
    "href": "qmd/2018.html#part-2-10",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nBrute force over all sizes is slow, but works\n\n\nCode\nbest = 0\nfor i in range(3, 301):\n    for row, col in itertools.product(range(301 - i), range(301 - i)):\n        total = board[row : row + i, col : col + i].sum()\n        if total &gt; best:\n            best = total\n            result = row + 1, col + 1, i\nprint(\",\".join(str(x) for x in result))"
  },
  {
    "objectID": "qmd/2018.html#part-1-11",
    "href": "qmd/2018.html#part-1-11",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(12)\nlookup = {\".\": 0, \"#\": 1}\ngenerations = 20\ninitial_state = [lookup[char] for char in data[0] if char in lookup]\nstate = np.pad(initial_state, generations)\nrules = [line.split(\" =&gt; \") for line in data[2:]]\nalive = np.array(\n    [[lookup[x] for x in rule[0]] for rule in rules if lookup[rule[1]] == 1]\n)\n\n\ndef update(cell_neighbors):\n    return 1 * (not abs(np.array(alive) - cell_neighbors).sum(axis=1).min())\n\n\nstates = [state.copy()]\nfor i in range(generations):\n    state = scipy.ndimage.generic_filter(\n        state, update, footprint=np.ones(5), mode=\"constant\"\n    )\n    states.append(state.copy())\nindices = np.arange(state.shape[0]) - generations\n(indices * state).sum()"
  },
  {
    "objectID": "qmd/2018.html#part-2-11",
    "href": "qmd/2018.html#part-2-11",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nSimulating the 50 billion generations is impossible, so something cleverer is needed. My first attempt was to see how the total number of plants changed as the generations progressed, and I noticed that after comparatively gew generations the number was constant. Looking at how the pattern of plants changed after that period made extrapolation to 50 billion generations easy. An off-by-one and an off-by-a-factor-of-ten error later, and the problem was solved.\n\n\nCode\ngenerations = 150\nstate = np.pad(initial_state, generations)\nstates = [state.copy()]\nfor i in range(1, generations):\n    new_state = scipy.ndimage.generic_filter(\n        state, update, footprint=np.ones(5), mode=\"constant\"\n    )\n    states.append(new_state.copy())\n    if (new_state == np.roll(state, 1)).all():\n        break\n    state = new_state\n(\n    ((np.arange(new_state.shape[0]) - generations) + (50_000_000_000 - i)) * new_state\n).sum()"
  },
  {
    "objectID": "qmd/2018.html#part-1-12",
    "href": "qmd/2018.html#part-1-12",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\nMine Cart Madness\n\n\nCode\ncharacters = r\" |-/\\+&gt;&lt;v^\"\ncart_labels = {\"&gt;\": (\"-\", 1), \"&lt;\": (\"-\", -1), \"v\": (\"|\", -1j), \"^\": (\"|\", 1j)}\ngraph = {}\ncarts = []\ncarts_part2 = []\nfor y, line in enumerate(load(13)):\n    for x, char in enumerate(line):\n        position = x - 1j * y\n        if char in cart_labels:\n            char, direction = cart_labels[char]\n            carts.append([position, direction, itertools.cycle([1j, 1, -1j])])\n            carts_part2.append([position, direction, itertools.cycle([1j, 1, -1j])])\n        graph[position] = characters.index(char)\ni = 0\nwhile True:\n    for cart in carts:\n        new_position = cart[0] + cart[1]\n        if new_position in [x[0] for x in carts]:\n            result = int(new_position.real), -int(new_position.imag)\n            break\n        cart[0] = new_position\n        tile = graph[new_position]\n        if tile == 3:\n            cart[1] = cart[1].imag + 1j * cart[1].real\n        elif tile == 4:\n            cart[1] = -(cart[1].imag + 1j * cart[1].real)\n        elif tile == 5:\n            cart[1] = cart[1] * next(cart[2])\n    else:\n        i += 1\n        continue\n    break\nprint(result)"
  },
  {
    "objectID": "qmd/2018.html#part-2-12",
    "href": "qmd/2018.html#part-2-12",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ncarts = carts_part2\ncarts.sort(key=lambda x: (-x[0].imag, x[0].real))\nwhile len(carts) &gt; 1:\n    is_crashed = [False] * len(carts)\n    for idx, cart in enumerate(carts):\n        if is_crashed[idx]:\n            continue\n        new_position = cart[0] + cart[1]\n        crashes = [\n            i\n            for i, cart2 in enumerate(carts)\n            if new_position == cart2[0] and not is_crashed[i]\n        ]\n        for crash in crashes:\n            is_crashed[idx] = True\n            is_crashed[crash] = True\n            continue\n        cart[0] = new_position\n        tile = graph[new_position]\n        if tile == 3:\n            cart[1] = cart[1].imag + 1j * cart[1].real\n        elif tile == 4:\n            cart[1] = -(cart[1].imag + 1j * cart[1].real)\n        elif tile == 5:\n            cart[1] = cart[1] * next(cart[2])\n    carts = [cart for (crash, cart) in zip(is_crashed, carts) if not crash]\n    carts.sort(key=lambda x: (-x[0].imag, x[0].real))\nprint(int(carts[0][0].real), int(-carts[0][0].imag), sep=\",\")"
  },
  {
    "objectID": "qmd/2018.html#part-1-13",
    "href": "qmd/2018.html#part-1-13",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndef solve(n):\n    e1, e2 = 0, 1\n    recipes = [3, 7]\n    while len(recipes) &lt; n + 10:\n        v1, v2 = recipes[e1], recipes[e2]\n        tens, units = divmod(v1 + v2, 10)\n        recipes += [tens, units] if tens else [units]\n        l = len(recipes)\n        e1, e2 = (e1 + v1 + 1) % l, (e2 + v2 + 1) % l\n    # print(recipes)\n    return functools.reduce(lambda x, y: 10 * x + y, recipes[n : n + 10])\n\n\nsolve(157901)"
  },
  {
    "objectID": "qmd/2018.html#part-2-13",
    "href": "qmd/2018.html#part-2-13",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef solve(n):\n    seq = [int(x) for x in str(n)]\n    s = len(seq)\n    e1, e2 = 0, 1\n    recipes = [3, 7]\n    while recipes[-s:] != seq and recipes[-s - 1 : -1] != seq:\n        v1, v2 = recipes[e1], recipes[e2]\n        tens, units = divmod(v1 + v2, 10)\n        recipes += [tens, units] if tens else [units]\n        l = len(recipes)\n        e1, e2 = (e1 + v1 + 1) % l, (e2 + v2 + 1) % l\n    delta = 0 if recipes[-s:] == seq else 1\n    return l - s - delta\n\n\nsolve(\"157901\")"
  },
  {
    "objectID": "qmd/2018.html#part-1-14",
    "href": "qmd/2018.html#part-1-14",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis was a slog. Lots of small pieces to keep track of\n\n\nCode\nclass Unit:\n    def __init__(self, kind, power=3):\n        self.kind = kind\n        self.hit_points = 200\n        self.attack_power = power\n\n    def attack(self, other):\n        other.hit_points -= self.attack_power\n\n    @property\n    def is_dead(self):\n        return self.hit_points &lt;= 0\n\n\nclass Board:\n    def __init__(self, rock, elves, goblins, elf_power=3):\n        self.state = {}\n        self.ymax = max(rock + elves + goblins, key=lambda x: x[0])[0]\n        self.xmax = max(rock + elves + goblins, key=lambda x: x[1])[1]\n        self.board = np.zeros((self.ymax + 1, self.xmax + 1), dtype=np.byte)\n        for coord in rock:\n            self.board[coord] = 1\n        for coord in elves:\n            self.state[coord] = Unit(\"elf\", elf_power)\n            self.board[coord] = 2\n        for coord in goblins:\n            self.state[coord] = Unit(\"goblin\")\n            self.board[coord] = 3\n\n    def __str__(self):\n        char_map = {0: \" \", 1: \"█\", 2: \"E\", 3: \"G\"}\n        return \"\\n\".join(\n            \"\".join(char_map[char] for char in line) for line in self.board\n        )\n\n    def combat(self):\n        n = 0\n        while self.any_alive(\"goblin\") and self.any_alive(\"elf\"):\n            x = self.one_round()\n            n += 1\n        return (n + x), sum(unit.hit_points for unit in self.state.values())\n\n    def any_alive(self, kind):\n        for unit in self.state.values():\n            if unit.kind == kind:\n                return True\n        return False\n\n    def count(self, kind):\n        return sum(x.kind == kind for x in self.state.values())\n\n    def one_round(self):\n        alive_count = {key: self.count(key) for key in [\"elf\", \"goblin\"]}\n        unit_positions = sorted(zip(*np.where(self.board &gt; 1)))\n        for unit_position in unit_positions:\n            if any(x == 0 for x in alive_count.values()):\n                return -1\n            try:\n                unit = self.state[unit_position]\n            except KeyError:  # Unit was killed earlier in the round\n                continue\n            target_position = self.find_target(unit_position)\n            if target_position is None:\n                new_position = self.find_move(unit_position)\n                if new_position is None:\n                    continue\n                self.board[unit_position] = 0\n                del self.state[unit_position]\n\n                self.state[new_position] = unit\n                self.board[new_position] = 2 if unit.kind == \"elf\" else 3\n                target_position = self.find_target(new_position)\n                if target_position is None:\n                    continue\n            target = self.state[target_position]\n            unit.attack(target)\n            if target.is_dead:\n                alive_count[target.kind] -= 1\n                del self.state[target_position]\n                self.board[target_position] = 0\n        return 0\n\n    def find_move(self, position):\n        paths = deque([(0, [], position)])\n        seen = set()\n\n        target_kind = 3 if (self.board[position] == 2) else 2\n        mask = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n        target_mask = scipy.ndimage.convolve(\n            self.board == target_kind, mask, mode=\"constant\"\n        ) & (self.board == 0)\n        targets = sorted(zip(*np.where(target_mask)))\n        candidates = []\n        target_distance = np.inf\n        while paths:\n            distance, first_move, position = paths.popleft()\n            if distance &gt; target_distance:\n                break\n            if position in seen:\n                continue\n            if position in targets:\n                candidates.append((position, first_move))\n                target_distance = distance\n            seen.add(position)\n            y, x = position\n            for neighbor in [(y - 1, x), (y, x - 1), (y, x + 1), (y + 1, x)]:\n                if self.board[neighbor] == 0 and neighbor not in seen:\n                    move = neighbor if not first_move else first_move\n                    paths.append((distance + 1, move, neighbor))\n        if not candidates:\n            return None\n        return sorted(candidates, key=lambda x: x[0])[0][1]\n\n    def find_target(self, position):\n        y, x = position\n        target_kind = 2 + (self.board[position] == 2)\n        targets = []\n        for neighbor in [(y - 1, x), (y, x - 1), (y, x + 1), (y + 1, x)]:\n            if self.board[neighbor] == target_kind:\n                targets.append((self.state[neighbor].hit_points, *neighbor))\n        return sorted(targets)[0][1:] if targets else None\n\n\nlookup = {\".\": 0, \"#\": 1, \"E\": 2, \"G\": 3}\nboard = np.array([[lookup[char] for char in line] for line in load(15)])\ngoblins = sorted(zip(*np.where(board == 3)))\nelves = sorted(zip(*np.where(board == 2)))\nrock = sorted(zip(*np.where(board == 1)))\nboard = Board(rock, elves, goblins)\nnp.product(board.combat())"
  },
  {
    "objectID": "qmd/2018.html#part-2-14",
    "href": "qmd/2018.html#part-2-14",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor the longest time I missed the requirement that when two targets were equally far away, the first one in reading order should be picked, so my units weren’t targetting correctly. Annoyingly, this error didn’t show up in any of the test cases\n\n\nCode\ndef test(power):\n    board = Board(rock, elves, goblins, elf_power=power)\n    while board.any_alive(\"goblin\"):\n        board.one_round()\n        if board.count(\"elf\") != len(elves):\n            return False\n    return True\n\n\nfor power in range(3, 200):\n    if test(power):\n        break\nboard = Board(rock, elves, goblins, power)\nx = board.combat()\nprint(np.product(x))"
  },
  {
    "objectID": "qmd/2018.html#part-1-15",
    "href": "qmd/2018.html#part-1-15",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis is fairly straightforward. We have seven different operations, with two or three different addressing modes for each. We’ll start by building a dictionary of each operation, and then one of the valid addressing modes for each operation. From that, we can get a set of all the valid tuples of (operation, addressing mode 1, addressing mode 2).\nWe can then scan through the header lines of the input, and for each (before, command, after) triple, we can loop over the valid tuples, and check which ones convert before to after.\n\n\nCode\nimport operator\n\nfrom more_itertools import chunked\n\nregisters = [0, 0, 0, 0]\nops = {\n    \"add\": operator.add,\n    \"mul\": operator.mul,\n    \"ban\": operator.iand,\n    \"bor\": operator.ior,\n    \"set\": lambda a, b: a,\n    \"gt\": operator.gt,\n    \"eq\": operator.eq,\n}\n\n# 1 is register, 0 is immediate\nvalid_modes = defaultdict(lambda: [(1, 0), (1, 1)])\nvalid_modes[\"set\"] = [(0, 0), (1, 0)]\nvalid_modes[\"gt\"] = [(0, 1), (1, 0), (1, 1)]\nvalid_modes[\"eq\"] = [(0, 1), (1, 0), (1, 1)]\n\nvalid_ops = {(op,) + mode for op in ops for mode in valid_modes[op]}\n\n\ndef get_operands(modes, operands, registers):\n    result = []\n    for mode, operand in zip(modes, operands):\n        result.append(registers[operand] if mode else operand)\n    return result\n\n\nsplit = 3298\nvalues = load(16, \"int\", footer=split)\ntotal = 0\nfor state, operation, new_state in chunked(values, 3):\n    count = 0\n    operands = operation[1:-1]\n    result = new_state[operation[-1]]\n    for op, *mode in valid_ops:\n        a, b = get_operands(mode, operands, state)\n        if ops[op](a, b) == result:\n            count += 1\n    if count &gt;= 3:\n        total += 1\ntotal"
  },
  {
    "objectID": "qmd/2018.html#part-2-15",
    "href": "qmd/2018.html#part-2-15",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWith that out of the way, we can intersect all the potentially valid assignments for each test case, and use that to figure out which opcode corresponds to what. Running the program after that is fairly straightforward.\n\n\nCode\nop_ids = defaultdict(lambda: valid_ops.copy())\nop_assignments = {}\n\nfor state, operation, new_state in chunked(values, 3):\n    op_number = operation[0]\n    if op_number in op_assignments:\n        continue\n    operands = operation[1:-1]\n    result = new_state[operation[-1]]\n    candidate_ops = set()\n    for op, *modes in valid_ops:\n        a, b = get_operands(modes, operands, state)\n        if ops[op](a, b) == result:\n            candidate_ops.add((op,) + tuple(modes))\n    op_ids[op_number] &= candidate_ops\n    if len(op_ids[op_number]) == 1:\n        assignment = op_ids[op_number].pop()\n        op_assignments[op_number] = assignment\n        for i in range(16):\n            op_ids[i].discard(assignment)\nstate = [0, 0, 0, 0]\nprogram = load(16, \"int\", header=split)\ni = 0\nfor op_id, a, b, c in program:\n    op, *modes = op_assignments[op_id]\n    a, b = get_operands(modes, (a, b), state)\n    state[c] = ops[op](a, b)\nstate[0]"
  },
  {
    "objectID": "qmd/2018.html#part-1-16",
    "href": "qmd/2018.html#part-1-16",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(17, \"int\")\nvariables = [line[0] for line in load(17)]\nxmin = min(line[0] if v == \"x\" else line[1] for v, line in zip(variables, data))\nxmax = max(line[0] if v == \"x\" else line[2] for v, line in zip(variables, data))\nymin = min(line[0] if v == \"y\" else line[1] for v, line in zip(variables, data))\nymax = max(line[0] if v == \"y\" else line[2] for v, line in zip(variables, data))\nr, a, f, s = ord(\"#\"), ord(\".\"), ord(\"|\"), ord(\"~\")\n\nboard = np.zeros((ymax - ymin + 1, xmax - xmin + 3), dtype=int) + a\nfor v, line in zip(variables, data):\n    if v == \"x\":\n        board[line[1] - ymin : line[2] - ymin + 1, line[0] - xmin + 1] = r\n    else:\n        board[line[0] - ymin, line[1] - xmin + 1 : line[2] - xmin + 2] = r\nsource = (-1, 500 - xmin + 1)\ntips = deque([source])\nwhile tips:\n    y, x = tips.popleft()\n    window = board[y + 1 :, x]\n    solid = (window == r) | (window == s)\n    if not solid.any():\n        board[y + 1 :, x] = f\n    else:\n        first_rock = solid.argmax()\n        board[y + 1 : y + 1 + first_rock, x] = f\n        y += first_rock\n        r_platform = ((board[y + 1, x:] != r) & (board[y + 1, x:] != s)).argmax()\n        l_platform = ((board[y + 1, :x] != r) & (board[y + 1, :x] != s))[::-1].argmax()\n        r_wall = mask.argmax() if (mask := (board[y, x:] == r)).any() else np.inf\n        l_wall = mask.argmax() if (mask := (board[y, :x] == r)[::-1]).any() else np.inf\n        fill = s\n        to_add = []\n        if l_wall &gt; l_platform:\n            fill = f\n            to_add += [(y, x - l_platform - 1)]\n            left = x - l_platform - 1\n        else:\n            left = x - l_wall\n        if r_wall &gt; r_platform:\n            fill = f\n            to_add += [(y, x + r_platform)]\n            right = x + r_platform + 1\n        else:\n            right = x + r_wall\n        if fill == s:\n            to_add += [(y - 1, x)]\n        if (board[y, left:right] != fill).any():\n            board[y, left:right] = fill\n            for element in to_add:\n                tips.append(element)\n((board == f) | (board == s)).sum()"
  },
  {
    "objectID": "qmd/2018.html#part-2-16",
    "href": "qmd/2018.html#part-2-16",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThis was a very weird part 2, since I basically solved it already in part 1\n\n\nCode\n(board == s).sum()"
  },
  {
    "objectID": "qmd/2018.html#part-1-17",
    "href": "qmd/2018.html#part-1-17",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nstate_map = {\".\": 0, \"|\": 1, \"#\": 2}\nreverse_map = {v: k for k, v in state_map.items()}\nstate = np.array([[state_map[char] for char in line] for line in load(18)])\nweights = np.ones((3, 3))\nweights[1, 1] = 0\nseen = {}\nfor i in range(10):\n    seen[tuple(state.flatten())] = i\n    tree_nb = scipy.ndimage.convolve(1 * (state == 1), weights, mode=\"constant\")\n    lumber_nb = scipy.ndimage.convolve(1 * (state == 2), weights, mode=\"constant\")\n    change = (\n        ((state == 0) & (tree_nb &gt;= 3))\n        | ((state == 1) & (lumber_nb &gt;= 3))\n        | ((state == 2) & ((tree_nb == 0) | (lumber_nb == 0)))\n    )\n    state = (state + change) % 3\n(state == 1).sum() * (state == 2).sum()"
  },
  {
    "objectID": "qmd/2018.html#part-2-17",
    "href": "qmd/2018.html#part-2-17",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThere’s no way we can run the simulation for that long. Hopefully we’ll get a repeat before then\n\n\nCode\ntarget = 1000000000\nfor i in range(10, target):\n    if tuple(state.flatten()) in seen:\n        start = seen[tuple(state.flatten())]\n        reversed_dict = {v: k for k, v in seen.items()}\n        state = np.array(reversed_dict[start + (target - start) % (i - start)])\n        break\n    seen[tuple(state.flatten())] = i\n    tree_nb = scipy.ndimage.convolve(1 * (state == 1), weights, mode=\"constant\")\n    lumber_nb = scipy.ndimage.convolve(1 * (state == 2), weights, mode=\"constant\")\n    change = (\n        ((state == 0) & (tree_nb &gt;= 3))\n        | ((state == 1) & (lumber_nb &gt;= 3))\n        | ((state == 2) & ((tree_nb == 0) | (lumber_nb == 0)))\n    )\n    state = (state + change) % 3\n(state == 1).sum() * (state == 2).sum()"
  },
  {
    "objectID": "qmd/2018.html#part-1-18",
    "href": "qmd/2018.html#part-1-18",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nbasic_ops = [\"add\", \"mul\", \"ban\", \"bor\"]\nname_to_op = {\n    basic_op + mode: (basic_op, 1, int(mode == \"r\"))\n    for basic_op in basic_ops\n    for mode in \"ir\"\n}\n\nname_to_op.update(**{\"set\" + mode: (\"set\", int(mode == \"r\"), 0) for mode in \"ir\"})\nname_to_op.update(\n    **{\n        comparison\n        + mode_pair: (comparison, int(mode_pair[0] == \"r\"), int(mode_pair[1] == \"r\"))\n        for comparison in [\"gt\", \"eq\"]\n        for mode_pair in [\"ir\", \"ri\", \"rr\"]\n    }\n)\n\n\ndef interpret(op_name):\n    name, *modes = name_to_op[op_name]\n    return [ops[name], modes]\n\n\ndef run(program, registers, ip_register):\n    ip = 0\n    while ip &lt; len(program):\n        registers[ip_register] = ip\n        op, modes, a, b, c = program[ip]\n        a, b = get_operands(modes, (a, b), registers)\n        registers[c] = op(a, b)\n        ip = registers[ip_register] + 1\n    return registers[0]\n\n\ndata = load(19)\nregisters = [0, 0, 0, 0, 0, 0]\nip, program = data[0], data[1:]\nip_register = int(re.findall(r\"-?\\d+\", ip)[0])\nprogram = [x.split() for x in program]\nprogram = [interpret(line[0]) + [int(x) for x in line[1:]] for line in program]\nrun(program, registers, ip_register)"
  },
  {
    "objectID": "qmd/2018.html#part-2-18",
    "href": "qmd/2018.html#part-2-18",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThis is another one of those where changing the value in the first register causes the code to go through a different path in the program, and greatly increases the runtime.\nAnalysing the execution path shows that the code starts off by jumping to a setup section at the end, which has the main effect of placing a value in register 5. It then jumps back to two nested loops, which go through a lot of busywork, and store their results in register 0. Finally, after a long time, it hits the exit condition of both loops, and the program ends.\nLooking at the inner loop, it does the following\nfor x4 in range(1, x5 + 1):\n    if x4 * x2 == x5:\n        x0 += x2\nBut thats equivalent to x0 += x2 if x5 % x2 == 0 else 0. The outer loop just runs over all values of x2 from 1 to x5. So what this code is really doing is calculating the sum of divisors function of whatever horrible mess is placed in x5 by the setup. We’ll get that by running through the code until the setup is over, and then calculate the sum of divisors:\n\n\nCode\ndef sum_of_divisors(n):\n    total = n + 1\n    for i in range(2, n):\n        if n % i == 0:\n            total += i\n    return total\n\n\nregisters = [1, 0, 0, 0, 0, 0]\nip = 0\nwhile ip != 1:\n    registers[ip_register] = ip\n    op, modes, a, b, c = program[ip]\n    a, b = get_operands(modes, (a, b), registers)\n    registers[c] = op(a, b)\n    ip = registers[ip_register] + 1\nsum_of_divisors(registers[5])"
  },
  {
    "objectID": "qmd/2018.html#part-1-19",
    "href": "qmd/2018.html#part-1-19",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThe hard part of this problem is moving from the regex representation of the map to a more sensible one. A pseudo-ebnf of the grammar is:\n\npath = direction, path | bracketed_path, path | options\ndirection = n|e|w|s\nbracketed_path = (, path, )\noptions = (path, |)*, path?\n\nBased on this, we can parse the string from start to finish by tracking a list of current positions. If a direction is encountered, each of the positions is updated. Whenever an opening bracket is encountered, the matching close bracket is found, the subexpression is split into options, and each of those paths is parsed. The visited edges are tracked along the way in a global dictionary. It’s not super elegant, but it works.\n\n\nCode\ns = load(20)[0][1:-1]\ndirections = {\"N\": 1j, \"E\": 1, \"S\": -1j, \"W\": -1}\n\n\ndef find_closing_paren(s):\n    count = 0\n    for idx, char in enumerate(s):\n        count += 1 if char == \"(\" else -1 if char == \")\" else 0\n        if count == 0:\n            return idx\n\n\ndef split_into_options(s):\n    count = 0\n    result = []\n    current = \"\"\n    for char in s:\n        if char == \"|\" and count == 0:\n            result.append(current)\n            current = \"\"\n        else:\n            current += char\n        count += 1 if char == \"(\" else -1 if char == \")\" else 0\n    result.append(current)\n    return result\n\n\nedges = defaultdict(bool)\n\n\ndef endpoints(s, positions=None):\n    i = 0\n    if positions is None:\n        positions = {0}\n    else:\n        positions = positions.copy()\n    while i &lt; len(s):\n        char = s[i]\n        if char == \"(\":\n            delta = find_closing_paren(s[i:])\n            substring = s[i + 1 : i + delta]\n            options = split_into_options(substring)\n            positions = {point for x in options for point in endpoints(x, positions)}\n            i += delta\n        else:\n            direction = directions[char]\n            positions = {x + direction for x in positions}\n            for position in positions:\n                edges[2 * position - direction] = True\n        i += 1\n    return positions\n\n\npoints = endpoints(s)\n\n\ndef edge_to_nodes(x):\n    return (\n        (x.real - x.real % 2 + 1j * (x.imag - x.imag % 2)) / 2,\n        (x.real + x.real % 2 + 1j * (x.imag + x.imag % 2)) / 2,\n    )\n\n\nnodes = len({node for edge in edges.keys() for node in edge_to_nodes(edge)})\n\n\nWith all that out of the way, the furthest room can be found with a BFS:\n\n\nCode\ndef neighbors(state):\n    return [\n        state + direction\n        for direction in directions.values()\n        if edges[2 * state + direction]\n    ]\n\n\nutils.bfs(0, None, neighbors)"
  },
  {
    "objectID": "qmd/2018.html#part-2-19",
    "href": "qmd/2018.html#part-2-19",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nAnd finding how many rooms require at least 1000 steps can be found with the same BFS, but ending whenever we get a cost greater than 1000\n\n\nCode\nend_condition = lambda cost, state: cost &gt;= 1000\nnodes - len(utils.bfs(0, end_condition, neighbors, return_visited=True))"
  },
  {
    "objectID": "qmd/2018.html#part-1-20",
    "href": "qmd/2018.html#part-1-20",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\nAnalysing the structure of the program, we can see that the value of register 0 is only relevant in one place, namely as a comparison towards the end, where the program exits if x0 == x3. So for the first part, we just run the code until we hit that comparison the first time, and see what the value of x3 is; that must be the answer to the problem.\n\n\nCode\ndata = load(21)\nregisters = [0, 0, 0, 0, 0, 0]\nip, program = data[0], data[1:]\nip_register = int(re.findall(r\"-?\\d+\", ip)[0])\nip = 0\nprogram = [x.split() for x in program]\nprogram = [interpret(line[0]) + [int(x) for x in line[1:]] for line in program]\ncount = 0\nwhile True:\n    registers[ip_register] = ip\n    op, modes, a, b, c = program[ip]\n    a, b = get_operands(modes, (a, b), registers)\n    registers[c] = op(a, b)\n    ip = registers[ip_register] + 1\n    if ip == 28:\n        count += 1\n        if count == 2:\n            break\nregisters[3]"
  },
  {
    "objectID": "qmd/2018.html#part-2-20",
    "href": "qmd/2018.html#part-2-20",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, we need to do two things:\n\nAnalyse the provided script so that we can run it in pure python rather than the assembly it’s given in\nThink about why there would even be a largest amount of iterations the code can make and still halt.\n\nFor part 1, it turns out that the code is repeatedly applying a fairly simple transformation to register 3, and then checking that against register 0. The only way that there could be a largest set of iterations is if the code eventualy produces the same value in register 3 as it did some number of iterations ago. The value we’re looking for is then the last value found in register 3 before the repeated value:\n\n\nCode\nx1, x3 = 0, 0\nseen = []\nwhile x3 not in seen:\n    seen.append(x3)\n    x1 = x3 | 65536\n    x3 = 4921097\n    while x1 &gt;= 1:\n        x3 = ((x3 + (x1 % 256)) * 65899) % 16777216\n        x1 = x1 // 256\nseen[-1]"
  },
  {
    "objectID": "qmd/2018.html#part-1-21",
    "href": "qmd/2018.html#part-1-21",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nd = 7863\ntarget_x, target_y = 14, 760\nbase = 20183\n\n\n@functools.cache\ndef geologic_index(x, y):\n    if y == 0:\n        return (x * 16807) % base\n    if x == 0:\n        return (y * 48271) % base\n    return ((geologic_index(x - 1, y) + d) * (geologic_index(x, y - 1) + d)) % base\n\n\n@functools.cache\ndef terrain_type(x, y):\n    if x == target_x and y == target_y:\n        return 0\n    return ((geologic_index(x, y) + d) % base) % 3\n\n\nboard = np.zeros((target_x + 1, target_y + 1), dtype=int)\nfor i in range(target_x + 1):\n    for j in range(target_y + 1):\n        board[i, j] = terrain_type(i, j)\nboard.sum()"
  },
  {
    "objectID": "qmd/2018.html#part-2-21",
    "href": "qmd/2018.html#part-2-21",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThis calls for a path finding algorithm. A* to the rescue! We’ll need functions that\n\nFind the neighboring states of the current state\nFind the cost of getting to each neighbor\nEstimate the cost of getting to the end from any given location\n\n\n\nCode\ndef neighbors(state):\n    x, y, equipment = state\n    candidates = [\n        (x + 1, y, equipment),\n        (x - 1, y, equipment),\n        (x, y - 1, equipment),\n        (x, y + 1, equipment),\n        (x, y, (equipment + 1) % 3),\n        (x, y, (equipment + 2) % 3),\n    ]\n\n    return [\n        candidate\n        for candidate in candidates\n        if candidate[0] &gt;= 0\n        and candidate[1] &gt;= 0\n        and candidate[2] != terrain_type(candidate[0], candidate[1])\n    ]\n\n\ndef weights(s1, s2):\n    return 1 if s1[-1] == s2[-1] else 7\n\n\ndef heuristic(s1, s2):\n    return abs(s1[0] - s2[0]) + abs(s1[1] - s2[1]) + 7 * (s1[-1] != s2[-1])\n\n\ninitial_state = 0, 0, 1\ntarget = target_x, target_y, 1\nutils.astar(initial_state, target, neighbors, heuristic, weights)"
  },
  {
    "objectID": "qmd/2018.html#part-1-22",
    "href": "qmd/2018.html#part-1-22",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThe first part is pretty simple\n\n\nCode\ndata = np.array(load(23, \"int\"))\nrow = data[np.argmax(data[:, -1])]\n(np.abs((data - row)[:, :-1]).sum(axis=1) &lt;= row[-1]).sum()"
  },
  {
    "objectID": "qmd/2018.html#part-2-22",
    "href": "qmd/2018.html#part-2-22",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe next part is signifcantly more tricky. Blindly iterating through every point and asking “how many are you in range of” is a non-starter, due to the sizes of the numbers involved. SImilarly, going the other way and generating all the covered points for each nanobot and adding those up runs into the same problem.\nA first thing to realise is that the sets of points covered by any given nanobot is an axis-aligned octahedron, centered at the nanobot’s position. The eight faces that define the octahedron have normal vectors [±1, ±1, ±1]. We can group these faces into four pairs of parallel faces, and each octahedron can be thought of as the intersection of the infinte regions between those pairs of planes. That means we can represent an octahedron as four sets of intervals, which I will call the \\((s, t, u, v)\\) basis. To intersect two octahedra we can simply intersect the corresponding intervals of each octahedron.\nWith the above considerations in hand, we could create a list of (region, number of intersections) pairs, with initial state [(all space, 0)]. We could then loop over all the nanobots, and for each one, calculate all the intersections with the existing list, and if they are non-zero, append them to the list, with updated intersection count.\nThat would build up a map of all the intersections, and the desired answer would be represented by the pair with greatest intersection count. That would look something like this:\n\n\nCode\nnormal_vectors = np.array([[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1]])\ncenters = data[:, :-1] @ normal_vectors.T\nradii = data[:, -1].reshape(-1, 1)\nc = np.transpose(np.stack([centers - radii, centers + radii + 1]), axes=[1, 2, 0])\nintersections = {}\nfor idx, row in enumerate(c):\n    current = frozenset([idx])\n    to_add = {current: row}\n    for i in intersections:\n        new_i = np.hstack(\n            [\n                np.maximum(intersections[i], row)[:, :1],\n                np.minimum(intersections[i], row)[:, 1:],\n            ]\n        )\n        if (np.diff(new_i) &gt; 0).all():\n            to_add[current.union(i)] = new_i\n    intersections = intersections | to_add\n\n    break\n\n\nUnfortunately, the above approach has a slight flaw: It ends up explicitly creating all \\(\\sim2^n\\) possible intersections. With 1000 nanobots, that’s just not feasible.\nIf we focus on just one set of planes we can quite easily find where the biggest intersection is in that direction by scanning through from \\(-\\infty\\) to \\(\\infty\\), adding one for every left plane we encounter, and subtracting one for every right plane.\n\n\nCode\nopenings = sorted(c[:, 0, 0])[::-1]\nclosings = sorted(c[:, 0, -1])[::-1]\ncurrent_closing, current_opening = closings.pop(), openings.pop()\ntotal = 0\nedges = {}\nwhile openings:\n    if current_opening &lt; current_closing:\n        total += 1\n        edges[current_opening] = total\n        current_opening = openings.pop()\n    else:\n        total -= 1\n        edges[current_closing] = total\n        current_closing = closings.pop()\nmax(edges.values())\n\n\nBut extending this to all four planes is non-obvious. Analysing the inputs shows that all the points overlap, apart from very few emitters. That means we can identify these, and the relevant points are just the intersection of all the other emitters, which can easily be found in the basis we’ve chosen.\n\n\nCode\nadjacency_matrix = np.zeros((len(c), len(c)))\nfor i, pi in enumerate(c):\n    for j, pj in enumerate(c):\n        new = np.hstack([np.maximum(pi, pj)[:, :1], np.minimum(pi, pj)[:, 1:]])\n        if (np.diff(new) &gt; 0).all():\n            adjacency_matrix[i, j] = 1\nmask = (adjacency_matrix.sum(axis = 0) &gt;= np.median(adjacency_matrix.sum(axis = 0)) / 2)\nindices = np.where(mask)[0]\nc[indices, :, :].max(axis=0)[0, 0]\n\n\nThis feels slightly like cheating, since it easily fails for other inputs.\nA better approach would be to iteratively zoom in on promising areas of space. That is, starting with a bounding box containing all the points of interest, iteratively split the box into 16 sub-boxes, and for each of these boxes ask how many of the beacons it intersects with. Expanding the boxes in the order:\n\nMost beacons in range first\nLarger boxes before smaller boxes\nBoxes closer to the origin before boxes further away\n\nMeans that by the time we see a box of size 1, we know that it is the optimal box, since\n\nAll regions of space which could potentially contain more beacons have already been examined by criterion 1\nAll larger regions of space which can see the same number of beacons have already been examined by criterion 2\nThere are no closer boxes of the same size which can see the same number of beacons by criterion 3\n\nAll we need to implement is thus a procedure for determining whether a box and a beacon intersect. But in the \\((s, t, u, v)\\) basis, that’s just determining whether the intervals that make up the box and the intervals that make up the beacon intersect. And it’s not too difficult to verify that two half-open intervals \\(\\left[ a, b\\right)\\) and \\(\\left[x, y\\right)\\) intersect if \\(x \\leq a &lt; y\\) or \\(a \\leq x &lt; b\\). Putting everything together gives\n\n\nCode\ndef score_box(corner, length, c=c):\n    x = c[:, :, 0]\n    y = c[:, :, 1]\n    left = (x &lt;= corner) & (corner &lt; y)\n    right = (corner &lt;= x) & (x - length &lt; corner)\n    return -(left | right).all(axis=1).sum()\n\n\nl = 2 ** (int(np.ceil(np.log2(abs(c).max()))))\ncorner = -l, -l, -l, -l\nlength = 2 * l\nq = PriorityQueue()\ninitial_state = score_box(corner, length), -length, 0, corner\nq.put(initial_state)\ni = 0\nwhile q.qsize() &gt; 0 and i &lt; 1000:\n    i += 1\n    s, neg_length, position, corner = q.get()\n    l = -neg_length\n    if l == 1:\n        break\n    for new_corner in (\n        np.array(list(itertools.product([0, 1], repeat=4))) * l // 2 + corner\n    ):\n        score = score_box(new_corner, l // 2)\n        position = 0 if l &gt; 2 else max(abs(new_corner))\n        q.put((score, -l // 2, position, tuple(new_corner)))\nposition"
  },
  {
    "objectID": "qmd/2018.html#part-1-23",
    "href": "qmd/2018.html#part-1-23",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis was a bit of a slog, with a fair bit of attention needed to make sure that the requirements were implemented correctly.\n\n\nCode\nclass Group:\n    def __init__(\n        self,\n        n_units,\n        hit_points,\n        damage,\n        initiative,\n        damage_type,\n        weaknesses=[],\n        immunities=[],\n    ):\n        self.n_units = n_units\n        self.hit_points = hit_points\n        self.damage = damage\n        self.initiative = initiative\n        self.damage_type = damage_type\n        self.weaknesses = weaknesses\n        self.immunities = immunities\n\n    def __repr__(self):\n        return (\n            f\"Group({self.n_units}, {self.hit_points}, {self.damage}, \"\n            f\"{self.initiative}, {self.damage_type})\"\n        )\n\n    @property\n    def effective_power(self):\n        return self.damage * self.n_units\n\n    @property\n    def is_alive(self):\n        return self.n_units &gt; 0\n\n    def attack(self, other):\n        other.defend(self.calculate_damage(other))\n\n    def calculate_damage(self, other):\n        if self.damage_type in other.immunities:\n            return 0\n        elif self.damage_type in other.weaknesses:\n            return 2 * self.effective_power\n        return self.effective_power\n\n    def defend(self, damage):\n        self.n_units = self.n_units - damage // self.hit_points\n        self.n_units = max(self.n_units, 0)\n\n    def selection_order(self):\n        return (-self.effective_power, -self.initiative)\n\n    def select_target(self, others):\n        max_damage = (0, 0, 0)\n        for other in others:\n            damage = self.calculate_damage(other)\n            key = (damage, other.effective_power, other.initiative)\n            if key &gt; max_damage:\n                max_damage = key\n                result = other\n        if max_damage[0] &gt; 0:\n            return result\n        else:\n            return None\n\n\ndef select_targets(attackers, defenders):\n    targets = []\n    defenders = defenders.copy()\n    for group in sorted(attackers, key=lambda x: x.selection_order()):\n        target = group.select_target(defenders)\n        if target is not None:\n            targets.append((group, target))\n            defenders.remove(target)\n    return targets\n\n\ndef one_round(infection, immune):\n    matchup = select_targets(infection, immune) + select_targets(immune, infection)\n\n    for match in sorted(matchup, key=lambda x: -x[0].initiative):\n        match[0].attack(match[1])\n\n    return [x for x in infection if x.is_alive], [x for x in immune if x.is_alive]\n\n\ndata = [x.split(\"\\n\")[1:] for x in load(24, \"raw\")[:-1].split(\"\\n\\n\")]\n\n\ndef parse(line):\n    n_units, hit_points, damage, initiative = [\n        int(x) for x in re.findall(\"-?\\d+\", line)\n    ]\n    damage_type = re.search(\"(\\w*) damage\", line).groups()[0]\n    immunity_match = re.search(\"\\((.*)\\)\", line)\n    if not immunity_match:\n        weaknesses, immunities = [], []\n    else:\n        weaknesses, immunities = parse_immunities(immunity_match.groups()[0])\n    return Group(\n        n_units, hit_points, damage, initiative, damage_type, weaknesses, immunities\n    )\n\n\ndef parse_immunities(exp):\n    weaknesses = []\n    immunities = []\n    for sequence in exp.split(\"; \"):\n        first, middle, *rest = sequence.split()\n        if first == \"weak\":\n            kind = weaknesses\n        else:\n            kind = immunities\n        kind += \"\".join(rest).split(\",\")\n    return weaknesses, immunities\n\n\nimmune, infection = [[parse(line) for line in block] for block in data]\nwhile immune and infection:\n    immune, infection = one_round(immune, infection)\nresult = immune if immune else infection\nsum(x.n_units for x in result)"
  },
  {
    "objectID": "qmd/2018.html#part-2-23",
    "href": "qmd/2018.html#part-2-23",
    "title": "2018 Solutions",
    "section": "Part 2",
    "text": "Part 2\nI did a binary search for this one. The players can get stuck in a draw, so we need to take that into account.\n\n\nCode\ndef winner(boost):\n    immune, infection = [[parse(line) for line in block] for block in data]\n    for group in immune:\n        group.damage += boost\n    while immune and infection:\n        total = sum(x.n_units for x in immune + infection)\n        immune, infection = one_round(immune, infection)\n        if total == sum(x.n_units for x in immune + infection):\n            return 0\n    return sum(x.n_units for x in immune)\n\n\nhigh = 1\nwhile not winner(high):\n    high *= 2\nlow = high // 2\nwhile high - low &gt; 1:\n    mid = (high + low) // 2\n    if winner(mid):\n        high = mid\n    else:\n        low = mid\nwinner(high)"
  },
  {
    "objectID": "qmd/2018.html#part-1-24",
    "href": "qmd/2018.html#part-1-24",
    "title": "2018 Solutions",
    "section": "Part 1",
    "text": "Part 1\nI could write this by hand. Or I could realise that the problem description is perfectly suited for a union-find/disjoint set data structure:\n\n\nCode\nfrom scipy.cluster.hierarchy import DisjointSet\n\npoints = [tuple(x) for x in load(25, \"int\")]\ndisjoint_set = DisjointSet(points)\nfor x in range(len(points)):\n    deltas = np.abs(np.array(points) - np.array(points[x])).sum(axis=1)\n    for y in range(x + 1, len(points)):\n        if deltas[y] &lt;= 3:\n            disjoint_set.merge(points[x], points[y])\ndisjoint_set.n_subsets"
  },
  {
    "objectID": "qmd/2022.html",
    "href": "qmd/2022.html",
    "title": "2022 Solutions",
    "section": "",
    "text": "Code\nimport functools\nimport itertools\nimport os\nimport re\nimport sys\nfrom collections import defaultdict, deque, namedtuple\nfrom pathlib import Path\nfrom queue import PriorityQueue\n\nimport more_itertools\nimport numpy as np\nimport pandas as pd\nimport scipy\n\nsys.path.insert(1, os.path.join(sys.path[0], \"..\"))\n\nimport utils\n\nload = utils.year_load(2022)"
  },
  {
    "objectID": "qmd/2022.html#part-1",
    "href": "qmd/2022.html#part-1",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nelves = [x.split(\"\\n\") for x in load(1, \"raw\").split(\"\\n\\n\")]\nmax([sum([int(y) for y in x if y]) for x in elves])"
  },
  {
    "objectID": "qmd/2022.html#part-2",
    "href": "qmd/2022.html#part-2",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsum(sorted([sum([int(y) for y in x if y]) for x in elves])[-3:])"
  },
  {
    "objectID": "qmd/2022.html#part-1-1",
    "href": "qmd/2022.html#part-1-1",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nlines = [\n    [ord(x) - ord(\"A\"), ord(y) - ord(\"X\")]\n    for x, y in [x.split() for x in load(2)]\n]\nsum([line[1] + 1 + 3 * ((line[1] - line[0] + 1) % 3) for line in lines])"
  },
  {
    "objectID": "qmd/2022.html#part-2-1",
    "href": "qmd/2022.html#part-2-1",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsum([(line[1] + line[0] - 1) % 3 + 1 + 3 * line[1] for line in lines])"
  },
  {
    "objectID": "qmd/2022.html#part-1-2",
    "href": "qmd/2022.html#part-1-2",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ntotal = 0\nlines = load(3)\nfor l in lines:\n    letter = set(l[: len(l) // 2]).intersection(set(l[len(l) // 2 :])).pop()\n    total += ord(letter.upper()) - ord(\"A\") + 1 + 26 * letter.isupper()\ntotal"
  },
  {
    "objectID": "qmd/2022.html#part-2-2",
    "href": "qmd/2022.html#part-2-2",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ntotal = 0\nfor chunk in more_itertools.chunked(lines, 3):\n    letter = functools.reduce(lambda x, y: set(x).intersection(set(y)), chunk).pop()\n    total += ord(letter.upper()) - ord(\"A\") + 1 + 26 * letter.isupper()\ntotal"
  },
  {
    "objectID": "qmd/2022.html#part-1-3",
    "href": "qmd/2022.html#part-1-3",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nassignments = load(4)\nregex = re.compile(\"\\d+\")\nassignments = map(lambda x: [int(y) for y in re.findall(regex, x)], assignments)\nassignments = [sorted([a[:2], a[2:]]) for a in assignments]\nsum((a[1] &gt;= b[1] or a[0] == b[0]) for a, b in assignments)"
  },
  {
    "objectID": "qmd/2022.html#part-2-3",
    "href": "qmd/2022.html#part-2-3",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsum((a[1] &gt;= b[0] or a[0] == b[0]) for a, b in assignments)"
  },
  {
    "objectID": "qmd/2022.html#part-1-4",
    "href": "qmd/2022.html#part-1-4",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nlines = load(5)\nnumbers = [re.findall(\"\\d+\", line) for line in lines]\nsplit = np.argmax([len(x) for x in numbers])\ninstructions = [[int(y) for y in x] for x in numbers[split + 1 :] if x]\ninitial_state = list(itertools.zip_longest(*lines[:split]))\n\nletters = [re.findall(\"[A-Z]\", \"\".join(column)) for column in initial_state]\np1 = [x[::-1] for x in letters.copy() if x]\nfor n, source, dest in instructions:\n    for i in range(n):\n        p1[dest - 1].append(p1[source - 1].pop())\n\"\".join(x[-1] if x else \" \" for x in p1)"
  },
  {
    "objectID": "qmd/2022.html#part-2-4",
    "href": "qmd/2022.html#part-2-4",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\np2 = [x[::-1] for x in letters.copy() if x]\nfor n, source, dest in instructions:\n    p2[dest - 1] += p2[source - 1][-n:]\n    p2[source - 1] = p2[source - 1][:-n]\n\"\".join(x[-1] if x else \" \" for x in p2)"
  },
  {
    "objectID": "qmd/2022.html#part-1-5",
    "href": "qmd/2022.html#part-1-5",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(6)[0]\n\n\ndef find_marker(n):\n    for i in range(len(data) - n + 1):\n        if len(set(list(data[i : i + n]))) == n:\n            return i + n\n\n\nfind_marker(4)"
  },
  {
    "objectID": "qmd/2022.html#part-2-5",
    "href": "qmd/2022.html#part-2-5",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nfind_marker(14)"
  },
  {
    "objectID": "qmd/2022.html#part-1-6",
    "href": "qmd/2022.html#part-1-6",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis requires a bit of tedious bookkeeping, but is otherwise straightforward.\nKeeping track of full names is necessary, since “/foo/baz” and “/bar/baz” refer to two different directories.\nThe following code has a bug where it will show incorrect totals if the contents of the same directory are described more than once. Luckily, that doesn’t seem to ever happen.\n\n\nCode\nlines = load(7)\ndirectory = {\"/\": {\"children\": [], \"parent\": None, \"weights\": []}}\n\n\ndef get_fullname(name, parent):\n    return f\"{parent if parent != '/' else ''}/{name}\"\n\n\ndef add_directory(name, parent, directory):\n    fullname = get_fullname(name, parent)\n    directory[fullname] = {\"children\": [], \"parent\": parent, \"weights\": []}\n    directory[parent][\"children\"].append(fullname)\n\n\nfor idx, line in enumerate(lines):\n    if \"$ cd\" in line:\n        target = line.split()[-1]\n        if target == \"..\":\n            cwd = directory[cwd][\"parent\"]\n        elif target == \"/\":\n            cwd = \"/\"\n        else:\n            cwd = get_fullname(target, cwd)\n    if line[0] != \"$\":\n        metadata, name = line.split()\n        if metadata == \"dir\":\n            if name not in directory:\n                add_directory(name, cwd, directory)\n        else:\n            directory[cwd][\"weights\"].append(int(metadata))\nweights = {}\n\n\ndef calculate_weights(node):\n    if node not in weights:\n        weights[node] = sum(directory[node][\"weights\"]) + sum(\n            calculate_weights(node) for node in directory[node][\"children\"]\n        )\n    return weights[node]\n\n\ncalculate_weights(\"/\")\nsum(weight for weight in weights.values() if weight &lt;= 100_000)"
  },
  {
    "objectID": "qmd/2022.html#part-2-6",
    "href": "qmd/2022.html#part-2-6",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe weight of every directory has been stored in the weight dict, so finding the smallest one that’s greater than a given threshold is trivial\n\n\nCode\nto_free = weights[\"/\"] - 40_000_000\nmin(weight for weight in weights.values() if weight &gt;= to_free)"
  },
  {
    "objectID": "qmd/2022.html#part-1-7",
    "href": "qmd/2022.html#part-1-7",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\nIt really feels like there should be a slick array-based solution to this: calculate the cumulative max from each of the four directions, take the minimum of those four and compare with our array. But it doesn’t seem like numpy has easy functionality for calculating the cumulative max.\nA bit off digging reveals the very useful ufunc accumulate, which does exactly what we need. Then it’s just a question of getting it to work in the four directions. Either we change the axis and direction of operation, or (as here) we transform the data from one orientation to another, do the accumulation, and transform back at the end.\n\n\nCode\ndata = np.array([[int(char) for char in line] for line in load(8)])\nmasks = []\nfor i in range(4):\n    transformed = np.rot90(data, i)\n    mask = np.roll(np.maximum.accumulate(transformed), 1, axis=0)\n    mask[0] = -1\n    masks.append(np.rot90(mask, 4 - i))\nmask = np.min(masks, axis=0)\n(data &gt; mask).sum()"
  },
  {
    "objectID": "qmd/2022.html#part-2-7",
    "href": "qmd/2022.html#part-2-7",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe conceptual approach for this is similar - find a way of calculating the score in one direction, then transform the data to use that operation for the other directions.\nThere are a couple of gotchas:\n\nThe elves’ sightlines are blocked by trees of the same height, not just by trees of greater height. If we want to leverage maximum as an indicator, we need to decrease the value of the tree under consideration by one, since otherwise there’s no way of distinguishing between a, a - 1 (not blocked) and a, a (blocked).\nThe elves can see the tree that they’re being blocked by. If we try to account for this by just adding one to all the sightlines, we’ll get a bug when they can see all the way to the edge. Instead, we pretend that they can always see the last tree in the forest\n\n\n\nCode\ndef scenic_score(data):\n    def one_row(i):\n        \"\"\"How many trees can be seen looking down from row i\"\"\"\n        current = data.copy()\n        current[i] = current[i] - 1\n        mask = np.maximum.accumulate(np.roll(current, -i, axis=0)) &lt;= current[i]\n        mask[-i - 1] = True\n        return mask[1 : len(data) - i].sum(axis=0)\n\n    return np.array([one_row(i) for i in range(len(data))])\n\n\nscenic_scores = []\nfor i in range(4):\n    scenic_scores.append(np.rot90(scenic_score(np.rot90(data, i)), 4 - i))\nnp.product(scenic_scores, axis=0).max()"
  },
  {
    "objectID": "qmd/2022.html#bonus",
    "href": "qmd/2022.html#bonus",
    "title": "2022 Solutions",
    "section": "Bonus",
    "text": "Bonus\nThe grid here invites plotting. One thing we can plot is the shortest tree which would be visible at each location\n\n\nCode\nimport matplotlib.pyplot as plt\n\nplt.imshow(mask + 1)\nplt.xticks([]), plt.yticks([])\na = plt.colorbar()\n\n\n\n\n\nThe shortest visible tree at each location\n\n\n\n\nWe can see how at the edges of the forest shorter trees are visible, but towards the center they’ve all been shadowed by taller trees."
  },
  {
    "objectID": "qmd/2022.html#part-1-8",
    "href": "qmd/2022.html#part-1-8",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nbase = {2: 1, 2 + 1j: 1 + 1j, 2 + 2j: 1 + 1j, 1 + 2j: 1 + 1j}\ndeltas = {k * 1j**i: v * 1j**i for k, v in base.items() for i in range(4)}\ndirections = {\"R\": 1, \"L\": -1, \"U\": 1j, \"D\": -1j}\ninstructions = [x.split() for x in load(9)]\n\n\ndef tail_moves(rope_length):\n    seen = []\n    rope = [0] * rope_length\n    for direction, count in instructions:\n        for _ in range(int(count)):\n            rope[0] += directions[direction]\n            for i in range(1, len(rope)):\n                rope[i] += (\n                    deltas[rope[i - 1] - rope[i]]\n                    if abs(rope[i - 1] - rope[i]) &gt;= 2\n                    else 0\n                )\n            seen.append(rope[-1])\n    return seen\n\n\nlen(set(tail_moves(2)))"
  },
  {
    "objectID": "qmd/2022.html#part-2-8",
    "href": "qmd/2022.html#part-2-8",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nlen(set(tail_moves(10)))"
  },
  {
    "objectID": "qmd/2022.html#part-1-9",
    "href": "qmd/2022.html#part-1-9",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ninstructions = load(10)\ndeltas = [\n    int(element) if element[-1].isdigit() else 0\n    for line in instructions\n    for element in line.split()\n]\n\n\ndef run(f, result):\n    for cycle, x in enumerate(np.cumsum([1] + deltas)):\n        result += f(x, cycle + 1)\n    return result\n\n\nrun(lambda x, y: x * y if y % 40 == 20 else 0, 0)"
  },
  {
    "objectID": "qmd/2022.html#part-2-9",
    "href": "qmd/2022.html#part-2-9",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef draw_sprite(sprite_position, cycle):\n    return \"█\" if abs(sprite_position - ((cycle - 1) % 40)) &lt;= 1 else \" \"\n\n\nprint(*[run(draw_sprite, \"\")[40 * i : 40 * (i + 1)] for i in range(6)], sep=\"\\n\")"
  },
  {
    "objectID": "qmd/2022.html#part-1-10",
    "href": "qmd/2022.html#part-1-10",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(11, \"raw\")\nmonkeys = data.split(\"\\n\\n\")\n\n\nclass Monkey:\n    def __init__(self, update, test):\n        self.update = update\n        self.factor = test[0]\n        self.target = lambda x: test[1] if x % self.factor == 0 else test[2]\n\n\nmonkeys = []\ninitial_items = []\nfor monkey in data.split(\"\\n\\n\"):\n    lines = [line for line in monkey.split(\"\\n\") if line]\n    update = eval(\"lambda old: \" + lines[2].split(\" = \")[1])\n    digits = [[int(x) for x in re.findall(\"\\d+\", line)] for line in lines]\n    monkeys.append(Monkey(update, [x[0] for x in digits[-3:]]))\n    initial_items.append(digits[1])\n\n\ndef run(rounds, function):\n    examined = [0] * len(monkeys)\n    for monkey, items in zip(monkeys, initial_items):\n        monkey.items = items.copy()\n    for _ in range(rounds):\n        for idx, monkey in enumerate(monkeys):\n            examined[idx] += len(monkey.items)\n            for i in range(len(monkey.items)):\n                item = function((monkey.update(monkey.items.pop())))\n                monkeys[monkey.target(item)].items.append(item)\n    return examined\n\n\nnp.product(sorted(run(20, lambda x: x // 3))[-2:])"
  },
  {
    "objectID": "qmd/2022.html#part-2-10",
    "href": "qmd/2022.html#part-2-10",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ncommon_multiple = np.product([x.factor for x in monkeys])\nnp.product(sorted(run(10000, lambda x: x % common_multiple))[-2:])"
  },
  {
    "objectID": "qmd/2022.html#part-1-11",
    "href": "qmd/2022.html#part-1-11",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = [list(x) for x in load(12)]\nelevations = np.array([[ord(char) - ord(\"a\") for char in line] for line in data])\nsource = tuple(x[0] for x in np.where(elevations == ord(\"S\") - ord(\"a\")))\ntarget = tuple(x[0] for x in np.where(elevations == ord(\"E\") - ord(\"a\")))\nelevations[source] = 0\nelevations[target] = 25\n\nxmax, ymax = elevations.shape\n\n\ndef grid_neighbors(x, y):\n    candidates = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n    return [c for c in candidates if 0 &lt;= c[0] &lt; xmax and 0 &lt;= c[1] &lt; ymax]\n\n\ndef find_neighbors(x, y):\n    return [n for n in grid_neighbors(x, y) if elevations[n] - elevations[x, y] &lt;= 1]\n\n\ndef navigate(source, neighbor_func, stop_condition):\n    active = deque([(0, source)])\n    seen = set()\n    while active:\n        steps, current = active.popleft()\n        if stop_condition(current):\n            return steps\n        if current in seen:\n            continue\n        seen.add(current)\n        for neighbor in neighbor_func(*current):\n            active.append((steps + 1, neighbor))\n    return np.inf\n\n\nnavigate(source, find_neighbors, lambda x: x == target)"
  },
  {
    "objectID": "qmd/2022.html#part-2-11",
    "href": "qmd/2022.html#part-2-11",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef reversed_neighbors(x, y):\n    return [n for n in grid_neighbors(x, y) if elevations[x, y] - elevations[n] &lt;= 1]\n\n\nnavigate(target, reversed_neighbors, lambda x: elevations[x] == 0)"
  },
  {
    "objectID": "qmd/2022.html#part-1-12",
    "href": "qmd/2022.html#part-1-12",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nimport ast\n\n\ndef compare(left, right):\n    if isinstance(left, int) and isinstance(right, int):\n        return (left &gt; right) + (left &gt;= right)\n    if isinstance(left, int):\n        return compare([left], right)\n    if isinstance(right, int):\n        return compare(left, [right])\n    if not left and not right:\n        return 1\n    if not left:\n        return 0\n    if not right:\n        return 2\n    val = compare(left[0], right[0])\n    return val if (val == 0 or val == 2) else compare(left[1:], right[1:])\n\n\ntotal = 0\ns = load(13, \"raw\")[:-1]\nfor idx, (left, right) in enumerate(map(lambda x: x.split(\"\\n\"), s.split(\"\\n\\n\"))):\n    val = compare(ast.literal_eval(left), ast.literal_eval(right))\n    if val == 0:\n        total += idx + 1\ntotal"
  },
  {
    "objectID": "qmd/2022.html#part-2-12",
    "href": "qmd/2022.html#part-2-12",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndividers = [[2]], [[6]]\npackets = [\n    ast.literal_eval(packet) for pair in s.split(\"\\n\\n\") for packet in pair.split(\"\\n\")\n]\npositions = [\n    sum(compare(divider, packet) == 2 for packet in packets) for divider in dividers\n]\n(positions[0] + 1) * (positions[1] + 2)"
  },
  {
    "objectID": "qmd/2022.html#part-1-13",
    "href": "qmd/2022.html#part-1-13",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(14, \"int\")\nflat = [val for line in data for val in line]\nxmin, xmax = min(flat[::2]), max(flat[::2])\nymin, ymax = min(flat[1::2]), max(flat[1::2])\nair, rock, sand = ord(\".\"), ord(\"#\"), ord(\"o\")\nboard = np.zeros((ymax + 1, xmax - xmin + 3), dtype=int) + air\nfor line in data:\n    chunks = list(more_itertools.chunked(line, 2))\n    for (current_x, current_y), (next_x, next_y) in zip(chunks, chunks[1:]):\n        current_y, next_y = sorted([current_y, next_y])\n        current_x, next_x = sorted([current_x, next_x])\n        if current_x == next_x:\n            board[current_y : next_y + 1, current_x - xmin + 1] = rock\n        else:\n            board[current_y, current_x - xmin + 1 : next_x - xmin + 2] = rock\ninitial_board = board.copy()\nstart = 0, 500 - xmin + 1\ny, x = start\n\n\nwhile y + 1 &lt; board.shape[0]:\n    if board[y + 1, x] == air:\n        y += 1\n    elif board[y + 1, x - 1] == air:\n        y, x = y + 1, x - 1\n    elif board[y + 1, x + 1] == air:\n        y, x = y + 1, x + 1\n    else:\n        board[y, x] = sand\n        y, x = start\n(board == sand).sum()"
  },
  {
    "objectID": "qmd/2022.html#part-2-13",
    "href": "qmd/2022.html#part-2-13",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nboard = np.vstack([initial_board, np.zeros((2, board.shape[1]), dtype=int) + air])\npad_width = (board.shape[0] * 2 - board.shape[1]) // 2 + 2\npadding = np.zeros((board.shape[0], pad_width), dtype=int) + air\nboard = np.hstack([padding, board, padding])\nboard[-1] = rock\nstart = 0, 500 - xmin + 1 + pad_width\ny, x = start\nwhile True:\n    if board[y + 1, x] == air:\n        y += 1\n    elif board[y + 1, x - 1] == air:\n        y, x = y + 1, x - 1\n    elif board[y + 1, x + 1] == air:\n        y, x = y + 1, x + 1\n    else:\n        board[y, x] = sand\n        if (y, x) == start:\n            break\n        y, x = start\n(board == sand).sum()"
  },
  {
    "objectID": "qmd/2022.html#part-1-14",
    "href": "qmd/2022.html#part-1-14",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndef combine_two_intervals(i1, i2):\n    i1, i2 = sorted([i1, i2])\n    if i2[0] &lt;= i1[1]:\n        return i1[0], max(i1[1], i2[1])\n    return False\n\n\ndef combine_n_intervals(intervals):\n    active = intervals.copy()\n    result = []\n    while active:\n        current = active.pop()\n        for index, previous in enumerate(result):\n            new_interval = combine_two_intervals(current, previous)\n            if new_interval:\n                del result[index]\n                active.append(new_interval)\n                break\n        else:\n            result.append(current)\n    return result\n\n\ny_target = 2000000\nfixes = set()\nintervals = []\nfor x, y, u, v in load(15, \"int\"):\n    r = abs(x - u) + abs(y - v)\n    if v == y_target:\n        fixes.add(u)\n    available = r - abs(y - y_target)\n    if available &gt;= 0:\n        interval = x - available, x + available + 1\n        intervals += [interval]\nintervals = combine_n_intervals(intervals)\nsum(x[1] - x[0] for x in intervals) - len(fixes)"
  },
  {
    "objectID": "qmd/2022.html#part-2-14",
    "href": "qmd/2022.html#part-2-14",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\nTo solve this quickly, we need to move from a representation of the problem in terms of the covered points to one that considers the beacons as the central object. From the problem description, we can see that the point we are interested in must lie just out of range of at least two beacons, since otherwise there would be more than one point which satisfies the criteria.\nWe’ll do a coordinate transformation so that we’re working in a basis of (x + y, x - y) coordinates; in that basis, the area covered by each beacon is an axis-aligned square. Determining whether (and where) two squares intersect can be done by looking at the two axes of the square separately. We can thus loop over pairs of beacons, and for each pair identify the points which would be just out of range of both beacons; for each of these points we can check whether it is in range of any of the other beacons. If it is not, we have found the point we were interested in and we are finished.\n\n\nCode\ndata = np.array(load(15, \"int\"))\nradii = abs(np.squeeze(np.diff(data.reshape(-1, 2, 2), axis=1))).sum(axis=1)\ndiamonds = np.hstack([data[:, :2] @ [[1, 1], [1, -1]], radii.reshape(-1, 1)])\n\n\ndef intersect_intervals(i0, i1):\n    new_left = max(i0[0], i1[0])\n    new_right = min(i0[1], i1[1])\n    return [new_left, new_right] if new_right &gt;= new_left else []\n\n\ndef is_on_square(point, centre, radius):\n    return abs(point[0] - centre[0]) == radius or abs(point[1] - centre[1]) == radius\n\n\ndef intersect_diamonds(d0, d1):\n    x0, y0, r0 = d0\n    x1, y1, r1 = d1\n    if (x0 + r0) % 2 != (x1 + r1) % 2:\n        return []\n    result = []\n    for x in intersect_intervals((x0 - r0, x0 + r0), (x1 - r1, x1 + r1)):\n        for y in intersect_intervals((y0 - r0, y0 + r0), (y1 - r1, y1 + r1)):\n            if is_on_square((x, y), (x0, y0), r0) and is_on_square(\n                (x, y), (x1, y1), r1\n            ):\n                result.append((x, y))\n    return result\n\n\ndone = False\nlimit = 4000000\nfor d0 in diamonds + [0, 0, 1]:\n    for d1 in diamonds + [0, 0, 1]:\n        if (d0 == d1).all():\n            continue\n        for x0, y0 in intersect_diamonds(d0, d1):\n            for x, y, r in diamonds:\n                if abs(x0 - x) &lt;= r and abs(y0 - y) &lt;= r:\n                    break\n            else:\n                real_x, real_y = (x0 + y0) // 2, (x0 - y0) // 2\n                if abs(real_x) &lt;= limit and abs(real_y) &lt;= limit:\n                    done = True\n                    break\n        if done:\n            break\n    if done:\n        break\nlimit * real_x + real_y\n\n\n\n\nCode\ncentres = np.array([[1, 0], [0, 0]])\nradii = np.array([1, 2])\nd0, d1 = np.hstack([centres @ [[1, 1], [1, -1]], radii.reshape(-1, 1)])\nintersect_diamonds(d0, d1)"
  },
  {
    "objectID": "qmd/2022.html#part-1-15",
    "href": "qmd/2022.html#part-1-15",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\nWe should start by loading the data, and trying to visualize the graph\n\n\nCode\nimport sknetwork\n\ngraph = {}\npressures = {}\nfor line in load(16):\n    pressure = int(re.findall(r\"\\d+\", line)[0])\n    left, right = line.split(\";\")\n    node = left.split()[1]\n    neighbors = [\n        x.strip() for x in re.sub(\".*valves? (.*)\", r\"\\1\", right[:-1]).split(\",\")\n    ]\n    graph[node] = neighbors\n    if pressure &gt; 0:\n        pressures[node] = pressure\ng = sknetwork.data.from_adjacency_list(graph, weighted=False)\n\nfrom IPython.display import SVG\nfrom sknetwork.embedding.force_atlas import ForceAtlas\n\nforceatlas2 = ForceAtlas()\nembedding = forceatlas2.fit_transform(g.adjacency)\nimage = sknetwork.visualization.svg_graph(g.adjacency, embedding, names=g.names)\nSVG(image)\n\n\n\n\n\nThe network of rooms and valves, and how they link together\n\n\n\n\nLooks pretty cool!\n\n\nCode\ndistances = {\n    (j, i): 0 if i == j else 100 if i not in graph[j] else 1\n    for i in graph\n    for j in graph\n}\n# Very slick Floyd-Warshall: The distance between two nodes i and j is the minimum over\n# all paths from i to j, which in turn is the minimum of the sum d(i, k) + d(j,\n# k) over all nodes k. Shamelessly stolen. Could have been done with some\n# pathfinding instead, but that would have been slower.\nfor k, i, j in itertools.permutations(graph, 3):\n    distances[i, j] = min(distances[i, j], distances[i, k] + distances[k, j])\n\n\ndef expand(node, time_remaining):\n    result = {}\n\n    # For each possible set of open valves, we store the result of opening them\n    # in the optimal order. We take care not to exceed the time alloted to us,\n    # and not to open a valve twice.\n    def inner(node, time_remaining, used_valves, flow):\n        result[used_valves] = max(result.get(used_valves, 0), flow)\n        for other_node, pressure in pressures.items():\n            new_time_remaining = time_remaining - distances[node, other_node] - 1\n            if new_time_remaining &lt;= 0 or other_node in used_valves:\n                continue\n            inner(\n                other_node,\n                new_time_remaining,\n                used_valves | frozenset([other_node]),\n                flow + new_time_remaining * pressure,\n            )\n\n    inner(node, time_remaining, frozenset(), 0)\n    return result\n\n\n# The result for part 1 is then\nmax(expand(\"AA\", 30).values())"
  },
  {
    "objectID": "qmd/2022.html#part-2-15",
    "href": "qmd/2022.html#part-2-15",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, we don’t need to consider the two agents together. We can just find the best pair of valve sets with no overlaps.\n\n\nCode\npart2_paths = expand(\"AA\", 26)\nmax(\n    v1 + v2\n    for s1, v1 in part2_paths.items()\n    for s2, v2 in part2_paths.items()\n    if not (s1 & s2)\n)"
  },
  {
    "objectID": "qmd/2022.html#part-1-16",
    "href": "qmd/2022.html#part-1-16",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nshapes = [\n    np.array(\n        [[0 if char == \".\" else 1 for char in line] for line in x.split(\"\\n\")],\n        dtype=bool,\n    )\n    for x in [\"####\", \".#.\\n###\\n.#.\", \"..#\\n..#\\n###\", \"#\\n#\\n#\\n#\", \"##\\n##\"]\n]\ndirections = load(17, \"raw\").strip()\n\n\ndef has_collision(x, y, shape, board):\n    if y &lt; 0:\n        return False\n    height, width = shape.shape\n    window = np.pad(\n        shape[max(0, height - y - 1) :],\n        [[0, 0], [x, 7 - x - width]],\n        mode=\"constant\",\n    )\n    top_of_window = y - window.shape[0] + 1\n    return (board[top_of_window : top_of_window + window.shape[0]] & window).any()\n\n\ndef find_height(directions, n=2022):\n    board = np.ones((1, 7), dtype=bool)\n    discard = -1\n    d = 0\n    seen = {}\n    cycle_length = None\n    for i in range(n):\n        shape = shapes[i % len(shapes)]\n        height, width = shape.shape\n        x, y = 2, -4\n        while True:\n            direction = directions[d]\n            d = (d + 1) % len(directions)\n            if direction == \"&gt;\":\n                if x + width != 7 and not has_collision(x + 1, y, shape, board):\n                    x += 1\n            else:\n                if x != 0 and not has_collision(x - 1, y, shape, board):\n                    x -= 1\n            if y &lt; -1:\n                y += 1\n            else:\n                if has_collision(x, y + 1, shape, board):\n                    old_board = board.copy()\n                    board = np.pad(\n                        board, [[max(height - y - 1, 0), 0], [0, 0]], mode=\"constant\"\n                    )\n                    loc = max(y - height + 1, 0)\n                    board[loc : loc + height, x : x + width] += shape\n                    break\n                y += 1\n        row = board.all(axis=1).argmax()\n        discard += board.shape[0] - row - 1\n        board = board[: row + 1]\n        state = (i % len(shapes), d, tuple(np.ravel(board)))\n        if state in seen:\n            if cycle_length is None:\n                cycle_length = i - seen[state][0]\n            if (i % cycle_length) == (n % cycle_length):\n                delta_h = board.shape[0] + discard - seen[state][1]\n                return board.shape[0] + discard + delta_h * ((n - i) // cycle_length)\n        seen[state] = i, board.shape[0] + discard\n    return seen[state][1]\n\n\nfind_height(directions)"
  },
  {
    "objectID": "qmd/2022.html#part-2-16",
    "href": "qmd/2022.html#part-2-16",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\nActually simulating that many steps isn’t possible, so we should probably look for a loop of some kind. To avoid having to think too much, we’ll say that after any given rock has fallen the state is (shapeindex, windindex, hash of board above latest full line). If a state ever repeats, we know it will go on repeating forever, so we can just advance until we’re at the same point in the cycle as the very end, and then add on however many cycles we need\n\n\nCode\nfind_height(directions, 1_000_000_000_000) - 1\n\n\nThere’s a weird off by one error in my code which is only present for some cases. I can’t be bothered to find out why."
  },
  {
    "objectID": "qmd/2022.html#part-1-17",
    "href": "qmd/2022.html#part-1-17",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\nIdea: find all neighboring boxes by finding the union of the shifts along each of i,j,k,-i,-j,-k and subtracting the original shape. A given box might neighbor the original shape in up to six places, so to account for that I can take all the neighbors, shift them again along each of the axes, and for each shift, count how many boxes now overlap the original shape.\n\n\nCode\ndata = load(18, \"np\")\n\n\ndef to_set(arr):\n    return set(tuple(x) for x in arr)\n\n\ndef inflate(data):\n    if isinstance(data, set):\n        data = np.array(list(data))\n    return to_set(np.vstack([row + data for row in deltas])) - occupied\n\n\noccupied = to_set(data)\ndeltas = (np.tile(np.eye(3, dtype=int), 2) * np.repeat((1, -1), 3)).T\nnb = inflate(data)\narr = np.array(list(nb))\nsum([len(to_set(arr + delta) & occupied) for delta in deltas])"
  },
  {
    "objectID": "qmd/2022.html#part-2-17",
    "href": "qmd/2022.html#part-2-17",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, once we have identified which of the neighboring boxes represent external neighbors (i.e. are connected to the outside world), we can do exactly the same thing. The tricky thing is then to make this identification. Under the assumption that the droplet is connected, so that every box in the droplet is reachable from every other via a series of face, edge or corner moves, then every point the outside boundary is face-connected to every other after at most two inflations. I can then use a union find data structure to merge all the connected groups together, and the outside group is then the largest of all of these\n\n\nCode\nfrom scipy.cluster.hierarchy import DisjointSet\n\npoints = inflate(data)\nfor i in range(2):\n    points = inflate(points)\n\ndisjoint_set = DisjointSet(points)\nfor x in points:\n    comparisons = x + np.eye(3, dtype=int)\n    for comparison in comparisons:\n        if (y := tuple(comparison)) in disjoint_set:\n            disjoint_set.merge(x, y)\nmax_s = 0\nfor subset in disjoint_set.subsets():\n    if len(subset) &gt; max_s:\n        max_s = len(subset)\n        s = subset\narr = np.array(list(s & nb))\nsum([len(to_set(arr + delta) & occupied) for delta in deltas])"
  },
  {
    "objectID": "qmd/2022.html#part-1-18",
    "href": "qmd/2022.html#part-1-18",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThe core of this problem is to develop an approach that can take a list of prices and generate an optimal build. Blindly taking every action probably won’t work, but is maybe worth examining as a first attempt.\nInstead of simulating each of the 24 different time steps, we should focus on the build order, so the decision at any given point in time is which robot to build next. We should bail from any given branch if:\n\nThe time has exceeded the maximum time available\nWe have built more robots of a given kind than are needed by any of the recipes\nWe’ve already seen a better situation: Suppose we’ve previously found a state with a given config of robots at t1, and now have built the same robots at a later time t2. If we could have the same or more resources at t2 by using the t1 config and just waiting, then the first build order is strictly better.\n\n\n\nCode\ndef score(geodes, time, t_max=24):\n    time_remaining = t_max - time - 1\n    return -(geodes + time_remaining * (time_remaining + 1) // 2)\n\n\ndef is_better(t1, r1, g1, i, t2, r2, g2):\n    return False  # (t2 &gt;= t1) and (g1 &gt;= g2) and ((r1 + (t2 - t1) * i) &gt;= r2).all()\n\n\ndef evaluate(costs, t_max=24):\n    seen = defaultdict(dict)\n    max_prices = costs.max(axis=0)\n    income = np.array([1, 0, 0])\n    resources = np.array([0, 0, 0])\n    time = 0\n    geodes = 0\n    initial_state = (\n        score(geodes, time, t_max),\n        time,\n        geodes,\n        tuple(income),\n        tuple(resources),\n    )\n    q = PriorityQueue()\n    q.put(initial_state)\n    max_geodes = 0\n    while q.qsize() &gt; 0:\n        _, time, geodes, income, resources = q.get()\n        income, resources = np.array(income), np.array(resources)\n        if time == t_max:\n            break\n        for t1, (r1, g1) in seen[tuple(income)].items():\n            if is_better(t1, r1, g1, income, time, resources, geodes):\n                break\n        else:\n            seen[tuple(income)][time] = (resources, geodes)\n            with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                waits = (costs - resources) / income\n            waits[np.isnan(waits)] = 0\n            for idx, wait in enumerate(np.ceil(waits.max(axis=1))):\n                wait = max(wait, 0)\n                if time + wait + 1 &gt; t_max:\n                    continue\n                # Turns to wait for resources, plus one to build\n                dt = int(wait) + 1\n                new_time = time + dt\n                new_income = income.copy()\n                new_geodes = geodes\n                if idx != 3:\n                    if income[idx] &gt;= max_prices[idx]:\n                        continue\n                    new_income[idx] += 1\n                else:\n                    new_geodes += t_max - new_time\n                    if new_geodes &gt; max_geodes:\n                        max_geodes = new_geodes\n\n                new_resources = resources.copy() + income * dt - costs[idx]\n\n                q.put(\n                    (\n                        score(new_geodes, new_time, t_max),\n                        new_time,\n                        new_geodes,\n                        tuple(new_income),\n                        tuple(new_resources),\n                    )\n                )\n    return max_geodes\n\n\ntotal = 0\nfor blueprint_id, *l in load(19, \"int\"):\n    costs = np.array([[l[0], 0, 0], [l[1], 0, 0], [l[2], l[3], 0], [l[4], 0, l[5]]])\n    total += blueprint_id * evaluate(costs)\ntotal"
  },
  {
    "objectID": "qmd/2022.html#part-2-18",
    "href": "qmd/2022.html#part-2-18",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ntotal = 1\nfor _, *l in load(19, \"int\")[:3]:\n    costs = np.array([[l[0], 0, 0], [l[1], 0, 0], [l[2], l[3], 0], [l[4], 0, l[5]]])\n    total *= evaluate(costs, 32)\ntotal"
  },
  {
    "objectID": "qmd/2022.html#part-1-19",
    "href": "qmd/2022.html#part-1-19",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\nI was almost caught out by the fact that there can be duplicate entries in the data; my original linked list in a dictionary didn’t account for this, so nodes were silently dropped. Oops.\nOtherwise the simple approach ended up working: make a list of node -&gt; (predecessor, successor), and to move a given element simply follow the pointers the relevant number of times.\nTo save time, I map each rotation to the range [-l/2, l/2] where l is the length of the linked list. The idea is that for a circular list of length l, moving l-1 steps to the right is the same as not moving, and since the list is doubly linked, moving one step to the left is better than moving l-2 steps to the right.\n\n\nCode\ndef mix(data, n=1):\n    unique_data = list(enumerate(data))\n    ll = {\n        k: [p, n]\n        for (k, p, n) in zip(\n            unique_data,\n            [unique_data[-1]] + unique_data[:-1],\n            unique_data[1:] + [unique_data[0]],\n        )\n    }\n    for i in range(n):\n        for value in enumerate(data):\n            mod = len(data) - 1\n            offset = mod // 2\n            shift = (value[1] + offset) % mod - offset\n            if shift == 0:\n                continue\n            current = ll[value]\n            ll[current[0]][1] = current[1]\n            ll[current[1]][0] = current[0]\n            del ll[value]\n            coord = 1 if shift &gt; 0 else 0\n            for _ in range(abs(shift)):\n                current = ll[current[coord]]\n\n            succ = current[coord]\n            pred = ll[succ][1 - coord]\n            if shift &lt; 0:\n                pred, succ = succ, pred\n            ll[value] = [pred, succ]\n            ll[pred][1] = value\n            ll[succ][0] = value\n    v = (data.index(0), 0)\n    result = []\n    for _ in range(len(ll)):\n        result.append(v[1])\n        v = ll[v][1]\n    return sum(result[((i + 1) * 1000) % len(result)] for i in range(3))\n\n\ndata = list(load(\"20\", \"np\"))\nmix(data)"
  },
  {
    "objectID": "qmd/2022.html#part-2-19",
    "href": "qmd/2022.html#part-2-19",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nmix([x * 811589153 for x in data], 10)"
  },
  {
    "objectID": "qmd/2022.html#part-1-20",
    "href": "qmd/2022.html#part-1-20",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\nWe’ll use recursion and the call stack to keep track of the operations for us\n\n\nCode\nfrom operator import add, ifloordiv, mul, sub\n\ninstructions = {}\nlookup = {\"*\": mul, \"/\": ifloordiv, \"-\": sub, \"+\": add}\nfor line in load(21):\n    lhs, rhs = line.split(\":\")\n    operands = rhs.split()\n    if len(operands) == 1:\n        instructions[lhs] = {\"dependencies\": [], \"value\": int(operands[0])}\n    else:\n        instructions[lhs] = {\n            \"dependencies\": [operands[0], operands[2]],\n            \"operation\": lookup[operands[1]],\n        }\n\n\n@functools.cache\ndef value(mystring):\n    instruction = instructions[mystring]\n    if not instruction[\"dependencies\"]:\n        return instruction[\"value\"]\n    else:\n        return instruction[\"operation\"](\n            *[value(x) for x in instruction[\"dependencies\"]]\n        )\n\n\nvalue(\"root\")"
  },
  {
    "objectID": "qmd/2022.html#part-2-20",
    "href": "qmd/2022.html#part-2-20",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nvalue.cache_clear()\ninverse_operations = {sub: add, add: sub, mul: ifloordiv, ifloordiv: mul}\nif \"humn\" in instructions:\n    del instructions[\"humn\"]\ninstructions[\"root\"][\"operation\"] = sub\n\n\ndef balance(instruction, target):\n    if instruction == \"humn\":\n        return target\n    for idx, dependency in enumerate(instructions[instruction][\"dependencies\"]):\n        try:\n            v = value(dependency)\n            pos = idx\n        except KeyError:\n            next_instruction = dependency\n    op = instructions[instruction][\"operation\"]\n    if pos == 0 and op in [ifloordiv, sub]:\n        updated_target = op(v, target)\n    else:\n        updated_target = inverse_operations[op](target, v)\n    return balance(next_instruction, updated_target)\n\n\nbalance(\"root\", 0)"
  },
  {
    "objectID": "qmd/2022.html#part-1-21",
    "href": "qmd/2022.html#part-1-21",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(22, \"raw\")\nchart, instructions = data.split(\"\\n\\n\")\nchart = chart.split(\"\\n\")\ntarget = max(len(x) for x in chart)\nchart = [[x for x in line.ljust(target, \" \")] for line in chart]\nboard = np.array(chart)\nstart_x = (board[0] == \".\").argmax()\ny, x = 0, start_x\ndy, dx = 0, 1\nymax, xmax = board.shape\nR = np.array([[0, 1], [-1, 0]])\nL = -R\nmatrices = {\"L\": L, \"R\": R}\ninstructions = instructions.replace(\"R\", \" R \").replace(\"L\", \" L \").split()\nfor instruction in instructions:\n    if instruction in \"LR\":\n        dy, dx = matrices[instruction] @ [dy, dx]\n    else:\n        for _ in range(int(instruction)):\n            next_y, next_x = (y + dy) % ymax, (x + dx) % xmax\n            while board[next_y, next_x] == \" \":\n                next_y, next_x = (next_y + dy) % ymax, (next_x + dx) % xmax\n            if board[next_y, next_x] == \"#\":\n                break\n            y, x = next_y, next_x\nfacings = {(0, 1): 0, (1, 0): 1, (0, -1): 2, (-1, 0): 3}\n(y + 1) * 1000 + 4 * (x + 1) + facings[dy, dx]"
  },
  {
    "objectID": "qmd/2022.html#part-2-21",
    "href": "qmd/2022.html#part-2-21",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWell.\nThe logic for this one is basically the same as for part one, with the only change being what happens when we hit an empty cell. Previously we just kept moving in the same direction until we landed back on the board; now we have to find which edge we should move to.\nI considered trying to solve the edge pairing for all possible cube nets, but quickly concluded that hardcoding the specific net in my input was going to be much faster. I start off by building a mapping of edge pairings which tracks:\n\nWhich pairs of edges are connected\nWhat the rotation between the two edges is\nWhether values along the two edges increase in the same direction. This is technically not necessary, since it’s basically included in the rotation, but it’s handy to have around.\n\nThere are 14 outside edges, but they pair up two and two, so we only need to specify 7 of them and then add the reverse pairing to the mapping.\nThe edges are labelled with an arbitrary number, so we also need a way of identifying which edge we’re on. So for each edge, we’ll specify which two meta-squares of the net it joins, starting with the square on the cube and ending with the square off the cube.\nWhen we hit an empty cell, we identify which edge we just crossed, and then move to the corresponding matching edge. There’s a bit of faffing to make sure that (say) top and bottom edges along the same square get different y coordinates, and then we finally add on how far along the edge we are.\nThat gives us the new position on the grid. If this position is empty, we rotate to face the new direction and move there. Otherwise we stay in place and don’t rotate.\n\n\nCode\nedge_pairings = {\n    0: [9, \"R\", 1],\n    1: [8, \"\", 1],\n    2: [5, \"RR\", -1],\n    3: [4, \"R\", 1],\n    6: [7, \"R\", 1],\n    10: [13, \"RR\", -1],\n    11: [12, \"R\", 1],\n}\n\nfor key in list(edge_pairings.keys()):\n    edge, direction, sign = edge_pairings[key]\n    edge_pairings[edge] = [key, direction.replace(\"R\", \"L\"), sign]\n\nedge_positions = [\n    ((0, 1), (3, 1)),\n    ((0, 2), (3, 2)),\n    ((0, 2), (0, 0)),\n    ((0, 2), (1, 2)),\n    ((1, 1), (1, 2)),\n    ((2, 1), (2, 2)),\n    ((2, 1), (3, 1)),\n    ((3, 0), (3, 1)),\n    ((3, 0), (0, 0)),\n    ((3, 0), (3, 2)),\n    ((2, 0), (2, 2)),\n    ((2, 0), (1, 0)),\n    ((1, 1), (1, 0)),\n    ((0, 1), (0, 0)),\n]\nedge_lookup = {edges: idx for idx, edges in enumerate(edge_positions)}\nboard_shape = np.array([4, 3])\ny, x = 0, start_x\ndy, dx = 0, 1\nfor instruction in instructions:\n    if instruction in \"LR\":\n        dy, dx = matrices[instruction] @ [dy, dx]\n    else:\n        for _ in range(int(instruction)):\n            next_y, next_x = (y + dy) % ymax, (x + dx) % xmax\n            if board[next_y, next_x] == \" \":\n                old_square = y // 50, x // 50\n                new_square = next_y // 50, next_x // 50\n                edge = edge_lookup[(old_square, new_square)]\n                new_edge, rotations, sign = edge_pairings[edge]\n                new_edge_position = edge_positions[new_edge]\n                new_edge_delta = np.diff(new_edge_position, axis=0).ravel()\n                next_y, next_x = [x * 50 for x in new_edge_position[0]]\n                next_y, next_x = [next_y, next_x] + 49 * (\n                    (new_edge_delta % board_shape) == 1\n                )\n                offset = x % 50 if dx == 0 else y % 50\n                offset = offset if sign &gt; 0 else 49 - offset\n                next_y, next_x = [next_y, next_x] + offset * (new_edge_delta == 0)\n                if board[next_y, next_x] != \"#\":\n                    for rotation in rotations:\n                        dy, dx = matrices[rotation] @ [dy, dx]\n            if board[next_y, next_x] == \"#\":\n                break\n            y, x = next_y, next_x\nfacings = {(0, 1): 0, (1, 0): 1, (0, -1): 2, (-1, 0): 3}\n(y + 1) * 1000 + 4 * (x + 1) + facings[dy, dx]"
  },
  {
    "objectID": "qmd/2022.html#part-1-22",
    "href": "qmd/2022.html#part-1-22",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nboard = np.array(\n    [[1 if char == \"#\" else 0 for char in line] for line in load(23)],\n    dtype=bool,\n)\n\n\ndef simulate(board, n_rounds):\n    mask = np.ones((3, 3), dtype=bool)\n    mask[1, 1] = 0\n    n = np.array([[1, 1, 1], [0, 0, 0], [0, 0, 0]])\n    e, s, w = n[::-1].T, n[::-1], n.T\n    Direction = namedtuple(\n        \"Direction\", [\"weights\", \"padding\", \"reverse_move\", \"bitmask\"]\n    )\n    north = Direction(n, [[0, 2], [1, 1]], [1, 0], 1)\n    south = Direction(s, [[2, 0], [1, 1]], [-1, 0], 2)\n    east = Direction(e, [[1, 1], [2, 0]], [0, -1], 4)\n    west = Direction(w, [[1, 1], [0, 2]], [0, 1], 8)\n    directions = [north, south, west, east]\n\n    i = 0\n    while i &lt; n_rounds:\n        i += 1\n        has_neighbors = scipy.ndimage.convolve(board, mask, mode=\"constant\")\n        stopped, rest = (board & (~has_neighbors)), (board & has_neighbors)\n        proposed_moves = np.pad(stopped.astype(int), 1, mode=\"constant\")\n        for d in directions:\n            neighbors = scipy.ndimage.correlate(board, d.weights, mode=\"constant\")\n            proposed_moves += np.pad(\n                (rest & ~neighbors) * d.bitmask, d.padding, mode=\"constant\"\n            )\n            rest &= neighbors\n        proposed_moves += np.pad(rest, 1, mode=\"constant\")\n\n        # Now unwind overlapping moves\n        for d1 in directions[1:]:\n            multiples = ((proposed_moves & d1.bitmask) &gt; 0) & (\n                proposed_moves != d1.bitmask\n            )\n            for point in np.argwhere(multiples):\n                for d2 in directions:\n                    if proposed_moves[tuple(point)] & d2.bitmask:\n                        proposed_moves[tuple(point + d2.reverse_move)] = d2.bitmask\n                proposed_moves[tuple(point)] = 0\n        coords = np.argwhere(proposed_moves)\n        x_min, y_min = coords.min(axis=0)\n        x_max, y_max = coords.max(axis=0)\n        new_board = proposed_moves[x_min : x_max + 1, y_min : y_max + 1] &gt; 0\n        if board.shape == new_board.shape and (board == new_board).all():\n            break\n        board = new_board\n        directions = directions[1:] + [directions[0]]\n    return i, (board == 0).sum()\n\n\nsimulate(board, 10)[1]"
  },
  {
    "objectID": "qmd/2022.html#part-2-22",
    "href": "qmd/2022.html#part-2-22",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsimulate(board, np.inf)[0]"
  },
  {
    "objectID": "qmd/2022.html#part-1-23",
    "href": "qmd/2022.html#part-1-23",
    "title": "2022 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis is a problem that seems to call for some pathfinding algorithms. We can account for the movement of the blizzards by making a function to answer the question “Is there a blizzard at position y, x at time t?”. With that in hand, we can just explore the full search space. To guide the search, we’ll use the (current tiime + manhattan distance to the goal node) as a score and always expand the lowest scoring state first, and stop when we’ve reached the target.\n\n\nCode\nchart = np.array([list(x) for x in load(24)])[1:-1, 1:-1]\nchart_dict = {}\ndirections = [\"&gt;\", \"&lt;\", \"^\", \"v\"]\nupdates = {\"&gt;\": (1, 1), \"&lt;\": (1, -1), \"^\": (0, -1), \"v\": (0, 1)}\nfor direction in directions:\n    positions = defaultdict(list)\n    for y, x in zip(*np.where(chart == direction)):\n        (fixed, moving) = (y, x) if direction in \"&lt;&gt;\" else (x, y)\n        positions[fixed].append(moving)\n    chart_dict[direction] = positions\n\n\ndef has_blizzard(y, x, time):\n    position = y, x\n    for direction in directions:\n        moving, sign = updates[direction]\n        fixed = 1 - moving\n        blizzards = chart_dict[direction][position[fixed]]\n        blizzard_positions = [\n            (b + sign * time) % chart.shape[moving] for b in blizzards\n        ]\n        if position[moving] in blizzard_positions:\n            return True\n    return False\n\n\n\ndef travel(chart, start, end, time):\n    score = abs(end[0] - start[0]) + abs(start[1] - end[1]) + time\n    target_y, target_x = end\n    state = score, time, start\n    q = PriorityQueue()\n    q.put(state)\n    seen = set()\n    while q.qsize() &gt; 0:\n        score, time, (y, x) = q.get()\n        if (y, x) == end:\n            break\n        if (time, y, x) in seen:\n            continue\n        seen.add((time, y, x))\n        for (dy, dx) in [(-1, 0), (0, -1), (0, 0), (0, 1), (1, 0)]:\n            new_y, new_x = y + dy, x + dx\n            if (\n                new_y &lt; -1\n                or (new_y == -1 and new_x != 0)\n                or (new_y &gt; chart.shape[0])\n                or (new_y == chart.shape[0] and new_x != chart.shape[1] - 1)\n                or new_x &lt; 0\n                or new_x &gt;= chart.shape[1]\n                or has_blizzard(new_y, new_x, time + 1)\n\n            ):\n                continue\n            score = abs(target_y - new_y) + abs(target_x - new_x) + time + 1\n            q.put((score, time + 1, (new_y, new_x)))\n    return score\n\nbottom_y, right_x = chart.shape\nstart = (-1, 0)\nend = (bottom_y, right_x - 1)\nfirst_leg = travel(chart, start, end, 0)\nfirst_leg"
  },
  {
    "objectID": "qmd/2022.html#part-2-23",
    "href": "qmd/2022.html#part-2-23",
    "title": "2022 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe above takes ~7 seconds on my machine (and it took 13 before I added the A* scoring logic), so using it to do three searches through the search space might not be feasible. On the other hand, the three searches can be made completely independent of one another, since arriving later at a checkpoint will always be worse than arriving earlier, since an early arrival could always wait in place until the later time.\n\n\nCode\ntime = first_leg\nwaypoints = [(-1, 0), (bottom_y, right_x - 1)]\nfor waypoint in waypoints:\n    start = end\n    end = waypoint\n    time = travel(chart, start, end, time)\ntime\n\n\nThis actually works, but it still seems like there should be some slick-ish way of using the chinese remainder theorem or something similar to greatly reduce the search space, since we basically have four masks of residues that are invalid for (y, x, t) triples."
  },
  {
    "objectID": "qmd/2020.html",
    "href": "qmd/2020.html",
    "title": "2020 Solutions",
    "section": "",
    "text": "Code\nimport functools\nimport itertools\nimport os\nimport re\nimport sys\nfrom collections import defaultdict, deque\n\nimport numpy as np\nimport scipy\n\nsys.path.insert(1, os.path.join(sys.path[0], \"..\"))\nimport utils\n\nload = utils.year_load(2020)"
  },
  {
    "objectID": "qmd/2020.html#part-1",
    "href": "qmd/2020.html#part-1",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(1, \"np\")\n[pair[0] * pair[1] for pair in itertools.product(data, data) if sum(pair) == 2020][0]"
  },
  {
    "objectID": "qmd/2020.html#part-2",
    "href": "qmd/2020.html#part-2",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\n[\n    triple[0] * triple[1] * triple[2]\n    for triple in itertools.product(data, data, data)\n    if sum(triple) == 2020\n][0]"
  },
  {
    "objectID": "qmd/2020.html#part-1-1",
    "href": "qmd/2020.html#part-1-1",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndef is_valid(interval, letters, password):\n    interval = [int(x) for x in interval.split(\"-\")]\n    occurrences = password.count(letters[0])\n    return interval[0] &lt;= occurrences &lt;= interval[1]\n\n\nlines = load(2)\nsum([is_valid(*line.split()) for line in lines])"
  },
  {
    "objectID": "qmd/2020.html#part-2-1",
    "href": "qmd/2020.html#part-2-1",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nfrom operator import xor\n\n\ndef is_valid(interval, letters, password):\n    lower, upper = [int(x) - 1 for x in interval.split(\"-\")]\n    return xor(password[lower] == letters[0], password[upper] == letters[0])\n\n\nsum([is_valid(*line.split()) for line in lines])"
  },
  {
    "objectID": "qmd/2020.html#part-1-2",
    "href": "qmd/2020.html#part-1-2",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = np.array([[0 if char == \".\" else 1 for char in line] for line in load(3)])\n\n\ndef count_trees(data, width_change, height_change):\n    height, width = data.shape\n    result = 0\n    for i in range((height - 1) // height_change + 1):\n        result += data[i * height_change, (i * width_change) % width]\n    return result\n\n\ncount_trees(data, 3, 1)"
  },
  {
    "objectID": "qmd/2020.html#part-2-2",
    "href": "qmd/2020.html#part-2-2",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nslopes = [[1, 1], [3, 1], [5, 1], [7, 1], [1, 2]]\nnp.prod([count_trees(data, slope[0], slope[1]) for slope in slopes])"
  },
  {
    "objectID": "qmd/2020.html#part-1-3",
    "href": "qmd/2020.html#part-1-3",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(4, \"raw\")\npassports = data.split(\"\\n\\n\")\npassport_dicts = [\n    dict(list(map(lambda x: x.split(\":\"), p.replace(\"\\n\", \" \").split())))\n    for p in passports\n]\nsum([len(set(p.keys()) - set([\"cid\"])) == 7 for p in passport_dicts])"
  },
  {
    "objectID": "qmd/2020.html#part-2-3",
    "href": "qmd/2020.html#part-2-3",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ndef validate_key(key, value):\n    year_limits = {\"byr\": [1920, 2002], \"eyr\": [2020, 2030], \"iyr\": [2010, 2020]}\n    try:\n        if key in [\"byr\", \"eyr\", \"iyr\"]:\n            minval, maxval = year_limits[key]\n            return minval &lt;= int(value) &lt;= maxval\n        if key == \"hgt\":\n            value, unit = int(value[:-2]), value[-2:]\n            return (unit == \"cm\" and (150 &lt;= value &lt;= 193)) or (\n                unit == \"in\" and (59 &lt;= value &lt;= 76)\n            )\n        if key == \"hcl\":\n            return (\n                value[0] == \"#\"\n                and len(value) == 7\n                and not (set(value[1:]) - set(\"0123456789abcdef\"))\n            )\n        if key == \"ecl\":\n            return value in [\"amb\", \"blu\", \"brn\", \"gry\", \"grn\", \"hzl\", \"oth\"]\n        if key == \"pid\":\n            test = int(value)\n            return len(value) == 9\n        return True\n    except ValueError:\n        return False\n\n\ndef is_valid_passport(p):\n    return len(set(p.keys()) - set([\"cid\"])) == 7 and all(\n        [validate_key(key, p[key]) for key in p]\n    )\n\n\nsum([is_valid_passport(p) for p in passport_dicts])"
  },
  {
    "objectID": "qmd/2020.html#part-1-4",
    "href": "qmd/2020.html#part-1-4",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\n# \"BFFFBBFRRR\" -&gt; 70, column 7 -&gt; 567\ndef seat_id(instruction):\n    return int(instruction.translate(str.maketrans(\"BFRL\", \"1010\")), 2)\n\n\nseat_ids = [seat_id(x) for x in load(5)]\nmax(seat_ids)"
  },
  {
    "objectID": "qmd/2020.html#part-2-4",
    "href": "qmd/2020.html#part-2-4",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\n(set(range(min(seat_ids), max(seat_ids) + 1)) - set(seat_ids)).pop()"
  },
  {
    "objectID": "qmd/2020.html#part-1-5",
    "href": "qmd/2020.html#part-1-5",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(6, \"raw\")\ngroups = data.split(\"\\n\\n\")\nsum(len(set(list(group.replace(\"\\n\", \"\")))) for group in groups)"
  },
  {
    "objectID": "qmd/2020.html#part-2-5",
    "href": "qmd/2020.html#part-2-5",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsum(\n    len(functools.reduce(lambda x, y: set(x) & set(y), (group.splitlines())))\n    for group in groups\n)"
  },
  {
    "objectID": "qmd/2020.html#part-1-6",
    "href": "qmd/2020.html#part-1-6",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\nNothing super groundbreaking for part one. I thought of using a regex to parse the input, but splitting on commas and then into words works just fine.\n\n\nCode\ndata = load(7)\ntree = {}\nfor line in data:\n    bag, contents = line.split(\" bags contain \")\n    if \"no other\" in contents:\n        contents = {}\n    else:\n        elements = contents.split(\", \")\n        contents = {\n            \" \".join(words[1:-1]): int(words[0]) for words in map(str.split, elements)\n        }\n    tree[bag] = contents\n\n\n@functools.cache\ndef contains_gold(key):\n    return \"shiny gold\" in tree[key] or any(contains_gold(child) for child in tree[key])\n\n\nsum(contains_gold(key) for key in tree)"
  },
  {
    "objectID": "qmd/2020.html#part-2-6",
    "href": "qmd/2020.html#part-2-6",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe key thing to remember is to include the bag itself, as well as the bags it contains, when calculating the total. That’s what the “+1” is for in the sum\n\n\nCode\n@functools.cache\ndef count_bags(bag):\n    return sum(tree[bag][key] * (count_bags(key) + 1) for key in tree[bag])\n\n\ncount_bags(\"shiny gold\")"
  },
  {
    "objectID": "qmd/2020.html#part-1-7",
    "href": "qmd/2020.html#part-1-7",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = [x.split() for x in load(8)]\ndata = [(x[0], int(x[1])) for x in data]\n\n\ndef terminal_run(program):\n    ip, accumulator = 0, 0\n    seen = {}\n    while ip != len(program):\n        if ip in seen:\n            return False, accumulator\n        seen[ip] = 1\n        instruction, operand = program[ip]\n        ip += 1\n        if instruction == \"jmp\":\n            ip += operand - 1\n        if instruction == \"acc\":\n            accumulator += operand\n    return True, accumulator\n\n\nterminal_run(data)[1]"
  },
  {
    "objectID": "qmd/2020.html#part-2-7",
    "href": "qmd/2020.html#part-2-7",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\ninstruction_map = {\"acc\": \"acc\", \"jmp\": \"nop\", \"nop\": \"jmp\"}\nfor idx, instruction in enumerate(data):\n    new_instruction = (instruction_map[instruction[0]], instruction[1])\n    status, value = terminal_run(data[:idx] + [new_instruction] + data[idx + 1 :])\n    if status:\n        break\nvalue"
  },
  {
    "objectID": "qmd/2020.html#part-1-8",
    "href": "qmd/2020.html#part-1-8",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = list(load(9, \"np\"))\nend = len(data) - 25\nfor window_start in range(end):\n    target = data[window_start + 25]\n    if (\n        min(\n            map(\n                lambda x: abs(target - sum(x)),\n                itertools.combinations(data[window_start : window_start + 25], 2),\n            )\n        )\n        != 0\n    ):\n        break\ninvalid_number = target\ninvalid_number"
  },
  {
    "objectID": "qmd/2020.html#part-2-8",
    "href": "qmd/2020.html#part-2-8",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nstart_idx, end_idx = 0, 1\nwhile start_idx &lt; len(data):\n    total = sum(data[start_idx:end_idx])\n    if total == invalid_number:\n        break\n    if total &lt; invalid_number:\n        end_idx += 1\n    if total &gt; invalid_number:\n        start_idx += 1\n        end_idx = start_idx + 1\nmin(data[start_idx:end_idx]) + max(data[start_idx:end_idx])"
  },
  {
    "objectID": "qmd/2020.html#part-1-9",
    "href": "qmd/2020.html#part-1-9",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = [0] + sorted((load(10, \"np\")))\n(np.diff(data) == 1).sum() * ((np.diff(data) == 3).sum() + 1)"
  },
  {
    "objectID": "qmd/2020.html#part-2-9",
    "href": "qmd/2020.html#part-2-9",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nSorting the values, we see a series of jumps of 1 and jumps of 3. If the value is allowed to jump by at most 3 every time, then we have to include both sides of every jump of 3.\nThe only interesting thing is then what to do with runs of 1 jumps. In general, we can count the number of ways, \\(f\\), as follows\n\\(f(n) = f(n - 1) + g(n-1)\\)\nThe first term comes from saying that we pick the first element, leaving us with a run of length \\((n - 1)\\), exactly as before. The second comes from saying that we skip the first element, and now have to find the number of ways of choosing for a series of gaps starting with \\(2\\), followed by \\(n - 2\\) ones. Similarly\n\\(g(n - 1) = f(n - 2) + f(n - 3)\\)\nIf we pick the element that resulted in a gap of two, then we just have to choose from a run of n - 2 ones, which is the \\(f\\) we are looking at. If we don’t pick it, we’ve created a gap of size \\(3\\) - but then we are forced to pick the next element, leaving us with a run of length \\(n - 3\\) to distribute.\nPutting everything together gives the recurrence\n\\(f(n) = f(n - 1) + f(n - 2) + f(n - 3)\\),\nwith initial conditions \\(f(0) = 1\\), \\(f(-1) = 0\\), \\(f(-2) = 0\\).\nThat recurrence can be written in matrix form as\n\\[\n\\begin{pmatrix}\n1 & 1 & 1 \\\\\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n\\end{pmatrix}\\]\nAnd iterating the function is then just a question of matrix powers\n\n\nCode\ndef total_ways(n_ones):\n    matrix = np.array([[1, 1, 1], [1, 0, 0], [0, 1, 0]])\n    return (np.linalg.matrix_power(matrix, n_ones) @ [1, 0, 0])[0]\n\n\nnp.product(\n    [total_ways(len(x)) for x in \"\".join(str(x) for x in np.diff(data)).split(\"3\")]\n)"
  },
  {
    "objectID": "qmd/2020.html#part-1-10",
    "href": "qmd/2020.html#part-1-10",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\nFor the first part, we are taking the convolution of our original grid with a weights array that looks like \\[\n\\begin{pmatrix}\n1 & 1 & 1\\\\\n1 & 0 & 1\\\\\n1 & 1 & 1\\\\\n\\end{pmatrix}\n\\] Scipy has nice routines that handle all that indexing for us, so we’ll cheat and use them. The only slight issue is what to do at the edge of the grid, but using a constant value of 0 for any cells that would fall outside the grid works out of the box.\n\n\nCode\ndata = np.array([[1 if char == \".\" else 0 for char in line] for line in load(11)])\nmask = np.where(data)\nboard = np.zeros(data.shape, dtype=int)\nnew_board = np.ones(board.shape, dtype=int)\nnew_board[mask] = 0\nweights = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nwhile (board != new_board).any():\n    board = new_board.copy()\n    convolution = scipy.ndimage.convolve(new_board, weights, mode=\"constant\")\n    new_board[np.where(convolution == 0)] = 1\n    new_board[np.where(convolution &gt;= 4)] = 0\n    new_board[mask] = 0\nboard.sum()"
  },
  {
    "objectID": "qmd/2020.html#part-2-10",
    "href": "qmd/2020.html#part-2-10",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2 I was unable to find a nice way of expressing the condition of “Look for the first grid position in a given direction which is not floor”. That means that I have to manually loop over the grid instead of using the convolution routine - and that really slows down the runtime!\n\n\nCode\nboard = np.zeros(data.shape, dtype=int)\nnew_board = np.ones(board.shape, dtype=int)\nnew_board[mask] = 0\n\n\ndef update(board):\n    new_board = board.copy()\n    directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    for row, col in itertools.product(*[range(x) for x in board.shape]):\n        total = 0\n        for direction in directions:\n            done = False\n            new_row, new_col = row, col\n            while not done:\n                new_row, new_col = new_row + direction[0], new_col + direction[1]\n                if (\n                    new_row &lt; 0\n                    or new_row &gt;= board.shape[0]\n                    or new_col &lt; 0\n                    or new_col &gt;= board.shape[1]\n                ):\n                    break\n                if not data[new_row, new_col]:\n                    done = True\n            else:  # no break - so a valid position\n                total += board[new_row, new_col]\n        if total == 0:\n            new_board[row, col] = 1\n        if total &gt;= 5:\n            new_board[row, col] = 0\n    new_board[mask] = 0\n    return new_board\n\n\nwhile (new_board != board).any():\n    board = new_board\n    new_board = update(new_board)\nnew_board.sum()"
  },
  {
    "objectID": "qmd/2020.html#part-1-11",
    "href": "qmd/2020.html#part-1-11",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\nI’ll use the usual trick of modelling the 2d grid as the complex plane.\n\n\nCode\ndirections = {\"N\": 1j, \"E\": 1, \"S\": -1j, \"W\": -1}\nturns = {\"L\": 1j, \"R\": -1j}\nposition, direction = 0, 1\n\n\ndef update_state(position, direction, instruction, value, part=1):\n    if instruction in directions:\n        offset = directions[instruction] * value\n        return (\n            (position + offset, direction)\n            if part == 1\n            else (position, direction + offset)\n        )\n    if instruction in turns:\n        return position, direction * turns[instruction] ** (int(value // 90))\n    return position + value * direction, direction\n\n\ninstructions = load(12)\nfor instruction, value in map(lambda x: (x[0], int(x[1:])), instructions):\n    position, direction = update_state(position, direction, instruction, value)\nint(abs(position.real) + abs(position.imag))"
  },
  {
    "objectID": "qmd/2020.html#part-2-11",
    "href": "qmd/2020.html#part-2-11",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nPart 2 can be done basically the same way as part 1, with only a small change to the update state function. In part 1, nesw move the ship; in part 2 they move the waypoint. Everything else is the same.\n\n\nCode\nposition, waypoint = 0, 10 + 1j\nfor instruction, value in map(lambda x: (x[0], int(x[1:])), instructions):\n    position, waypoint = update_state(position, waypoint, instruction, value, part=2)\nint(abs(position.real) + abs(position.imag))"
  },
  {
    "objectID": "qmd/2020.html#part-1-12",
    "href": "qmd/2020.html#part-1-12",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis one looks like a bunch of modular arithmetic. The first one is just whichever bus number n has the smallest -x (mod n)\n\n\nCode\nx = 1006726\nbuses = (\n    \"23,x,x,x,x,x,x,x,x,x,x,x,x,41,x,x,x,x,x,x,x,x,x,647,\"\n    \"x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,13,19,x,x,x,x,x,x,x\"\n    \",x,x,29,x,557,x,x,x,x,x,37,x,x,x,x,x,x,x,x,x,x,17\"\n)\nbus_moduli = [\n    (int(_), (-idx) % int(_)) for idx, _ in enumerate(buses.split(\",\")) if _ != \"x\"\n]\nbus_numbers = [n for n, a in bus_moduli]\nwaits = [-x % bus for bus in bus_numbers]\nmin(waits) * bus_numbers[np.argmin(waits)]"
  },
  {
    "objectID": "qmd/2020.html#part-2-12",
    "href": "qmd/2020.html#part-2-12",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor the second, it’s the Chinese remainder theorem to the rescue. Code shamelessly copied from wikipedia.\n\n\nCode\nfrom utils import crt\n\ncrt(bus_moduli)"
  },
  {
    "objectID": "qmd/2020.html#part-1-13",
    "href": "qmd/2020.html#part-1-13",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = [line.split(\" = \") for line in load(14)]\nresult = defaultdict(int)\nmask = \"\"\nfor operation, operand in data:\n    if operation == \"mask\":\n        mask = operand\n    else:\n        new_operand = \"\".join(\n            [b1 if (b1 != \"X\") else b2 for b1, b2 in zip(mask, f\"{int(operand):036b}\")]\n        )\n        result[operation[4:-1]] = int(new_operand, 2)\nsum(result.values())\n\n\n\n\nCode\nresult = defaultdict(int)\nmask = \"\"\nfor operation, operand in data:\n    if operation == \"mask\":\n        mask = operand\n    else:\n        operand = int(operand)\n        operation = operation[4:-1]\n        addresses = [\"\"]\n        for b1, b2 in zip(mask, f\"{int(operation):036b}\"):\n            if b1 == \"X\":\n                addresses = [a + \"0\" for a in addresses] + [a + \"1\" for a in addresses]\n            elif b1 == \"1\":\n                addresses = [a + \"1\" for a in addresses]\n            else:\n                addresses = [a + b2 for a in addresses]\n        for address in addresses:\n            result[int(address, 2)] = operand\nsum(result.values())"
  },
  {
    "objectID": "qmd/2020.html#part-1-14",
    "href": "qmd/2020.html#part-1-14",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nprefix = load(15, \"int\")[0]\nstate = {i: idx + 1 for idx, i in enumerate(prefix[:-1])}\ncurrent = prefix[-1]\n\n\ndef update(current, i):\n    if current not in state:\n        next_n = 0\n    else:\n        next_n = i - state[current]\n    state[current] = i\n    return next_n\n\n\nn_turns = 2020\nfor i in range(len(prefix), n_turns):\n    current = update(current, i)\ncurrent"
  },
  {
    "objectID": "qmd/2020.html#part-2-13",
    "href": "qmd/2020.html#part-2-13",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\n30 million is just within range where brute force would be plausible. Let’s try it:\n\n\nCode\nfor i in range(n_turns, 30_000_000):\n    current = update(current, i)\ncurrent"
  },
  {
    "objectID": "qmd/2020.html#part-1-15",
    "href": "qmd/2020.html#part-1-15",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\nI could do this by trying to merge ranges of valid values. Or I could just instantiate a set with every valid value…\n\n\nCode\ndata = load(16, \"raw\")\nrules, own, nearby = data[:-1].split(\"\\n\\n\")\nvalid = set()\nfor rule in rules.split(\"\\n\"):\n    limits = [int(x) for x in re.findall(r\"\\d+\", rule)]\n    for lower, upper in zip(limits[::2], limits[1::2]):\n        valid |= set(range(lower, upper + 1))\nsum(\n    map(\n        lambda x: 0 if int(x) in valid else int(x),\n        nearby[nearby.index(\"\\n\") + 1 :].replace(\"\\n\", \",\").split(\",\"),\n    )\n)"
  },
  {
    "objectID": "qmd/2020.html#part-2-14",
    "href": "qmd/2020.html#part-2-14",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nI’m not entirely surprised that that’s where he went for part 2\n\n\nCode\nranges = defaultdict(set)\nfor rule in rules.split(\"\\n\"):\n    name, _ = rule.split(\":\")\n    limits = [int(x) for x in re.findall(r\"\\d+\", rule)]\n    for lower, upper in zip(limits[::2], limits[1::2]):\n        ranges[name] |= set(range(lower, upper + 1))\nown_ticket = [int(x) for x in own.split(\"\\n\")[1].split(\",\")]\nnearby_tickets = [[int(x) for x in line.split(\",\")] for line in nearby.split(\"\\n\")[1:]]\nnearby_tickets = np.array([x for x in nearby_tickets if all(y in valid for y in x)])\nassignments = [0] * len(own_ticket)\nwhile ranges:\n    for column in range(len(assignments)):\n        if assignments[column]:\n            continue\n        candidates = [\n            key\n            for key in ranges.keys()\n            if all(x in ranges[key] for x in nearby_tickets[:, column])\n        ]\n        if len(candidates) == 1:\n            assignments[column] = candidates[0]\n            del ranges[candidates[0]]\nnp.product(\n    [\n        own_ticket[idx]\n        for idx, assignment in enumerate(assignments)\n        if \"departure\" in assignment\n    ]\n)"
  },
  {
    "objectID": "qmd/2020.html#part-1-16",
    "href": "qmd/2020.html#part-1-16",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis looks like another good time to use scipy’s handy correlate/convolve functions. At some point I should probably learn what the difference between those two is.\n\n\nCode\ndata = np.array(\n    [[1 if char == \"#\" else 0 for char in line] for line in load(17)], dtype=int\n)\n\n\ndef simulate(data, dimensions=3, ncycles=6):\n    weights = np.ones((3,) * dimensions)\n    missing_dimensions = dimensions - len(data.shape)\n    data = data.reshape(data.shape + (1,) * missing_dimensions)\n    data = np.pad(data, ncycles)\n    for i in range(ncycles):\n        convolution = scipy.ndimage.correlate(data, weights, mode=\"constant\")\n        data = (convolution == 3) | ((convolution == 4) & data)\n    return data.sum()\n\n\nsimulate(data)"
  },
  {
    "objectID": "qmd/2020.html#part-2-15",
    "href": "qmd/2020.html#part-2-15",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\n\n\nCode\nsimulate(data, 4)"
  },
  {
    "objectID": "qmd/2020.html#part-1-17",
    "href": "qmd/2020.html#part-1-17",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nimport string\n\noperators = {\"*\": lambda x, y: x * y, \"+\": lambda x, y: x + y}\n\n\ndef find_closing_paren(s):\n    assert s[0] == \"(\"\n    count = 0\n    for idx, char in enumerate(s):\n        count += 1 if char == \"(\" else -1 if char == \")\" else 0\n        if count == 0:\n            return idx + 1\n\n\ndef evaluate(expression, part=1):\n    i = 0\n    ops = deque()\n    operands = deque()\n    while i &lt; len(expression):\n        char = expression[i]\n        if char in \"+*\":\n            ops.append(char)\n            i += 1\n            continue\n        if char == \"(\":\n            delta = find_closing_paren(expression[i:])\n            operands.append(evaluate(expression[i + 1 : i + delta - 1], part=part))\n            i += delta\n        elif char in string.digits:\n            operands.append(int(char))\n            i += 1\n\n        if part == 2 and ops and ops[-1] == \"+\":\n            ops.pop()\n            operands.append(operands.pop() + operands.pop())\n\n    while ops:\n        op = ops.popleft()\n        operands.appendleft(operators[op](operands.popleft(), operands.popleft()))\n    return operands.pop()\n\n\nlines = [x.replace(\" \", \"\") for x in load(18)]\nsum(evaluate(line) for line in lines)"
  },
  {
    "objectID": "qmd/2020.html#part-2-16",
    "href": "qmd/2020.html#part-2-16",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe change for part 2 is so small that it can be included in part 1 as a flag\n\n\nCode\nsum(evaluate(line, part=2) for line in lines)"
  },
  {
    "objectID": "qmd/2020.html#part-1-18",
    "href": "qmd/2020.html#part-1-18",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(19, \"raw\")\nrelations, strings = map(lambda x: x.split(\"\\n\"), data.split(\"\\n\\n\"))\ndependencies = {}\nrules = {}\nfor relation in relations:\n    lhs, rhs = relation.split(\":\")\n    rules[int(lhs)] = (\n        {rhs.replace('\"', \"\").strip()}\n        if '\"' in rhs\n        else {tuple([int(y) for y in x.split()]) for x in rhs.split(\"|\")}\n    )\n\ndependencies = {\n    x: set().union(*rules[x]) if x not in [54, 20] else set() for x in rules\n}\n\n\ndef concat(l1, l2):\n    return {s1 + s2 for s1 in l1 for s2 in l2}\n\n\ndef expand(rule, rules, mappings):\n    result = set()\n    for option in rules[rule]:\n        if isinstance(option, str):\n            return rules[rule]\n        new_elements = (\n            mappings[option[0]]\n            if len(option) == 1\n            else concat(*[mappings[i] for i in option])\n        )\n        result |= new_elements\n    return result\n\n\ndef free_elements(mydict):\n    return [x for x in mydict if not mydict[x]]\n\n\nmappings = {}\nwhile dependencies:\n    k1 = free_elements(dependencies)[0]\n    mappings[k1] = expand(k1, rules, mappings)\n    for k2 in dependencies:\n        dependencies[k2].discard(k1)\n    del dependencies[k1]\nlen(list(filter(lambda x: x in mappings[0], strings[:-1])))"
  },
  {
    "objectID": "qmd/2020.html#part-2-17",
    "href": "qmd/2020.html#part-2-17",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nWe have loops now! Analysing the new rules, we see that the system should accept all strings of the form 42m 13n, with m &gt; n &gt; 0. Looking at the previous part shows that rule 42 and rule 31 never overlap, and all the strings they match have length 8. That gives the following logic for part 2:\n\n\nCode\nfrom more_itertools import chunked\n\n\ndef part2(s):\n    chunks = [\"\".join(x).strip() for x in chunked(s, 8)]\n    r42, r31 = 0, 0\n    while chunks[r42] in mappings[42]:\n        r42 += 1\n        if r42 == len(chunks):\n            break\n    while r42 + r31 &lt; len(chunks):\n        if chunks[r42 + r31] not in mappings[31]:\n            break\n        r31 += 1\n\n    return r31 &gt;= 1 and r42 &gt; r31 and r42 + r31 == len(chunks)\n\n\nsum(part2(s) for s in strings[:-1])"
  },
  {
    "objectID": "qmd/2020.html#part-1-19",
    "href": "qmd/2020.html#part-1-19",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = load(20, \"raw\").split(\"\\n\\n\")\ndata[0]\ntiles = {}\n\n\ndef edge_hashes(t):\n    edges = [\n        t[0],\n        t[0][::-1],\n        t[:, -1],\n        t[:, -1][::-1],\n        t[-1][::-1],\n        t[-1],\n        t[:, 0][::-1],\n        t[:, 0],\n    ]\n    return {\n        idx: functools.reduce(lambda x, y: 2 * x + y, edge[::-1])\n        for idx, edge in enumerate(edges)\n    }\n\n\ndef fingerprint(tile):\n    return tile, edge_hashes(tile), {v: k for k, v in edge_hashes(tile).items()}\n\n\nfor entry in data:\n    header, *tile = entry.split(\"\\n\")\n    tile = np.array(\n        [[1 if char == \"#\" else 0 for char in line] for line in tile if line],\n        dtype=\"int\",\n    )\n    tile_id = int(re.findall(r\"\\d+\", header)[0])\n    tiles[tile_id] = fingerprint(tile)\nmatches = defaultdict(set)\nkeys = sorted(tiles.keys())\nfor x in range(len(keys)):\n    for y in range(x + 1, len(keys)):\n        if set(tiles[keys[x]][1].values()) & set(tiles[keys[y]][1].values()):\n            matches[keys[x]].add(keys[y])\n            matches[keys[y]].add(keys[x])\ncorners = [x for x in matches if len(matches[x]) == 2]\nnp.product(corners)"
  },
  {
    "objectID": "qmd/2020.html#part-2-18",
    "href": "qmd/2020.html#part-2-18",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nDirect inspection shows that there are no false matches in the edge pairings, so we can proceed to place all the tiles without taking that into account. We’ll start by placing the tiles in the correct location without worrying about their orientation, and then rotate and flip them afterwards.\nThere are eight possible ways to fill the board (four different corners to put in the top left, and then for each of those, two different choices for how to flip around the main diagonal), so we’ll arbitrarily pick one of them.\nWe’ll start by placing a corner piece in the top left, and then one of its neighbors below it.\nWhen we place a tile, we mark the candidates for its unplaced neighbors: these are the intersection of whatever candidates were there before, and the unplaced matches of the current tile. We also remove the current tile as a candidate from any other open location, since it’s just been placed. Whenever a location has only one candidate, we can place that, and proceed until the whole board is filled.\n\n\nCode\ncorner = corners[0]\nmatch = next(iter(matches[corner]))\nlocations = defaultdict(lambda: set(keys))\nplaced = set()\n\n\ndef place(tile, location):\n    locations[location] = tile\n    placed.add(tile)\n    x, y = location\n    if x &lt; 11 and isinstance(locations[x + 1, y], set):\n        locations[x + 1, y] &= matches[tile] - placed\n    if y &lt; 11 and isinstance(locations[x, y + 1], set):\n        locations[x, y + 1] &= matches[tile] - placed\n    to_place = []\n    for location in locations:\n        if isinstance(locations[location], set):\n            locations[location].discard(tile)\n            if len(locations[location]) == 1:\n                to_place.append(location)\n    for placement in to_place:\n        if isinstance(locations[placement], set):\n            place(next(iter(locations[placement])), placement)\n\n\nplace(corner, (0, 0))\nplace(match, (1, 0))\ncoords = np.zeros((12, 12), dtype=int)\nfor location in locations:\n    coords[location] = locations[location]\n\n\nWith that out of the way, we need to orient the tiles correctly. We start by making sure the top left corner is oriented correctly, and then we match all of the other tiles to that structure.\nFor each row in the grid, we match the first cell to the first cell in the row above, and then we match all the other cells to the neighbor to their left.\n\n\nCode\n# start off by making sure that the right hand side matches\noverlap = [\n    tiles[coords[0, 0]][2][key]\n    for key in set(tiles[coords[0, 0]][2].keys()) & set(tiles[coords[0, 1]][2].keys())\n][0]\ndelta = (((overlap - overlap % 2) - 2) // 2) % 4\nif delta:\n    tile = np.rot90(tiles[coords[0, 0]][0], -delta)\n    tiles[coords[0, 0]] = fingerprint(tile)\n# Then check if the bottom of the tile is the one that matches [1, 0]. If not, flip it vertically.\noverlap = [\n    tiles[coords[0, 0]][2][key]\n    for key in set(tiles[coords[0, 0]][2].keys()) & set(tiles[coords[1, 0]][2].keys())\n][0]\nif overlap // 2 != 2:\n    tile = tile[::-1]\n    tiles[coords[0, 0]] = fingerprint(tile)\n\n\nAll the edges are labelled (not well, but they are labelled). To be oriented correctly, the 7 edge on a tile should match the 2 edge on the tile to its left, and/or the 0 edge on a tile should match the 5 edge on the tile above it.\n\n\nCode\nfor y in range(12):\n    for x in range(12):\n        if not x and not y:\n            continue\n        tile = tiles[coords[y, x]][0]\n        if not x:\n            old_edge = 5\n            target = 0\n            comparison = (y - 1, x)\n        else:\n            old_edge = 2\n            target = 7\n            comparison = (y, x - 1)\n        value = tiles[coords[comparison]][1][old_edge]\n        current = tiles[coords[y, x]][2][value]\n        if (target - current) % 2:\n            tile = tile.T\n            current = 7 - current\n        rotation = (current - target) // 2\n        tile = np.rot90(tile, rotation)\n        tiles[coords[y, x]] = fingerprint(tile)\n\n\nWe can now reconstruct the board, and go hunting for the sea monsters. The convolve/correlate functions are handy here as well, since we’re looking for an area where all of a subset of the neighboring cells are lit up. So we correlate with that mask, and check which correlations have the full set.\nThe following code will fail if any of the sea monsters overlap, but luckily they don’t.\n\n\nCode\nboard = np.zeros((8 * 12, 8 * 12), dtype=int)\nfor y in range(12):\n    for x in range(12):\n        board[y * 8 : (y + 1) * 8, x * 8 : (x + 1) * 8] = tiles[coords[y, x]][0][\n            1:-1, 1:-1\n        ]\npattern = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1],\n    [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0],\n]\n\ntotal = np.sum(pattern)\nmonsters = 0\nfor reflection in range(2):\n    for rotation in range(4):\n        convolution = scipy.ndimage.correlate(board, pattern, mode=\"constant\")\n        monsters += (convolution == total).sum()\n        board = np.rot90(board)\n    board = board.T\nboard.sum() - monsters * 15"
  },
  {
    "objectID": "qmd/2020.html#part-1-20",
    "href": "qmd/2020.html#part-1-20",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\nNice and easy one today, with just a bit of set intersection logic\n\n\nCode\ncounts = defaultdict(int)\nmappings = {}\nfor line in load(21):\n    ingredients, allergens = [\n        x.split() for x in line[:-2].replace(\",\", \"\").split(\"(contains\")\n    ]\n    for ingredient in ingredients:\n        counts[ingredient] += 1\n    for allergen in allergens:\n        if allergen in mappings:\n            mappings[allergen] &= set(ingredients)\n        else:\n            mappings[allergen] = set(ingredients)\npotential_allergens = set().union(*mappings.values())\nsum(counts[x] for x in counts if x not in potential_allergens)"
  },
  {
    "objectID": "qmd/2020.html#part-2-19",
    "href": "qmd/2020.html#part-2-19",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nAnd part 2 isn’t much harder. Any allergens which have only one matching ingredient are fixed; and this ingredient can then be removed from all the other allergens. And then it’s a question of continuing until we have the full map\n\n\nCode\nassignments = {}\nassignable = {x for x in mappings if len(mappings[x]) == 1}\nwhile mappings:\n    key = assignable.pop()\n    value = mappings[key].pop()\n    del mappings[key]\n    assignments[key] = value\n    for mapping in mappings:\n        mappings[mapping].discard(value)\n        if len(mappings[mapping]) == 1:\n            assignable.add(mapping)\nprint(\",\".join(assignments[x] for x in sorted(list(assignments.keys()))))"
  },
  {
    "objectID": "qmd/2020.html#part-1-21",
    "href": "qmd/2020.html#part-1-21",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\np1, p2 = map(deque, np.array(load(22, \"int\")).reshape(2, -1)[:, 1:])\nwhile p1 and p2:\n    c1, c2 = p1[0], p2[0]\n    p1.rotate(-1)\n    p2.rotate(-1)\n    winner, loser = (p1, p2) if (c1 &gt; c2) else (p2, p1)\n    winner.append(loser.pop())\nresult = p1 if p1 else p2\n(np.array(result) * (np.arange(len(result)) + 1)[::-1]).sum()"
  },
  {
    "objectID": "qmd/2020.html#part-2-20",
    "href": "qmd/2020.html#part-2-20",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nA fairly straightforward recursive implementation of the requirements\n\n\nCode\np1, p2 = map(deque, np.array(load(22, \"int\")).reshape(2, -1)[:, 1:])\n\n\ndef play(p1, p2):\n    seen = set()\n    while p1 and p2:\n        hashed = (tuple(p1), tuple(p2))\n        if hashed in seen:\n            return 1, 0\n        seen.add(hashed)\n        c1, c2 = p1[0], p2[0]\n        p1.rotate(-1)\n        p2.rotate(-1)\n        if c1 &lt; len(p1) and c2 &lt; len(p2):\n            new_p1 = deque(list(p1)[:c1])\n            new_p2 = deque(list(p2)[:c2])\n            recursive_battle = play(new_p1, new_p2)\n            winner, loser = (p1, p2) if recursive_battle[0] else (p2, p1)\n        else:\n            winner, loser = (p1, p2) if (c1 &gt; c2) else (p2, p1)\n        winner.append(loser.pop())\n    return p1, p2\n\n\nresult = play(p1, p2)\nresult = result[0] if result[0] else result[1]\n(np.array(result) * np.arange(1, len(result) + 1)[::-1]).sum()"
  },
  {
    "objectID": "qmd/2020.html#part-1-22",
    "href": "qmd/2020.html#part-1-22",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\ndata = [int(x) for x in \"583976241\"]\ns = deque(data)\nl = len(s)\nfor _ in range(100):\n    target = (s[0] - 2) % l + 1\n    s.rotate(-1)\n    pickup = [s.popleft() for i in range(3)]\n    while target in pickup:\n        target = (target - 2) % l + 1\n\n    count = 0\n    while s[0] != target:\n        s.rotate(-1)\n        count += 1\n    s.rotate(-1)\n    for value in pickup[::-1]:\n        s.appendleft(value)\n    s.rotate(count + 1)\nwhile s[0] != 1:\n    s.rotate()\ns.popleft()\n\"\".join(str(x) for x in s)"
  },
  {
    "objectID": "qmd/2020.html#part-2-21",
    "href": "qmd/2020.html#part-2-21",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThis approach is way too slow for part 2. Instead, we can build an implicit linked list in a numpy array, so that a[node] = next node for all nodes. To make that work with zero based indexing we relabel all the nodes. A single step can now be accomplished by just updating three array elements: the next pointer of the current node, the next pointer of the destination node, and the next pointer of the last of the moved elements.\n\n\nCode\ninitial_state = data + list(range(10, 1_000_001))\na = np.zeros(len(initial_state), dtype=int)\nminval = min(initial_state)\nfor c, n in zip(initial_state, initial_state[1:] + [initial_state[0]]):\n    a[c - 1] = n - 1\ncurrent = a[-1]\nfor _ in range(10_000_000):\n    to_move = [a[current], a[a[current]], a[a[a[current]]]]\n    destination = current - 1\n    while destination &lt; 0 or destination in to_move:\n        destination -= 1\n        if destination &lt; 0:\n            destination = 999_999\n    # next pointer of current is the one after the moved ones\n    a[current] = a[to_move[-1]]\n    # The next one after the moved three is the one after the destination\n    a[to_move[-1]] = a[destination]\n    # After the destination comes the first of the moved ones\n    a[destination] = to_move[0]\n    # And we move to the next node\n    current = a[current]\n(a[0] + 1) * (a[a[0]] + 1)"
  },
  {
    "objectID": "qmd/2020.html#part-1-23",
    "href": "qmd/2020.html#part-1-23",
    "title": "2020 Solutions",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nvectors = {\n    \"e\": (1, 0),\n    \"ne\": (1, 1),\n    \"nw\": (0, 1),\n    \"w\": (-1, 0),\n    \"sw\": (-1, -1),\n    \"se\": (0, -1),\n}\ncurrent = \"\"\nterminals = \"ew\"\ntiles = defaultdict(bool)\nfor s in load(24):\n    result = []\n    for char in s:\n        current += char\n        if char in terminals:\n            result.append(vectors[current])\n            current = \"\"\n    coords = tuple(np.array(result).sum(axis=0))\n    tiles[coords] ^= 1\nnp.sum(list(tiles.values()))"
  },
  {
    "objectID": "qmd/2020.html#part-2-22",
    "href": "qmd/2020.html#part-2-22",
    "title": "2020 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThis is a fairly simple convolution problem again. We’ll be working in the basis defined above, and in that basis, the neighbors are as given in the vectors dictionary. So the array of weights is the one below.\n\n\nCode\nkeys = list(tiles.keys())\nweights = [[1, 1, 0], [1, 0, 1], [0, 1, 1]]\nborder = 100\nsize = 2 * border + np.max(keys) - np.min(keys)\nboard = np.zeros((size, size), dtype=int)\nfor x, y in tiles:\n    board[x + size // 2, y + size // 2] = tiles[x, y]\nfor i in range(100):\n    neighbors = scipy.ndimage.correlate(board, weights, mode=\"constant\")\n    flips = ((board == 0) & (neighbors == 2)) | (\n        (board == 1) & ((neighbors == 0) | (neighbors &gt; 2))\n    )\n    board = (board + flips) % 2\nboard.sum()"
  },
  {
    "objectID": "qmd/2025.html",
    "href": "qmd/2025.html",
    "title": "2025 Solutions",
    "section": "",
    "text": "Code\nimport dataclasses\nimport functools\nimport itertools\nimport math\nimport operator\nimport os\nimport re\nimport sys\nfrom collections import defaultdict, deque, namedtuple\nfrom queue import PriorityQueue\n\nimport more_itertools\nimport numpy as np\nimport pandas as pd\nimport scipy\n\nsys.path.insert(1, \"..\")\n\nimport utils\n\nload = utils.year_load(2025)"
  },
  {
    "objectID": "qmd/2025.html#part-1",
    "href": "qmd/2025.html#part-1",
    "title": "2025 Solutions",
    "section": "Part 1",
    "text": "Part 1\nWe’re working in numbers mod 100. Left turns correspond to subtraction, and right turns correspond to addition. To find the position of the dial after a set of turns we just take the cumulative sum of the additions and subtractions (mod 100). Then we just check how many times this position is zero\n\n\nCode\ndata = np.array([50] + [int(x.replace(\"L\", \"-\").replace(\"R\", \"\")) for x in load(1)])\n(np.cumsum(data) % 100 == 0).sum()"
  },
  {
    "objectID": "qmd/2025.html#part-2",
    "href": "qmd/2025.html#part-2",
    "title": "2025 Solutions",
    "section": "Part 2",
    "text": "Part 2\nTo find the number of times we’ve crossed zero, we can just look at how many times the hundreds place of the running sum has changed - every time that happens, we’ve crossed the value 0 on the dial. This is almost the right answer but needs to be corrected for the fact that sometimes we just kiss zero and don’t cross it. For example, if the dial went 10 -&gt; 0 -&gt; 10, the divisor test wouldn’t show a zero crossing. Similarly, if we went 90 -&gt; 0 -&gt; 90, the divisor test would show two crossings instead of one.\nA bit of thinking shows that the relevant points are those where\n\nThe total sum is zero after a move\nThe dial moves in the opposite way in the next move.\n\nWe can find both of those cases using numpy magic, and the necessary expression then becomes\n\n\nCode\nsum(\n    abs(np.diff(np.cumsum(data) // 100))\n    + ((np.cumsum(data) % 100 == 0)[:-1] * np.diff(np.sign(data)) // 2)\n)"
  },
  {
    "objectID": "qmd/2025.html#243d6f36-f834-4365-988d-96eb25722e56",
    "href": "qmd/2025.html#243d6f36-f834-4365-988d-96eb25722e56",
    "title": "2025 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThere’s probably a clever approach here, but I’m not seeing it right now – I’m guessing that comes with adventing at 9pm after a long day at work. I’ll just iterate over the ranges, and for each range, iterate over the numbers in the range. For every number in the range, I’ll check whether str(number) == str(number)[:length//2] * 2. It’s slow, but it works\n\n\nCode\nranges = [[int(y) for y in x.split(\"-\")] for x in load(2)[0].split(\",\")]\n\ndef invalid_ids(part=1):\n    total = 0\n    for val in itertools.chain(*[range(start, end + 1) for start, end in ranges]):\n        length = len(str(val))\n        repeats = [2] if part == 1 else proper_factors(length)\n        if any(str(val)[: length // repeat] * repeat == str(val) for repeat in repeats):\n            total += val\n    return total\n\ninvalid_ids()"
  },
  {
    "objectID": "qmd/2025.html#part-2-1",
    "href": "qmd/2025.html#part-2-1",
    "title": "2025 Solutions",
    "section": "Part 2",
    "text": "Part 2\nThe advantage of organising part 1 like that is that part 2 can be included in the same function with a small flag to switch between the two code paths. The only thing that’s left to do is to implement a factorisation function and we are done.\n\n\nCode\n@functools.cache\ndef proper_factors(n):\n    f = [list(set((i, n // i))) for i in range(2, int(math.sqrt(n)) + 1) if n % i == 0]\n    return sorted([x for pair in f for x in pair] + ([n] if n != 1 else []))\n\ninvalid_ids(part=2)"
  },
  {
    "objectID": "qmd/2025.html#part-1-1",
    "href": "qmd/2025.html#part-1-1",
    "title": "2025 Solutions",
    "section": "Part 1",
    "text": "Part 1\nOnce the data is loaded into an array, part 1 can be solved using an ugly one-liner. The idea is to take the largest number in each line, multiply by ten and add the largest number occuring after the first one. This needs to be corrected to account for those cases when the last digit of a line is the largest one - in those cases, we need to take the largest digit occuring before the last slot, multiply by ten and add the last digit.\n\n\nCode\ndata = load(3, \"intarray\")\nsum(\n    line[firstmax] * 10 + max(line[firstmax + 1 :])\n    if ((firstmax := np.argmax(line)) != len(line) - 1)\n    else line[firstmax] + 10 * max(line[:-1])\n    for line in data\n)"
  },
  {
    "objectID": "qmd/2025.html#part-2-2",
    "href": "qmd/2025.html#part-2-2",
    "title": "2025 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, we need to be a bit cleverer, but the core of the logic from before still applies. We know that we need to pick 12 digits out of n. This means that out of the first (n-11) digits, we need to pick at least one – otherwise we’ll run out of digits. And which of those digits is the best one to pick? The largest one. If we pick the ith digit, we now need to pick exactly 11 digits from position i+1 to n, which leads us nicely to the following recursive solution\n\n\nCode\ndef optimal_selection(array, count):\n    if count == 0:\n        return []\n    if len(array) == count:\n        return list(array)\n    argmax = np.argmax(array[: len(array) -count + 1])\n    return [array[argmax]] + optimal_selection(array[argmax + 1 :], count - 1)\n\n\nsum(functools.reduce(lambda x, y: 10*x + y, optimal_selection(line, 12)) for line in data)\n\n\nOnce we have that, part 1 could have been expressed as just sum(functools.reduce(lambda x, y: 10*x + y, optimal_selection(line, 2)) for line in data), but I liked the original one-liner"
  },
  {
    "objectID": "qmd/2025.html#part-1-2",
    "href": "qmd/2025.html#part-1-2",
    "title": "2025 Solutions",
    "section": "Part 1",
    "text": "Part 1\nThis definitely feels like a job that calls for numpy/scipy’s convolution functions. And maybe that library is such a good fit for the task that using it is a bit like cheating.\n\n\nCode\ndata = load(4, \"chararray\")\ncount = scipy.ndimage.convolve(1 * (data == \"@\"), np.ones((3, 3)), mode=\"constant\")\nchanged = (data == \"@\") & (count &lt; 5)\nchanged.sum()"
  },
  {
    "objectID": "qmd/2025.html#part-2-3",
    "href": "qmd/2025.html#part-2-3",
    "title": "2025 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part two, we can take the results from part one and put into a while loop\n\n\nCode\nnew_data = data.copy()\nwhile changed.sum() &gt; 0:\n    count = scipy.ndimage.convolve(1 * (new_data == \"@\"), np.ones((3, 3)), mode=\"constant\")\n    changed = 1 * ((new_data == \"@\") & (count &lt; 5))\n    new_data[np.where(changed)] = \".\"\n(new_data != data).sum()\n\n\n&gt;"
  },
  {
    "objectID": "qmd/2025.html#part-1-3",
    "href": "qmd/2025.html#part-1-3",
    "title": "2025 Solutions",
    "section": "Part 1",
    "text": "Part 1\nFor part 1, we can just loop over the values and for every value \\(v\\) ask if there is some range \\(r = (\\mathrm{start}, \\mathrm{end})\\) such that \\(\\mathrm{start} &lt;= v &lt;= \\mathrm{end}\\). The number of values that we have to check is small enough that this runs plenty fast\n\n\nCode\nranges, values = load(5, \"raw\").split(\"\\n\\n\")\nranges = [[int(x) for x in r.split(\"-\")] for r in ranges.split(\"\\n\")]\nvalues = [int(x) for x in values.split(\"\\n\")]\n\nsum(any(start &lt;= value &lt;= end for start, end in ranges) for value in values)"
  },
  {
    "objectID": "qmd/2025.html#part-2-4",
    "href": "qmd/2025.html#part-2-4",
    "title": "2025 Solutions",
    "section": "Part 2",
    "text": "Part 2\nFor part 2, I didn’t even bother checking if the above approach would have been fast enough. since that’s obviously not the intended path. Instead, we should focus on the ranges themselves. The length of a range \\(r = (\\mathrm{start}, \\mathrm{end})\\) is just \\(\\mathrm{end} - \\mathrm{start} + 1\\). The only tricky thing is what to do when to ranges overlap – how to detect it, and how to correct for it.\nIf we sort the ranges by start, then one of the folowing is true:\n\nThe first two ranges overlap\nNo range can overlap with the first range\n\nSo we can just sort the ranges by first coordinate, loop over them and check the first two ranges in each loop iteration. If they overlap, we put the merged range back into the list of ranges, and if they don’t we are done merging the first range and can just add it to the total length\n\n\nCode\nranges = sorted(ranges, key=lambda x: x[0])\nmerged_ranges = []\n\nwhile len(ranges) &gt; 1:\n    r1, r2 = ranges[0], ranges[1]\n    if r1[1] + 1 &gt;= r2[0]:\n        ranges = [r1[0], max(r2[1], r1[1])] + ranges[2:]\n    else:\n        ranges = ranges[1:]\n        merged_ranges.append(r1)\nmerged_ranges.append(ranges[0])\nsum(end - start + 1 for start, end in merged_ranges)"
  }
]