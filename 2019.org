#+PROPERTY: header-args:jupyter-python  :session aoc-2019 :kernel aoc
#+PROPERTY: header-args    :pandoc t

* Imports
#+begin_src jupyter-python
  import math
  import pandas as pd
  import numpy as np
  from collections import defaultdict
  from pathlib import Path
  import functools
  import itertools
  import more_itertools
  import re
  datadir = Path("data/2019")
#+end_src

* Day 1
[[https://adventofcode.com/2019/day/1][The Tyranny of the Rocket Equation]]
** Part 1
#+begin_src jupyter-python
  data = [int(x) for x in open(datadir / "1.txt").readlines()]
  sum([x//3 - 2 for x in data])
#+end_src

** Part 2
#+begin_src jupyter-python
  total = 0
  for val in data:
      fuel = max(val // 3 - 2, 0)
      total += fuel
      if fuel:
          data.append(fuel)
  total
#+end_src

* Day 2
[[https://adventofcode.com/2019/day/2][1202 Program Alarm]]
** Part 1
#+begin_src jupyter-python
  from intcode import IntCodeProgram
  program = IntCodeProgram([int(x) for x in open(datadir / "2.txt").readline().split(',')])
  def solve(program, ip=0, noun=12, verb=2):
      program.reset()
      program.program[1] = noun
      program.program[2] = verb
      try:
          val = next(program.run())
      except StopIteration:
          return program.program[0]
  solve(program)
#+end_src

#+begin_src jupyter-python
  for noun, verb in itertools.product(range(100), range(100)):
      result = solve(program, 0, noun, verb)
      if result == 19690720:
          result = 100 * noun + verb
          break
  result
#+end_src

* Day 3
[[https://adventofcode.com/2019/day/3][Crossed Wires]]

** Part 1
#+begin_src jupyter-python
    with open(datadir / '3.txt') as f:
        lines = [x.strip().split(',') for x in f.readlines()]

    def path_to_segments(path):
        directions = {"U": 1j, "D": -1j, "R": 1 , "L": -1}
        deltas = [int(p[1:]) * directions[p[0]] for p in path]
        ends = np.cumsum(deltas)
        lengths = np.cumsum(np.abs(deltas))
        result = np.vstack([np.roll(ends, 1), ends, np.roll(lengths, 1)]).T
        result[0, 0] = 0
        result[0, 2] = 0
        return result

    def intersection(s1, s2):
        if ((s1[1] - s1[0]) * (s2[1] - s2[0])).imag == 0:
            return False
        if (s1[0] - s1[1]).imag == 0:
            s2, s1 = s1, s2
        if ((s1[0].real - s2[0].real) * (s1[1].real - s2[1].real) < 0
            and (s1[0].imag - s2[0].imag) * (s1[1].imag - s2[1].imag) < 0):
            intersection_point = s1[0].real + 1j * s2[0].imag
            total_length = (s1[2] + s2[2]
                            + abs((s1[0] - intersection_point).imag)
                            + abs((s2[0] - intersection_point).real))
            return intersection_point, total_length
        return False

    l1 = path_to_segments(lines[0])
    l2 = path_to_segments(lines[1])
    intersections = [i for s1, s2 in itertools.product(l1, l2) if (i := intersection(s1, s2))]
    int(min( abs(x[0].real) + abs(x[0].imag) for x in intersections))
#+end_src

** Part 2
#+begin_src jupyter-python
min(x[1] for x in intersections)

#+end_src

** Bonus
As a bonus, we can visualize the walk through space
#+begin_src jupyter-python

  import matplotlib.pyplot as plt
  import seaborn as sns
  sns.set_theme()

  def plot_path(segments, **kwargs):
      x = segments[:, 0].real
      y = segments[:, 0].imag
      plt.plot(x, y, **kwargs)
  plot_path(l1)
  plot_path(l2)
  ax = plt.gca()
  plt.savefig("graphs/2019-3.png", bbox_inches="tight")

#+end_src

That gives this plot for the two different wires

[[graphs/2019-3.png]]

* Day 4
[[https://adventofcode.com/2019/day/4][Secure Container]]
** Part 1
#+begin_src jupyter-python
  low = 231832
  high = 767346
  total = 0
  for i in range(low, high + 1):
      s = str(i)
      if list(s) == sorted(s):
          for digit in '0123456789':
              if s.count(digit) > 1:
                  total += 1
                  break
  total
#+end_src

** Part 2
#+begin_src jupyter-python
  total = 0
  for i in range(low, high + 1):
      s = str(i)
      if list(s) == sorted(s):
          if (s[0] == s[1] != s[2]) or (s[-1] == s[-2] != s[-3]):
              total += 1
              continue
          for idx in range(1, len(s) - 2):
              if s[idx - 1] != s[idx] == s[idx + 1] != s[idx + 2]:
                  total += 1
                  break
  total

#+end_src

* Day 5
[[https://adventofcode.com/2019/day/5][Sunny with a Chance of Asteroids]]
** Part 1
#+begin_src jupyter-python
  from intcode import IntCodeProgram
  program = IntCodeProgram(np.loadtxt(datadir / "5.txt", dtype=int, delimiter=","))
  list(program.run([1]))[-1]
#+end_src

** Part 2
#+begin_src jupyter-python
  program.reset()
  next(program.run([5]))
#+end_src

* Day 6
[[https://adventofcode.com/2019/day/6][Universal Orbit Map]]
** Part 1
We construct the DAG as a dictionary, where graph[node] corresponds to node.parent. We use a second dictionary to memoize the counts of how far each node is from the COM
#+begin_src jupyter-python
  data = open(datadir / "6.txt").readlines()
  graph = {child: parent for parent, child in map(lambda x: x.strip().split(")"), data)}

  @functools.cache
  def count_orbits(node):
      if node == "COM":
          return 0, ()
      previous = count_orbits(graph[node])
      return previous[0] + 1, (graph[node],) + previous[1]
  sum(count_orbits(x)[0] for x in graph)
#+end_src

** Part 2
Moving from orbit A to orbit B can be accomplished by moving to the last common ancestor of each node, and then switching branches. And that's the same as getting the full ancestry of both nodes, minus anything they might have in common.
#+begin_src jupyter-python
  _, p1 = count_orbits("YOU")
  _, p2 = count_orbits("SAN")

  len(set(p1) ^ set(p2))
#+end_src

* Day 7
[[https://adventofcode.com/2019/day/7][Amplification Circuit]]
** Part 1
#+begin_src jupyter-python
  from intcode import IntCodeProgram
  opcodes = np.loadtxt(datadir / "7.txt", dtype=int, delimiter=",")
  program = IntCodeProgram(opcodes)
  results = []
  for input_sequence in itertools.permutations(range(5)):
      val = 0
      for item in input_sequence:
          program.reset()
          inputs = [item, val]
          val = next(program.run(inputs))
      results.append(val)
  max(results)
#+end_src

** Part 2
#+begin_src jupyter-python
  results = []
  for seq in itertools.permutations(range(5, 10)):
      inputs = [[x] for x in seq]
      inputs[0].append(0)
      iterators = [IntCodeProgram(opcodes).run(inputs[i]) for i in range(5)]
      i = 0
      while True:
          try:
              val = next(iterators[i % 5])
              inputs[(i + 1) % 5].append(val)
              i += 1
          except StopIteration:
              break
      results.append(val)
  max(results)
#+end_src

* Day 8
[[https://adventofcode.com/2019/day/8][Space Image Format]]
** Part 1
#+begin_src jupyter-python
  data = open(datadir / "8.txt").read().strip()
  result = []
  for i in range(len(data) // (25 * 6))[::-1]:
      substring = data[25*6*i: 25*6*(i+1)]
      result.append((substring.count("0"), substring.count("1") * substring.count("2")))
  min(result)[1]
#+end_src

** Part 2
#+begin_src jupyter-python
  result = list("1" * 25 * 6)
  for i in range(len(data) // (25 * 6))[::-1]:
      substring = data[25*6*i: 25*6*(i+1)]
      result = [bottom if top == "2" else top for top, bottom in zip(substring, result)]

  print("\n".join(["".join(["█" if char != "0" else " " for char in line])
                   for line in  np.array(result).reshape(6, 25)]))
#+end_src

* Day 9
[[https://adventofcode.com/2019/day/9][Sensor Boost]]
** Part 1
Adding the required functionality to the intcode compiler wasn't too tricky. Opcodes which set values had to be modified a bit to account for the offset, but that was more or less it.

Allowing arbitrary final addresses was accomplished by the very dirty hack of changing the program type in this problem from a list to defaultdict(int). If it works, it works.
#+begin_src jupyter-python
  program = IntCodeProgram(np.loadtxt(datadir / "9.txt", dtype=int, delimiter=","))
  next(program.run([1]))
#+end_src

** Part 2
#+begin_src jupyter-python
  program.reset()
  next(program.run([2]))
#+end_src

* Day 10
[[https://adventofcode.com/2019/day/10][Monitoring Station]]
** Part 1
#+begin_src jupyter-python
  from math import gcd
  def simplify(x, y):
      if (x, y) == (0, 0):
          return 0, 0
      factor = gcd(x, y)
      return int(x / factor), int(y / factor)

  data = np.array([[0 if char == '.' else 1 for char in line.strip()]
                   for line in open(datadir / "10.txt").readlines()]).T
  ones = np.array(np.where(data)).T
  scores = [len(set(map(lambda x: simplify(*x), ones - ones[i]))) for i in range(len(ones))]
  position = ones[np.argmax(scores)]
  print(max(scores) - 1)
  print(position)
#+end_src

** Part 2

There are more than 200 visible asteroids, so we only need to worry about the ones we meet on the first round - but that's exactly the simplified asteroids, as seen from our position. We take these, and sort them according to the angle they make with the negative y axis (negative because we have y increasing as it goes down in this coordinate system). The one we're interested in is the 201st asteroid according to this order (201st because the one we're measuring from will automatically have an angle of zero and should not be counted)
#+begin_src jupyter-python
  np.array(sorted(set([simplify(*x) for x in ones - position]), key = lambda x: (np.arctan2(x[0], -x[1])) % (2 * np.pi))[200]) + position
#+end_src

* Day 11
[[https://adventofcode.com/2019/day/11][Space Police]]
** Part 1
#+begin_src jupyter-python
  from intcode import IntCodeProgram
  program = IntCodeProgram(np.loadtxt(datadir / "11.txt", dtype=int, delimiter=","))
  def solve(startval):
      position, direction = 0 + 0j, 1j
      program.reset()
      field = defaultdict(int)
      count = 0
      inputs = [startval]
      painted = set()
      for colour, turn in more_itertools.chunked(program.run(inputs), 2):
          field[position] = colour
          painted.add(position)
          direction = direction * (1j * (1 - 2 * turn))
          position += direction
          inputs.append(field[position])
      return painted, field
  len(solve(0)[0])
#+end_src


** Part 2
#+begin_src jupyter-python
  _, field = solve(1)
  ones = np.array([x for x in field.keys() if field[x]])
  offset = ones.real.min() + 1j*ones.imag.min()
  ones = ones - offset
  field = np.zeros((int(ones.real.max()) + 1, int(ones.imag.max()) + 1))
  for value in ones:
      field[int(value.real), int(value.imag)] = 1
  print("\n".join(["".join(["█" if char else " " for char in line]) for line in np.rot90(field)]))

#+end_src

* Day 12
[[https://adventofcode.com/2019/day/12][The N-Body Problem]]
** Part 1
#+begin_src jupyter-python
  data = open(datadir / "12.txt").readlines()
  regex = r"(-?\d+)"
  positions = np.array([list(map(int, re.findall(regex, line))) for line in data], dtype=int)
  velocities = np.zeros(positions.shape, dtype=int)
  indices = [0, 1, 2, 3]
  for i in range(1000):
      for m1, m2 in itertools.combinations([0, 1, 2, 3], 2):
          dv = 1 * (positions[m2] > positions[m1]) - 1 * (positions[m2] < positions[m1])
          velocities[m1] += dv
          velocities[m2] -= dv
      positions += velocities
  (np.abs(positions).sum(axis=1) * np.abs(velocities).sum(axis=1)).sum()
#+end_src

** Part 2
I don't know what optimizations are possible here, but an obvious one is to realise that the three different directions (x,y and z) are completely independent, and that instead of searching for one global cycle, we can ask if there are shorter cycles for the coordinates separately. The global cycle length is then the lcm of the individual cycle lengths, as long as each cycle starts at the initial state.
#+begin_src jupyter-python
  data = open(datadir / "12.txt").readlines()
  regex = r"(-?\d+)"
  positions = np.array([list(map(int, re.findall(regex, line))) for line in data], dtype=int)
  velocities = np.zeros(positions.shape, dtype=int)
  seen_x = {}
  seen_y = {}
  seen_z = {}
  for axis, seen in zip([0, 1, 2], [seen_x, seen_y, seen_z]):
      seen[tuple(np.hstack([positions[:, axis], velocities[:, axis]]))] = 0
  cycles = [False, False, False]
  for i in range(1_000_000):
      for m1, m2 in itertools.combinations([0, 1, 2, 3], 2):
          dv = 1 * (positions[m2] > positions[m1]) - 1 * (positions[m2] < positions[m1])
          velocities[m1] += dv
          velocities[m2] -= dv
      positions += velocities
      for axis, seen in zip([0, 1, 2], [seen_x, seen_y, seen_z]):
          if cycles[axis]:
              continue
          state = tuple(np.hstack([positions[:, axis], velocities[:, axis]]))
          if state in seen:
              cycles[axis] = i + 1
      if all(cycles):
          break
  math.lcm(*cycles)

#+end_src
