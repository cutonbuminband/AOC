#+PROPERTY: header-args:jupyter-python  :session aoc-2019 :kernel aoc
#+PROPERTY: header-args    :pandoc t

* Imports
#+begin_src jupyter-python
  import math
  import scipy
  import pandas as pd
  import numpy as np
  from collections import defaultdict
  from pathlib import Path
  import functools
  import itertools
  import more_itertools
  import collections
  import re
  import utils
  from intcode import IntCodeProgram
  from collections import deque
  load = utils.year_load(2019)
#+end_src

* Day 1
[[https://adventofcode.com/2019/day/1][The Tyranny of the Rocket Equation]]
** Part 1
#+begin_src jupyter-python
  data = load(1, "np")
  (data // 3 - 2).sum()
#+end_src

** Part 2
#+begin_src jupyter-python
  total = 0
  data = list(data)
  for val in data:
      fuel = max(val // 3 - 2, 0)
      total += fuel
      if fuel:
          data.append(fuel)
  total
#+end_src

* Day 2
[[https://adventofcode.com/2019/day/2][1202 Program Alarm]]
** Part 1
#+begin_src jupyter-python
  program = IntCodeProgram([int(x) for x in load(2)[0].split(',')])
  def solve(program, noun=12, verb=2):
      program.reset()
      program.program[1] = noun
      program.program[2] = verb
      try:
          val = next(program.run())
      except StopIteration:
          return program.program[0]
  solve(program)
#+end_src

#+begin_src jupyter-python
  for noun, verb in itertools.product(range(100), range(100)):
      result = solve(program, noun, verb)
      if result == 19690720:
          result = 100 * noun + verb
          break
  result
#+end_src

* Day 3
[[https://adventofcode.com/2019/day/3][Crossed Wires]]

** Part 1
#+begin_src jupyter-python
  lines = [x.strip().split(',') for x in load(3)]

  def path_to_segments(path):
      directions = {"U": 1j, "D": -1j, "R": 1 , "L": -1}
      deltas = [int(p[1:]) * directions[p[0]] for p in path]
      ends = np.cumsum(deltas)
      lengths = np.cumsum(np.abs(deltas))
      result = np.vstack([np.roll(ends, 1), ends, np.roll(lengths, 1)]).T
      result[0, 0] = 0
      result[0, 2] = 0
      return result

  def intersection(s1, s2):
      if ((s1[1] - s1[0]) * (s2[1] - s2[0])).imag == 0:
          return False
      if (s1[0] - s1[1]).imag == 0:
          s2, s1 = s1, s2
      if ((s1[0].real - s2[0].real) * (s1[1].real - s2[1].real) < 0
          and (s1[0].imag - s2[0].imag) * (s1[1].imag - s2[1].imag) < 0):
          intersection_point = s1[0].real + 1j * s2[0].imag
          total_length = (s1[2] + s2[2]
                          + abs((s1[0] - intersection_point).imag)
                          + abs((s2[0] - intersection_point).real))
          return intersection_point, total_length
      return False

  l1 = path_to_segments(lines[0])
  l2 = path_to_segments(lines[1])
  intersections = [i for s1, s2 in itertools.product(l1, l2) if (i := intersection(s1, s2))]
  int(min( abs(x[0].real) + abs(x[0].imag) for x in intersections))
#+end_src

** Part 2
#+begin_src jupyter-python
  min(x[1] for x in intersections)

#+end_src

** Bonus
As a bonus, we can visualize the walk through space
#+begin_src jupyter-python

  import matplotlib.pyplot as plt
  import seaborn as sns
  sns.set_theme()

  def plot_path(segments, **kwargs):
      x = segments[:, 0].real
      y = segments[:, 0].imag
      plt.plot(x, y, **kwargs)
  plot_path(l1)
  plot_path(l2)
  ax = plt.gca()
  plt.savefig("graphs/2019-3.png", bbox_inches="tight")

#+end_src

That gives this plot for the two different wires

[[graphs/2019-3.png]]

* Day 4
[[https://adventofcode.com/2019/day/4][Secure Container]]
** Part 1
#+begin_src jupyter-python
  low = 231832
  high = 767346
  total = 0
  for i in range(low, high + 1):
      s = str(i)
      if list(s) == sorted(s):
          for digit in '0123456789':
              if s.count(digit) > 1:
                  total += 1
                  break
  total
#+end_src

** Part 2
#+begin_src jupyter-python
  total = 0
  for i in range(low, high + 1):
      s = str(i)
      if list(s) == sorted(s):
          if (s[0] == s[1] != s[2]) or (s[-1] == s[-2] != s[-3]):
              total += 1
              continue
          for idx in range(1, len(s) - 2):
              if s[idx - 1] != s[idx] == s[idx + 1] != s[idx + 2]:
                  total += 1
                  break
  total

#+end_src

* Day 5
[[https://adventofcode.com/2019/day/5][Sunny with a Chance of Asteroids]]
** Part 1
#+begin_src jupyter-python
  program = IntCodeProgram(load(5, "np"), inputs=[1])
  list(program.run())[-1]
#+end_src

** Part 2
#+begin_src jupyter-python
  program.reset()
  program.inputs = [5]
  next(program.run())
#+end_src

* Day 6
[[https://adventofcode.com/2019/day/6][Universal Orbit Map]]
** Part 1
We construct the DAG as a dictionary, where graph[node] corresponds to node.parent.
#+begin_src jupyter-python
  data = load(6)
  graph = {child: parent for parent, child in map(lambda x: x.strip().split(")"), data)}

  @functools.cache
  def count_orbits(node):
      if node == "COM":
          return 0, ()
      previous = count_orbits(graph[node])
      return previous[0] + 1, (graph[node],) + previous[1]
  sum(count_orbits(x)[0] for x in graph)
#+end_src

** Part 2
Moving from orbit A to orbit B can be accomplished by moving to the last common ancestor of each node, and then switching branches. And that's the same as getting the full ancestry of both nodes, minus anything they might have in common.
#+begin_src jupyter-python
  _, p1 = count_orbits("YOU")
  _, p2 = count_orbits("SAN")

  len(set(p1) ^ set(p2))
#+end_src

* Day 7
[[https://adventofcode.com/2019/day/7][Amplification Circuit]]
** Part 1
#+begin_src jupyter-python
  opcodes = load(7, "np")
  program = IntCodeProgram(opcodes)
  results = []
  for input_sequence in itertools.permutations(range(5)):
      val = 0
      for item in input_sequence:
          program.reset()
          program.inputs = [item, val]
          val = next(program.run())
      results.append(val)
  max(results)
#+end_src

** Part 2
#+begin_src jupyter-python
  results = []
  for seq in itertools.permutations(range(5, 10)):
      inputs = [[x] for x in seq]
      inputs[0].append(0)
      iterators = [IntCodeProgram(opcodes, inputs=inputs[i]).run() for i in range(5)]
      i = 0
      while True:
          try:
              val = next(iterators[i % 5])
              inputs[(i + 1) % 5].append(val)
              i += 1
          except StopIteration:
              break
      results.append(val)
  max(results)
#+end_src

* Day 8
[[https://adventofcode.com/2019/day/8][Space Image Format]]
** Part 1
#+begin_src jupyter-python
  data = load(8)[0].strip()
  result = []
  for i in range(len(data) // (25 * 6))[::-1]:
      substring = data[25*6*i: 25*6*(i+1)]
      result.append((substring.count("0"), substring.count("1") * substring.count("2")))
  min(result)[1]
#+end_src

** Part 2
#+begin_src jupyter-python
  result = list("1" * 25 * 6)
  for i in range(len(data) // (25 * 6))[::-1]:
      substring = data[25*6*i: 25*6*(i+1)]
      result = [bottom if top == "2" else top for top, bottom in zip(substring, result)]

  print("\n".join(["".join(["â–ˆ" if char != "0" else " " for char in line])
                   for line in  np.array(result).reshape(6, 25)]))
#+end_src

* Day 9
[[https://adventofcode.com/2019/day/9][Sensor Boost]]
** Part 1
Adding the required functionality to the intcode compiler wasn't too tricky. Opcodes which set values had to be modified a bit to account for the offset, but that was more or less it.

Allowing arbitrary final addresses was accomplished by the very dirty hack of changing the program type in this problem from a list to defaultdict(int). If it works, it works.
#+begin_src jupyter-python
  program = IntCodeProgram(load(9, "np"))
  program.inputs = [1]
  next(program.run())
#+end_src

** Part 2
#+begin_src jupyter-python
  program.reset()
  program.inputs = [2]
  next(program.run())
#+end_src

* Day 10
[[https://adventofcode.com/2019/day/10][Monitoring Station]]
** Part 1
#+begin_src jupyter-python
  from math import gcd
  def simplify(x, y):
      if (x, y) == (0, 0):
          return 0, 0
      factor = gcd(x, y)
      return int(x / factor), int(y / factor)

  data = np.array([[0 if char == '.' else 1 for char in line.strip()]
                   for line in load(10)]).T
  ones = np.array(np.where(data)).T
  scores = [len(set(map(lambda x: simplify(*x), ones - ones[i]))) for i in range(len(ones))]
  position = ones[np.argmax(scores)]
  print(max(scores) - 1)
  print(position)
#+end_src

** Part 2

There are more than 200 visible asteroids, so we only need to worry about the ones we meet on the first round - but that's exactly the simplified asteroids, as seen from our position. We take these, and sort them according to the angle they make with the negative y axis (negative because we have y increasing as it goes down in this coordinate system). The one we're interested in is the 201st asteroid according to this order (201st because the one we're measuring from will automatically have an angle of zero and should not be counted)
#+begin_src jupyter-python
  np.array(sorted(set([simplify(*x) for x in ones - position]), key = lambda x: (np.arctan2(x[0], -x[1])) % (2 * np.pi))[200]) + position
#+end_src

* Day 11
[[https://adventofcode.com/2019/day/11][Space Police]]
** Part 1
#+begin_src jupyter-python
  program = IntCodeProgram(load(11, "np"))
  def solve(startval):
      position, direction = 0 + 0j, 1j
      program.reset()
      field = defaultdict(int)
      count = 0
      program.inputs = [startval]
      painted = set()
      for colour, turn in more_itertools.chunked(program.run(), 2):
          field[position] = colour
          painted.add(position)
          direction = direction * (1j * (1 - 2 * turn))
          position += direction
          program.inputs.append(field[position])
      return painted, field
  len(solve(0)[0])
#+end_src


** Part 2
#+begin_src jupyter-python
  _, field = solve(1)
  ones = np.array([x for x in field.keys() if field[x]])
  offset = ones.real.min() + 1j*ones.imag.min()
  ones = ones - offset
  field = np.zeros((int(ones.real.max()) + 1, int(ones.imag.max()) + 1))
  for value in ones:
      field[int(value.real), int(value.imag)] = 1
  print("\n".join(["".join(["â–ˆ" if char else " " for char in line]) for line in np.rot90(field)]))

#+end_src

* Day 12
[[https://adventofcode.com/2019/day/12][The N-Body Problem]]
** Part 1
#+begin_src jupyter-python
  data = load(12, "int")
  positions = np.array(data, dtype=int)
  velocities = np.zeros(positions.shape, dtype=int)
  indices = [0, 1, 2, 3]
  for i in range(1000):
      for m1, m2 in itertools.combinations([0, 1, 2, 3], 2):
          dv = 1 * (positions[m2] > positions[m1]) - 1 * (positions[m2] < positions[m1])
          velocities[m1] += dv
          velocities[m2] -= dv
      positions += velocities
  (np.abs(positions).sum(axis=1) * np.abs(velocities).sum(axis=1)).sum()
#+end_src

** Part 2
I don't know what optimizations are possible here, but an obvious one is to realise that the three different directions (x,y and z) are completely independent, and that instead of searching for one global cycle, we can ask if there are shorter cycles for the coordinates separately. The global cycle length is then the lcm of the individual cycle lengths, as long as each cycle starts at the initial state.
#+begin_src jupyter-python
  data = load(12, "int")
  positions = np.array(data, dtype=int)
  velocities = np.zeros(positions.shape, dtype=int)
  seen_x = {}
  seen_y = {}
  seen_z = {}
  for axis, seen in zip([0, 1, 2], [seen_x, seen_y, seen_z]):
      seen[tuple(np.hstack([positions[:, axis], velocities[:, axis]]))] = 0
  cycles = [False, False, False]
  for i in range(1_000_000):
      for m1, m2 in itertools.combinations([0, 1, 2, 3], 2):
          dv = 1 * (positions[m2] > positions[m1]) - 1 * (positions[m2] < positions[m1])
          velocities[m1] += dv
          velocities[m2] -= dv
      positions += velocities
      for axis, seen in zip([0, 1, 2], [seen_x, seen_y, seen_z]):
          if cycles[axis]:
              continue
          state = tuple(np.hstack([positions[:, axis], velocities[:, axis]]))
          if state in seen:
              cycles[axis] = i + 1
      if all(cycles):
          break
  math.lcm(*cycles)

#+end_src

* Day 13
[[https://adventofcode.com/2019/day/13][Care Package]]

** Part 1
#+begin_src jupyter-python
  program = IntCodeProgram(load(13, "np"))
  tiles = set()
  for x, y, kind in more_itertools.chunked(program.run(), 3):
      if kind == 2:
          tiles.add((x, y))
  len(tiles)
#+end_src

** Part 2
#+begin_src jupyter-python
  program.set(0, 2)
  ball, paddle = 0, 0
  result = 0
  def ai():
      global ball
      global paddle
      return (ball > paddle) - (ball < paddle)
  program.set_input(ai)
  values = more_itertools.chunked(program.run(), 3)
  for x, y, kind  in values:
      result = result if (x != -1) else kind
      paddle = paddle if (kind != 3) else x
      ball = ball if (kind != 4) else x
  result
#+end_src



* Day 14

** Part 1
#+begin_src jupyter-python
  data = load(14)
  graph = {}
  for line in data:
      inputs, output = line.strip().split(" => ")
      output_amount, output_resource = output.split()
      output_amount = int(output_amount)
      inputs = [pair.split() for pair in inputs.split(", ")]
      graph[output_resource] = (output_amount, [x[1] for x in inputs], [int(x[0]) for x in inputs])
  def topological_sort(graph):
      if not graph:
          return []
      dependencies = functools.reduce(lambda x, y: x | set(y[1]), graph.values(), set())
      ready = []
      for key in graph:
          if key not in dependencies:
              ready.append(key)
      assert ready
      new_graph = {k: v for k, v in graph.items() if k not in ready}
      return ready + topological_sort(new_graph)

  def part1(n):
      order = topological_sort(graph)
      requirements = defaultdict(int)
      requirements["FUEL"] = n
      for resource in order:
          production, kinds, amounts = graph[resource]
          if resource in requirements:
              n = int(np.ceil(requirements[resource] / production))
              for kind, amount in zip(kinds, amounts):
                  requirements[kind] += n * amount
          del requirements[resource]
      return requirements["ORE"]
  part1(1)
#+end_src

** Part 2
We need to somehow reverse the relationship we found above. There are probably smarter ways of doing things, but a binary search works fine:
#+begin_src jupyter-python
  target = 1_000_000_000_000
  lower_limit = target // part1(1)
  upper_limit = lower_limit * 2
  while part1(upper_limit) < target:
      lower_limit *= 2
      upper_limit *= 2
  while (upper_limit - lower_limit) != 1:
      midpoint = int((upper_limit + lower_limit) / 2)
      if part1(midpoint) > target:
          upper_limit = midpoint
      else:
          lower_limit = midpoint
  lower_limit
#+end_src

* Day 15
[[https://adventofcode.com/2019/day/15][Oxygen System]]
** Part 1
I really liked this puzzle! The approach I took is to first map out the entire area by giving the droid the necessary instructions, and then using a path finding algorithm to get from start to finish.
#+begin_src jupyter-python
  program = IntCodeProgram(load(15, "np"))
  f = program.run()
  directions = {1: 1j, 2: -1j, 3: -1, 4: 1}
  reverse_directions = {v: k for k, v in directions.items()}

  def neighbors(state, edges=None):
      if edges is None:
          return []
      return [state + directions[neighbor] for neighbor in edges[state]]

  def update(steps, state, neighbor):
      return steps + [reverse_directions[neighbor - state]]

  queue = deque([(0, 0)])
  old_position = 0
  visited = set()
  edges = defaultdict(set)
  i = 0
  while queue:
      i += 1
      steps, position = queue.popleft()
      visited.add(position)
      instructions = utils.bfs(old_position, position, neighbors, [], update, edges=edges)
      program.set_input(instructions)
      while program.state != 1:
          _ = next(f)
      for direction in directions:
          new_position = position + directions[direction]
          opposite_direction = direction + 2*(direction % 2) - 1
          program.set_input([direction])
          val = next(f)
          if val == 0:
              continue
          program.set_input([opposite_direction])
          _ = next(f)
          edges[position].add(direction)
          edges[new_position].add(opposite_direction)
          if val == 2:
              target = new_position
          if new_position not in visited:
              # append left to make it a dfs, so that the droid doesn't have to
              # run from one side of the board to the other all the time
              queue.appendleft((steps + 1, new_position))
      old_position = position
  utils.bfs(0, target, neighbors, edges=edges)
#+end_src

** Part 2
We mapped out the whole area for part 1, so part 2 is just a bfs with no stopping condition
#+begin_src jupyter-python
  utils.bfs(target, None, neighbors, edges=edges)
#+end_src

* Day 16

** Part 1
For the first part all the numbers are small, so we don't need to be particularly clever
#+begin_src jupyter-python
  initial_data = [int(x) for x in load(16)[0].strip()]
  data = initial_data.copy()
  base_pattern = np.array([0, 1, 0, -1])
  factors = []
  for i in range(1, len(data) + 1):
      pattern = base_pattern.repeat(i)
      repeats = int(np.ceil((len(data) + 1) / len(pattern)))
      factors.append(np.tile(pattern, repeats)[1:len(data) + 1])
  factors = np.array(factors)
  for i in range(100):
      data = abs(factors @ data) % 10
  print(*data[:8], sep="", end="\n")
#+end_src


** Part 2

For part 2, the numbers get so big that this approach is impossible (just the transition matrix  has len(data)**2 * 1e8 elements, so that's not going to work).

The first optimization we can make is to realise that calculating the $k$th from last digit of the output only requires knowledge of the last $k$ digits of the input. So the last digit is always unchanged, the last-but-one digit is always the sum of the previous last two digits etc.

In fact, we can explicitly solve this reccurrence for the second half of the input data, and looking at the data provided, that's where the relevant digits are located! Denoting the $k$th digit from the end after the $n$th iteration as $d_k^n$, we can verify that

\begin{align*}
d^n_0 &= d^{n-1}_0 = \ldots = d^0_0 \\
d^n_1 &= d^{n-1}_1 + (d^{n-1}_0) = d^0_1 + nd^0_0 \\
d^n_2 &= d^{n-1}_2 + (d^{n-1}_1 + d^{n-1}_0) = d^0_2 + nd^0_1 + \frac12n(n+1)d^0_0 \\
\end{align*}

Explicitly solving the recurrences for all the digits in the second half is certainly possible, but it's going to be very tedious. Instead, we can notice that the middle expression is always $d^{n-1}_k + d^n_{k -1}$ . That means that to calculate $d^{100}_k$ we only need to know $d^0_k$ and $d^1_{k-1},  d^2_{k-1}, \ldots, d^{100}_{k-1}$, which translates to the following short routine:

#+begin_src jupyter-python
  active = 101 * [0]
  results = []
  index = functools.reduce(lambda x, y: 10 * x + y, initial_data[:7])
  data = np.tile(initial_data, 10_000)
  counter_index = len(data) - index
  for i in range(counter_index):
      active[0] = data[- 1 - i]
      active = np.cumsum(active) % 10
      results.append(active[-1])
  functools.reduce(lambda x, y: 10 * x + y, results[::-1][:8])
#+end_src

* Day 24
[[https://adventofcode.com/2019/day/24][Planet of Discord]]
** Part 1
#+begin_src jupyter-python
  state = np.array([[0 if char == "." else 1 for char in line.strip()] for line in load(24)])
  weights = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]
  seen = {}
  while tuple(state.ravel()) not in seen:
      seen[tuple(state.ravel())] = True
      bugs = scipy.ndimage.convolve(state, weights, mode="constant")
      changes = (bugs != 1)
      empty = np.where(state == 0)
      changes[empty] = ((bugs == 1) | (bugs == 2))[empty]
      state = (state + changes) % 2
  x = state.ravel()
  (x * (2 ** np.arange(len(x)))).sum()
#+end_src

** Part 2
???

