<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>AOC - 2023 Solutions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../qmd/styles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../qmd/2023.html">2023 Solutions</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">AOC</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/2025.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2025 Solutions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/2024.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2024 Solutions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/2023.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">2023 Solutions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/2022.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2022 Solutions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/2021.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2021 Solutions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/2020.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2020 Solutions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/2019.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2019 Solutions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/2018.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2018 Solutions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/2017.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2017 Solutions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/2016.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2016 Solutions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../qmd/2015.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2015 Solutions</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#imports" id="toc-imports" class="nav-link active" data-scroll-target="#imports">Imports</a></li>
  <li><a href="#day-1-trebuchet" id="toc-day-1-trebuchet" class="nav-link" data-scroll-target="#day-1-trebuchet">Day 1: Trebuchet?!</a>
  <ul class="collapse">
  <li><a href="#part-1" id="toc-part-1" class="nav-link" data-scroll-target="#part-1">Part 1</a></li>
  <li><a href="#part-2" id="toc-part-2" class="nav-link" data-scroll-target="#part-2">Part 2</a></li>
  </ul></li>
  <li><a href="#day-2-cube-conundrum" id="toc-day-2-cube-conundrum" class="nav-link" data-scroll-target="#day-2-cube-conundrum">Day 2: Cube Conundrum</a>
  <ul class="collapse">
  <li><a href="#part-1-1" id="toc-part-1-1" class="nav-link" data-scroll-target="#part-1-1">Part 1</a></li>
  <li><a href="#part-2-1" id="toc-part-2-1" class="nav-link" data-scroll-target="#part-2-1">Part 2</a></li>
  </ul></li>
  <li><a href="#day-3-gear-ratios" id="toc-day-3-gear-ratios" class="nav-link" data-scroll-target="#day-3-gear-ratios">Day 3: Gear Ratios</a>
  <ul class="collapse">
  <li><a href="#part-1-2" id="toc-part-1-2" class="nav-link" data-scroll-target="#part-1-2">Part 1</a></li>
  <li><a href="#part-2-2" id="toc-part-2-2" class="nav-link" data-scroll-target="#part-2-2">Part 2</a></li>
  </ul></li>
  <li><a href="#day-4-scratchcards" id="toc-day-4-scratchcards" class="nav-link" data-scroll-target="#day-4-scratchcards">Day 4: Scratchcards</a>
  <ul class="collapse">
  <li><a href="#part-1-3" id="toc-part-1-3" class="nav-link" data-scroll-target="#part-1-3">Part 1</a></li>
  <li><a href="#part-2-3" id="toc-part-2-3" class="nav-link" data-scroll-target="#part-2-3">Part 2</a></li>
  </ul></li>
  <li><a href="#day-5-if-you-give-a-seed-a-fertilizer" id="toc-day-5-if-you-give-a-seed-a-fertilizer" class="nav-link" data-scroll-target="#day-5-if-you-give-a-seed-a-fertilizer">Day 5: If You Give A Seed A Fertilizer</a>
  <ul class="collapse">
  <li><a href="#part-1-4" id="toc-part-1-4" class="nav-link" data-scroll-target="#part-1-4">Part 1</a></li>
  <li><a href="#part-2-4" id="toc-part-2-4" class="nav-link" data-scroll-target="#part-2-4">Part 2</a></li>
  </ul></li>
  <li><a href="#day-6-wait-for-it" id="toc-day-6-wait-for-it" class="nav-link" data-scroll-target="#day-6-wait-for-it">Day 6: Wait For It</a>
  <ul class="collapse">
  <li><a href="#part-1-5" id="toc-part-1-5" class="nav-link" data-scroll-target="#part-1-5">Part 1</a></li>
  <li><a href="#part-2-5" id="toc-part-2-5" class="nav-link" data-scroll-target="#part-2-5">Part 2</a></li>
  </ul></li>
  <li><a href="#day-7-camel-cards" id="toc-day-7-camel-cards" class="nav-link" data-scroll-target="#day-7-camel-cards">Day 7: Camel Cards</a>
  <ul class="collapse">
  <li><a href="#part-1-6" id="toc-part-1-6" class="nav-link" data-scroll-target="#part-1-6">Part 1</a></li>
  <li><a href="#part-2-6" id="toc-part-2-6" class="nav-link" data-scroll-target="#part-2-6">Part 2</a></li>
  </ul></li>
  <li><a href="#day-8-haunted-wasteland" id="toc-day-8-haunted-wasteland" class="nav-link" data-scroll-target="#day-8-haunted-wasteland">Day 8: Haunted Wasteland</a>
  <ul class="collapse">
  <li><a href="#part-1-7" id="toc-part-1-7" class="nav-link" data-scroll-target="#part-1-7">Part 1</a></li>
  <li><a href="#part-2-7" id="toc-part-2-7" class="nav-link" data-scroll-target="#part-2-7">Part 2</a></li>
  </ul></li>
  <li><a href="#day-9-mirage-maintenance" id="toc-day-9-mirage-maintenance" class="nav-link" data-scroll-target="#day-9-mirage-maintenance">Day 9: Mirage Maintenance</a>
  <ul class="collapse">
  <li><a href="#part-1-8" id="toc-part-1-8" class="nav-link" data-scroll-target="#part-1-8">Part 1</a></li>
  <li><a href="#part-2-8" id="toc-part-2-8" class="nav-link" data-scroll-target="#part-2-8">Part 2</a></li>
  </ul></li>
  <li><a href="#day-10-pipe-maze" id="toc-day-10-pipe-maze" class="nav-link" data-scroll-target="#day-10-pipe-maze">Day 10: Pipe Maze</a>
  <ul class="collapse">
  <li><a href="#part-1-9" id="toc-part-1-9" class="nav-link" data-scroll-target="#part-1-9">Part 1</a></li>
  <li><a href="#part-2-9" id="toc-part-2-9" class="nav-link" data-scroll-target="#part-2-9">Part 2</a></li>
  </ul></li>
  <li><a href="#day-11-cosmic-expansion" id="toc-day-11-cosmic-expansion" class="nav-link" data-scroll-target="#day-11-cosmic-expansion">Day 11: Cosmic Expansion</a>
  <ul class="collapse">
  <li><a href="#part-1-10" id="toc-part-1-10" class="nav-link" data-scroll-target="#part-1-10">Part 1</a></li>
  <li><a href="#part-2-10" id="toc-part-2-10" class="nav-link" data-scroll-target="#part-2-10">Part 2</a></li>
  </ul></li>
  <li><a href="#day-12-hot-springs" id="toc-day-12-hot-springs" class="nav-link" data-scroll-target="#day-12-hot-springs">Day 12: Hot Springs</a>
  <ul class="collapse">
  <li><a href="#part-1-11" id="toc-part-1-11" class="nav-link" data-scroll-target="#part-1-11">Part 1</a></li>
  <li><a href="#part-2-11" id="toc-part-2-11" class="nav-link" data-scroll-target="#part-2-11">Part 2</a></li>
  </ul></li>
  <li><a href="#day-13-point-of-incidence" id="toc-day-13-point-of-incidence" class="nav-link" data-scroll-target="#day-13-point-of-incidence">Day 13: Point of Incidence</a>
  <ul class="collapse">
  <li><a href="#part-1-12" id="toc-part-1-12" class="nav-link" data-scroll-target="#part-1-12">Part 1</a></li>
  <li><a href="#part-2-12" id="toc-part-2-12" class="nav-link" data-scroll-target="#part-2-12">Part 2</a></li>
  </ul></li>
  <li><a href="#day-14-parabolic-reflector-dish" id="toc-day-14-parabolic-reflector-dish" class="nav-link" data-scroll-target="#day-14-parabolic-reflector-dish">Day 14: Parabolic Reflector Dish</a>
  <ul class="collapse">
  <li><a href="#part-1-13" id="toc-part-1-13" class="nav-link" data-scroll-target="#part-1-13">Part 1</a></li>
  <li><a href="#part-2-13" id="toc-part-2-13" class="nav-link" data-scroll-target="#part-2-13">Part 2</a></li>
  </ul></li>
  <li><a href="#day-15-lens-library" id="toc-day-15-lens-library" class="nav-link" data-scroll-target="#day-15-lens-library">Day 15: Lens Library</a>
  <ul class="collapse">
  <li><a href="#part-1-14" id="toc-part-1-14" class="nav-link" data-scroll-target="#part-1-14">Part 1</a></li>
  <li><a href="#part-2-14" id="toc-part-2-14" class="nav-link" data-scroll-target="#part-2-14">Part 2</a></li>
  </ul></li>
  <li><a href="#day-16-the-floor-will-be-lava" id="toc-day-16-the-floor-will-be-lava" class="nav-link" data-scroll-target="#day-16-the-floor-will-be-lava">Day 16: The Floor Will Be Lava</a>
  <ul class="collapse">
  <li><a href="#part-1-15" id="toc-part-1-15" class="nav-link" data-scroll-target="#part-1-15">Part 1</a></li>
  <li><a href="#part-2-15" id="toc-part-2-15" class="nav-link" data-scroll-target="#part-2-15">Part 2</a></li>
  </ul></li>
  <li><a href="#day-17-clumsy-crucible" id="toc-day-17-clumsy-crucible" class="nav-link" data-scroll-target="#day-17-clumsy-crucible">Day 17: Clumsy Crucible</a>
  <ul class="collapse">
  <li><a href="#part-1-16" id="toc-part-1-16" class="nav-link" data-scroll-target="#part-1-16">Part 1</a></li>
  <li><a href="#part-2-16" id="toc-part-2-16" class="nav-link" data-scroll-target="#part-2-16">Part 2</a></li>
  </ul></li>
  <li><a href="#day-18-lavaduct-lagoon" id="toc-day-18-lavaduct-lagoon" class="nav-link" data-scroll-target="#day-18-lavaduct-lagoon">Day 18: Lavaduct Lagoon</a>
  <ul class="collapse">
  <li><a href="#part-1-17" id="toc-part-1-17" class="nav-link" data-scroll-target="#part-1-17">Part 1</a></li>
  <li><a href="#part-2-17" id="toc-part-2-17" class="nav-link" data-scroll-target="#part-2-17">Part 2</a></li>
  </ul></li>
  <li><a href="#day-19-aplenty" id="toc-day-19-aplenty" class="nav-link" data-scroll-target="#day-19-aplenty">Day 19: Aplenty</a>
  <ul class="collapse">
  <li><a href="#part-1-18" id="toc-part-1-18" class="nav-link" data-scroll-target="#part-1-18">Part 1</a></li>
  <li><a href="#part-2-18" id="toc-part-2-18" class="nav-link" data-scroll-target="#part-2-18">Part 2</a></li>
  </ul></li>
  <li><a href="#day-20-pulse-propagation" id="toc-day-20-pulse-propagation" class="nav-link" data-scroll-target="#day-20-pulse-propagation">Day 20: Pulse Propagation</a>
  <ul class="collapse">
  <li><a href="#part-2-19" id="toc-part-2-19" class="nav-link" data-scroll-target="#part-2-19">Part 2</a></li>
  </ul></li>
  <li><a href="#day-21-step-counter" id="toc-day-21-step-counter" class="nav-link" data-scroll-target="#day-21-step-counter">Day 21: Step Counter</a>
  <ul class="collapse">
  <li><a href="#part-1-19" id="toc-part-1-19" class="nav-link" data-scroll-target="#part-1-19">Part 1</a></li>
  </ul></li>
  <li><a href="#day-25-snowverload" id="toc-day-25-snowverload" class="nav-link" data-scroll-target="#day-25-snowverload">Day 25: Snowverload</a>
  <ul class="collapse">
  <li><a href="#part-1-20" id="toc-part-1-20" class="nav-link" data-scroll-target="#part-1-20">Part 1</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">2023 Solutions</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="imports" class="level1">
<h1>Imports</h1>
<div class="cell" data-execution_count="1">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dataclasses</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> functools</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict, deque, namedtuple</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> queue <span class="im">import</span> PriorityQueue</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> more_itertools</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>sys.path.insert(<span class="dv">1</span>, <span class="st">".."</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> utils</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>load <span class="op">=</span> utils.year_load(<span class="dv">2023</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="day-1-trebuchet" class="level1">
<h1><a href="https://adventofcode.com/2023/day/1">Day 1: Trebuchet?!</a></h1>
<section id="part-1" class="level2">
<h2 class="anchored" data-anchor-id="part-1">Part 1</h2>
<p>Not much going on in part one. We need to extract the digits in each line and then add together <span class="math inline">\(10\times\)</span> all the first digits and all the last digits.</p>
<div class="cell" data-execution_count="2">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [[<span class="bu">int</span>(char) <span class="cf">for</span> char <span class="kw">in</span> line <span class="cf">if</span> char <span class="kw">in</span> <span class="st">"0123456879"</span>] <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">1</span>)]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span> <span class="op">*</span> <span class="bu">sum</span>(x[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> data) <span class="op">+</span> <span class="bu">sum</span>(x[<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2" class="level2">
<h2 class="anchored" data-anchor-id="part-2">Part 2</h2>
<p>For part two, we need to work with the string representation of the numbers. The examples show that the numbers can overlap, so we want a string like “fiveight” to show a “5” first and then an “8”.</p>
<p>We are only interested in the first and last digits of the string, so this could be done using a sliding window. Or we could hack it by padding the string representation of the number and doing a search and replace:</p>
<div class="cell" data-execution_count="3">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>number_names <span class="op">=</span> [</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"one"</span>, <span class="st">"one1one"</span>),</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"two"</span>, <span class="st">"two2two"</span>),</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"three"</span>, <span class="st">"three3three"</span>),</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"four"</span>, <span class="st">"four4four"</span>),</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"five"</span>, <span class="st">"five5five"</span>),</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"six"</span>, <span class="st">"six6six"</span>),</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"seven"</span>, <span class="st">"seven7seven"</span>),</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"eight"</span>, <span class="st">"eight8eight"</span>),</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"nine"</span>, <span class="st">"nine9nine"</span>),</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">1</span>, <span class="st">"raw"</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> pair <span class="kw">in</span> number_names:</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> data.replace(pair[<span class="dv">0</span>], pair[<span class="dv">1</span>])</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> data.split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [[<span class="bu">int</span>(char) <span class="cf">for</span> char <span class="kw">in</span> line <span class="cf">if</span> char <span class="kw">in</span> <span class="st">"0123456879"</span>] <span class="cf">for</span> line <span class="kw">in</span> data]</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span> <span class="op">*</span> <span class="bu">sum</span>(x[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> data) <span class="op">+</span> <span class="bu">sum</span>(x[<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-2-cube-conundrum" class="level1">
<h1><a href="https://adventofcode.com/2023/day/2">Day 2: Cube Conundrum</a></h1>
<section id="part-1-1" class="level2">
<h2 class="anchored" data-anchor-id="part-1-1">Part 1</h2>
<p>The most fiddly task in part 1 is parsing the input. Each line is a single game, with the game id appearing first and then the game outcome, separated by a colon. Each game consists of multiple rounds (delimited by a semicolon) and each round reveals multiple colours (delimited by commas).</p>
<p>So we split on the colon to separate the game id from the outcome, then split the outcome on semicolons to get each round, and finally split each round on commas to find the colours. A bit of regex let’s us finally get to a list of three integers as the representation of a round.</p>
<p>Once we have that, we can compare each round in a game with the maximum number of <code class="verbatim">[red, green, blue]</code> cubes available and see if it is possible. A game fails if any single round is impossible.</p>
<div class="cell" data-execution_count="4">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_game_round(game_round):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    colormap <span class="op">=</span> {<span class="st">"red"</span>: <span class="dv">0</span>, <span class="st">"green"</span>: <span class="dv">1</span>, <span class="st">"blue"</span>: <span class="dv">2</span>}</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    regex <span class="op">=</span> <span class="vs">r"([0-9]*) (red|green|blue)"</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v, c <span class="kw">in</span> [re.search(regex, entry).groups() <span class="cf">for</span> entry <span class="kw">in</span> game_round.split(<span class="st">","</span>)]:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        result[colormap[c]] <span class="op">=</span> <span class="bu">int</span>(v)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>games <span class="op">=</span> [</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    np.array([parse_game_round(x) <span class="cf">for</span> x <span class="kw">in</span> line.split(<span class="st">":"</span>)[<span class="dv">1</span>].split(<span class="st">";"</span>)])</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">2</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, game <span class="kw">in</span> <span class="bu">enumerate</span>(games):</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ((game <span class="op">-</span> [<span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>]) <span class="op">&lt;=</span> <span class="dv">0</span>).<span class="bu">all</span>():</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> idx <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>total</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-1" class="level2">
<h2 class="anchored" data-anchor-id="part-2-1">Part 2</h2>
<p>With part 1 out of the way, part 2 is trivial: we get the same representation for each game as before, and just calculate the maximum for each coordinate in any round, and then multiply those three numbers together.</p>
<div class="cell" data-execution_count="5">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(np.product(game.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">0</span>)) <span class="cf">for</span> game <span class="kw">in</span> games)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-3-gear-ratios" class="level1">
<h1><a href="https://adventofcode.com/2023/day/3">Day 3: Gear Ratios</a></h1>
<section id="part-1-2" class="level2">
<h2 class="anchored" data-anchor-id="part-1-2">Part 1</h2>
<p>It seems the theme for AOC this year is “let’s make things annoying to parse”.</p>
<p>We’ll need to extract the values and locations of all the numbers in the grid, and then compare that with the locations of the symbols. To get the coordinates that neighbor a symbol we can use a neat convolution trick. To get the coordinates of each number we’ll loop over all the lines in the grid, and use a regex to find the numbers.</p>
<p>Once we have that, we can find the desired value by finding the set intersetion of the number-coordinates and the neighbor coordinates; if that’s non-empty, we add the number to a running total.</p>
<div class="cell" data-execution_count="6">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">3</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>symbols <span class="op">=</span> np.array([[(c <span class="kw">not</span> <span class="kw">in</span> <span class="st">"0123456789"</span>) <span class="kw">and</span> c <span class="op">!=</span> <span class="st">"."</span> <span class="cf">for</span> c <span class="kw">in</span> l] <span class="cf">for</span> l <span class="kw">in</span> data])</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> [[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>]]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>neighbors <span class="op">=</span> scipy.ndimage.convolve(symbols, w, mode<span class="op">=</span><span class="st">"constant"</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>neighbors <span class="op">=</span> <span class="bu">set</span>(<span class="bu">zip</span>(<span class="op">*</span>np.where(neighbors)))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> {}</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, row <span class="kw">in</span> <span class="bu">enumerate</span>(data):</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> re.finditer(<span class="st">"\d+"</span>, row):</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        numbers[<span class="bu">frozenset</span>((i, j) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="op">*</span>n.span()))] <span class="op">=</span> <span class="bu">int</span>(n.group())</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(numbers[key] <span class="cf">if</span> key <span class="op">&amp;</span> neighbors <span class="cf">else</span> <span class="dv">0</span> <span class="cf">for</span> key <span class="kw">in</span> numbers)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-2" class="level2">
<h2 class="anchored" data-anchor-id="part-2-2">Part 2</h2>
<p>After part 1, part 2 is pretty simple. We can use the same (coordinates) -&gt; number mapping as before, and then just loop over all locations in the grid that have a value of “*”. We find the neighbors of each star, intersect with all the numbers coordinates, and only use the ones that intersect exactly two numbers</p>
<div class="cell" data-execution_count="7">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>offsets <span class="op">=</span> np.array(<span class="bu">list</span>(<span class="bu">zip</span>(<span class="op">*</span>np.where(w)))) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> star <span class="kw">in</span> <span class="bu">zip</span>(<span class="op">*</span>np.where(np.array([[c <span class="cf">for</span> c <span class="kw">in</span> l] <span class="cf">for</span> l <span class="kw">in</span> data]) <span class="op">==</span> <span class="st">"*"</span>)):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    neighbors <span class="op">=</span> <span class="bu">set</span>([<span class="bu">tuple</span>(x) <span class="cf">for</span> x <span class="kw">in</span> star <span class="op">+</span> offsets])</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    values <span class="op">=</span> [numbers[key] <span class="cf">for</span> key <span class="kw">in</span> numbers <span class="cf">if</span> key <span class="op">&amp;</span> neighbors]</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    total <span class="op">+=</span> values[<span class="dv">0</span>] <span class="op">*</span> values[<span class="dv">1</span>] <span class="cf">if</span> <span class="bu">len</span>(values) <span class="op">==</span> <span class="dv">2</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>total</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-4-scratchcards" class="level1">
<h1><a href="https://adventofcode.com/2023/day/4">Day 4: Scratchcards</a></h1>
<section id="part-1-3" class="level2">
<h2 class="anchored" data-anchor-id="part-1-3">Part 1</h2>
<p>After the interesting parsing tasks of the last few days, today was straightforward. Part one can be boiled down to this oneliner, which I don’t even think is completely illegible</p>
<div class="cell" data-execution_count="8">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(<span class="bu">int</span>(<span class="dv">2</span> <span class="op">**</span> (<span class="bu">len</span>(<span class="bu">set</span>(row[<span class="dv">1</span>:<span class="dv">11</span>]) <span class="op">&amp;</span> <span class="bu">set</span>(row[<span class="dv">11</span>:])) <span class="op">-</span> <span class="dv">1</span>)) <span class="cf">for</span> row <span class="kw">in</span> load(<span class="dv">4</span>, <span class="st">"int"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-3" class="level2">
<h2 class="anchored" data-anchor-id="part-2-3">Part 2</h2>
<p>I could have found some way of saving the intersections from part 1 so that I didn’t have to recalculate in part two, but it’s not that complicated.</p>
<div class="cell" data-execution_count="9">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">4</span>, <span class="st">"int"</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>counts <span class="op">=</span> np.ones(<span class="bu">len</span>(data), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, row <span class="kw">in</span> <span class="bu">enumerate</span>(data):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    wins <span class="op">=</span> <span class="bu">len</span>(<span class="bu">set</span>(row[<span class="dv">1</span>:<span class="dv">11</span>]) <span class="op">&amp;</span> <span class="bu">set</span>(row[<span class="dv">11</span>:]))</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    counts[i <span class="op">+</span> <span class="dv">1</span> : i <span class="op">+</span> wins <span class="op">+</span> <span class="dv">1</span>] <span class="op">+=</span> counts[i]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(counts)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-5-if-you-give-a-seed-a-fertilizer" class="level1">
<h1><a href="https://adventofcode.com/2023/day/5">Day 5: If You Give A Seed A Fertilizer</a></h1>
<section id="part-1-4" class="level2">
<h2 class="anchored" data-anchor-id="part-1-4">Part 1</h2>
<p>The first part is a straightforward implementation of the requirements.</p>
<p>To parse the file, we first split on “” to get each of the sections separately, then for each line of each section, we extract all of the integers. These are all positive, so we can do that with the regex “(+̣)”. After skipping through lines which don’t contain integers, we have a sensible representation for our data.</p>
<p>After that it’s just a question of following through what happens to each initial value: for each one we scan through the rulesets in order, and when we find a rule in a ruleset that matches we convert it to the new value and move on. If we don’t find a rule that matches we’re told that the converted value is the same as the original one.</p>
<div class="cell" data-execution_count="10">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>[seeds], <span class="op">*</span>rules <span class="op">=</span> [</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    [</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        [<span class="bu">int</span>(x) <span class="cf">for</span> x <span class="kw">in</span> ints]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> line <span class="kw">in</span> groups.split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (ints <span class="op">:=</span> re.findall(<span class="st">"(\d+)"</span>, line))</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> groups <span class="kw">in</span> load(<span class="dv">5</span>, <span class="st">"raw"</span>).split(<span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>minval <span class="op">=</span> np.inf</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> seed <span class="kw">in</span> seeds:</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> seed</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ruleset <span class="kw">in</span> rules:</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> destination, source, length <span class="kw">in</span> ruleset:</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> source <span class="op">&lt;=</span> current <span class="op">&lt;</span> source <span class="op">+</span> length:</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>                current <span class="op">=</span> current <span class="op">+</span> destination <span class="op">-</span> source</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current <span class="op">&lt;</span> minval:</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        minval <span class="op">=</span> current</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>minval</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-4" class="level2">
<h2 class="anchored" data-anchor-id="part-2-4">Part 2</h2>
<p>For part two we need to be a bit cleverer. We know that each rule converts a specific source range to a specific destination range. So to apply a rule to an arbitrary range, we split the range into three: The parts of the range before the rule applies, the parts of the range that intersect the rule and the parts of the range after the rule. Some of these parts can be empty, but that’s OK.</p>
<p>From there, building a routine to iteratively apply each ruleset to the original ranges is not too tricky.</p>
<div class="cell" data-execution_count="11">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_range(r, rule):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        x <span class="cf">if</span> x[<span class="dv">0</span>] <span class="op">&lt;</span> x[<span class="dv">1</span>] <span class="cf">else</span> []</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> [</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>            (r[<span class="dv">0</span>], <span class="bu">min</span>(rule[<span class="dv">0</span>], r[<span class="dv">1</span>])),</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            (<span class="bu">max</span>(r[<span class="dv">0</span>], rule[<span class="dv">0</span>]), <span class="bu">min</span>(r[<span class="dv">1</span>], rule[<span class="dv">1</span>])),</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            (<span class="bu">max</span>(rule[<span class="dv">1</span>], r[<span class="dv">0</span>]), r[<span class="dv">1</span>]),</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_ranges(ranges, rule):</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    dest, src, length <span class="op">=</span> rule</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    done, todo <span class="op">=</span> [], []</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l, m, r <span class="kw">in</span> [split_range(r, [src, src <span class="op">+</span> length]) <span class="cf">for</span> r <span class="kw">in</span> ranges]:</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        todo <span class="op">+=</span> [l] <span class="cf">if</span> l <span class="cf">else</span> []</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        todo <span class="op">+=</span> [r] <span class="cf">if</span> r <span class="cf">else</span> []</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        done <span class="op">+=</span> [(m[<span class="dv">0</span>] <span class="op">+</span> dest <span class="op">-</span> src, m[<span class="dv">1</span>] <span class="op">+</span> dest <span class="op">-</span> src)] <span class="cf">if</span> m <span class="cf">else</span> []</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> done, todo</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>ranges <span class="op">=</span> [(start, start <span class="op">+</span> l) <span class="cf">for</span> start, l <span class="kw">in</span> more_itertools.chunked(seeds, <span class="dv">2</span>)]</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ruleset <span class="kw">in</span> rules:</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    todo <span class="op">=</span> ranges</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> []</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> rule <span class="kw">in</span> ruleset:</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>        new_ranges, todo <span class="op">=</span> split_ranges(todo, rule)</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>        ranges <span class="op">+=</span> new_ranges</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">+=</span> todo</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a><span class="bu">min</span>(x[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> ranges)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-6-wait-for-it" class="level1">
<h1><a href="https://adventofcode.com/2023/day/6">Day 6: Wait For It</a></h1>
<section id="part-1-5" class="level2">
<h2 class="anchored" data-anchor-id="part-1-5">Part 1</h2>
<p>We can set up an equation for how far the boat will move in a given time, <span class="math inline">\(t\)</span> when waiting for a given period <span class="math inline">\(w\)</span> at the start, to wit <span class="math display">\[
d(t, w) = w(t-w)
\]</span></p>
<p>We are interested in which values of <span class="math inline">\(w\)</span> give <span class="math inline">\(d(t_0, w) &gt; d_0\)</span>, for the <span class="math inline">\(d_0, t_0\)</span> pairs we are given in the input, which is the same as exploring when the parabola described by <span class="math inline">\(-w^2 +wt_0 - d_0\)</span> is positive. This parabola has a maximum at <span class="math inline">\(w = \frac{t_0}{2}\)</span>, and it’s positive region (if any) will lie between the two roots. The roots are given by</p>
<p><span class="math display">\[
w_{1,2} = \frac{t_0 \mp \sqrt{t_0^2 - 4d_0^2}}{2};
\]</span></p>
<p>and for each <span class="math inline">\((d_0, t_0)\)</span> pair we are interested in how many integers lie in the open interval <span class="math inline">\((w_1, w_2)\)</span></p>
<div class="cell" data-execution_count="12">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>ts, ds <span class="op">=</span> np.array(load(<span class="dv">6</span>, <span class="st">"int"</span>))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>Δs <span class="op">=</span> np.sqrt(ts<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> ds)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>np.prod(np.floor(ts <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> Δs <span class="op">/</span> <span class="dv">2</span> <span class="op">-</span> <span class="fl">1e-10</span>) <span class="op">-</span> np.ceil(ts <span class="op">/</span> <span class="dv">2</span> <span class="op">-</span> Δs <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> <span class="fl">1e-10</span>) <span class="op">+</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-5" class="level2">
<h2 class="anchored" data-anchor-id="part-2-5">Part 2</h2>
<p>For part 2, we don’t need to change anything.</p>
<div class="cell" data-execution_count="13">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="bu">int</span>(<span class="st">""</span>.join([<span class="bu">str</span>(x) <span class="cf">for</span> x <span class="kw">in</span> ts]))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="bu">int</span>(<span class="st">""</span>.join([<span class="bu">str</span>(x) <span class="cf">for</span> x <span class="kw">in</span> ds]))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>Δ <span class="op">=</span> np.sqrt(t<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> d)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>np.floor(t <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> Δ <span class="op">/</span> <span class="dv">2</span> <span class="op">-</span> <span class="fl">1e-10</span>) <span class="op">-</span> np.ceil(t <span class="op">/</span> <span class="dv">2</span> <span class="op">-</span> Δ <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> <span class="fl">1e-10</span>) <span class="op">+</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-7-camel-cards" class="level1">
<h1><a href="https://adventofcode.com/2023/day/7">Day 7: Camel Cards</a></h1>
<section id="part-1-6" class="level2">
<h2 class="anchored" data-anchor-id="part-1-6">Part 1</h2>
<p>This feels doable. The key is to find a method to compare two hands of cards. We can use <code class="verbatim">np.unique</code> to get the count of how many times each unique value appears in the hand, which is almost exactly what we need. If we sort this count, then two hands will compare correctly if we compare their count tuples, since tuples sort lexicographically. The final comparator is <code class="verbatim">[counts, [card_value for card in hand]]</code>, to correctly sort hands of the same type but with different values.</p>
<div class="cell" data-execution_count="14">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> counts(hand, part<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    hand <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> hand <span class="cf">if</span> x <span class="op">!=</span> <span class="st">"J"</span>] <span class="cf">if</span> part <span class="op">==</span> <span class="dv">2</span> <span class="cf">else</span> hand</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    _, counts <span class="op">=</span> np.unique([x <span class="cf">for</span> x <span class="kw">in</span> hand], return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> <span class="bu">sorted</span>(counts, reverse<span class="op">=</span><span class="va">True</span>) <span class="cf">if</span> hand <span class="cf">else</span> [<span class="dv">0</span>]</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    counts[<span class="dv">0</span>] <span class="op">+=</span> <span class="dv">5</span> <span class="op">-</span> <span class="bu">len</span>(hand)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> counts</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [x.strip().split() <span class="cf">for</span> x <span class="kw">in</span> load(<span class="dv">7</span>)]</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>order <span class="op">=</span> <span class="bu">sorted</span>(</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    data, key<span class="op">=</span><span class="kw">lambda</span> row: [counts(row[<span class="dv">0</span>]), [<span class="st">"23456789TJQKA"</span>.index(c) <span class="cf">for</span> c <span class="kw">in</span> row[<span class="dv">0</span>]]]</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>([<span class="bu">int</span>(x[<span class="dv">1</span>]) <span class="cf">for</span> x <span class="kw">in</span> order] <span class="op">*</span> np.arange(<span class="dv">1</span>, <span class="dv">1</span> <span class="op">+</span> <span class="bu">len</span>(order)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-6" class="level2">
<h2 class="anchored" data-anchor-id="part-2-6">Part 2</h2>
<p>Part 2 was similar enough to part 1 that I just made a flag in the <code class="verbatim">counts</code> function and changed the order of the card values</p>
<div class="cell" data-execution_count="15">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>order <span class="op">=</span> <span class="bu">sorted</span>(</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    data,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    key<span class="op">=</span><span class="kw">lambda</span> row: [</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        counts(row[<span class="dv">0</span>], part<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        [<span class="st">"J23456789TQKA"</span>.index(c) <span class="cf">for</span> c <span class="kw">in</span> row[<span class="dv">0</span>]],</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>([<span class="bu">int</span>(x[<span class="dv">1</span>]) <span class="cf">for</span> x <span class="kw">in</span> order] <span class="op">*</span> np.arange(<span class="dv">1</span>, <span class="dv">1</span> <span class="op">+</span> <span class="bu">len</span>(order)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-8-haunted-wasteland" class="level1">
<h1><a href="https://adventofcode.com/2023/day/8">Day 8: Haunted Wasteland</a></h1>
<section id="part-1-7" class="level2">
<h2 class="anchored" data-anchor-id="part-1-7">Part 1</h2>
<p>For part 1 we build a dictionary of left, right instructions for each node, which makes following a path from start to end easy.</p>
<div class="cell" data-execution_count="16">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>instructions, lines <span class="op">=</span> load(<span class="dv">8</span>, <span class="st">"raw"</span>).split(<span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>instructions <span class="op">=</span> instructions.strip()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [words <span class="cf">for</span> line <span class="kw">in</span> lines.split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>) <span class="cf">if</span> (words <span class="op">:=</span> re.findall(<span class="st">"[A-Z]+"</span>, line))]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> {node: {<span class="st">"L"</span>: left, <span class="st">"R"</span>: right} <span class="cf">for</span> node, left, right <span class="kw">in</span> data}</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>node <span class="op">=</span> <span class="st">"AAA"</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> node <span class="op">!=</span> <span class="st">"ZZZ"</span>:</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    node <span class="op">=</span> nodes[node][instructions[i <span class="op">%</span> <span class="bu">len</span>(instructions)]]</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>i</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-7" class="level2">
<h2 class="anchored" data-anchor-id="part-2-7">Part 2</h2>
<p>Part 2 screams cycle checking, and indeed it is. The state at any given time is given by the current node and the index of the instruction list. If we ever see the same state twice, we know we’re in a cycle, and can figure out the period. All of the cycles turn out to have periods that match the offset from the start, so we can just use the <code class="verbatim">lcm</code> to find the common period. If some of the cycles had had a different offset, we would have need the full chinese remainder theorem.</p>
<div class="cell" data-execution_count="17">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>periods <span class="op">=</span> []</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_cycle(node):</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> {}</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> <span class="va">None</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (node, i <span class="op">%</span> <span class="bu">len</span>(instructions)) <span class="kw">not</span> <span class="kw">in</span> seen:</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        seen[node, i <span class="op">%</span> <span class="bu">len</span>(instructions)] <span class="op">=</span> i</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> nodes[node][instructions[i <span class="op">%</span> <span class="bu">len</span>(instructions)]]</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="st">"Z"</span>:</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> i</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    period <span class="op">=</span> i <span class="op">-</span> seen[(node, i <span class="op">%</span> <span class="bu">len</span>(instructions))]</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> period, z <span class="op">%</span> period</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>periods, congruences <span class="op">=</span> <span class="bu">list</span>(</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">zip</span>(<span class="op">*</span>[find_cycle(node) <span class="cf">for</span> node <span class="kw">in</span> nodes <span class="cf">if</span> node[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="st">"A"</span>])</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>math.lcm(<span class="op">*</span>periods)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-9-mirage-maintenance" class="level1">
<h1><a href="https://adventofcode.com/2023/day/9">Day 9: Mirage Maintenance</a></h1>
<section id="part-1-8" class="level2">
<h2 class="anchored" data-anchor-id="part-1-8">Part 1</h2>
<p>This one’s pretty straightforward: calculate all the needed differences; add the last element of each difference to the calculation.</p>
<div class="cell" data-execution_count="18">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> score(line, part<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> part <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        line <span class="op">=</span> line[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">any</span>(line):</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> line[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        line <span class="op">=</span> [line[i] <span class="op">-</span> line[i <span class="op">-</span> <span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(line))]</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(score(line) <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">9</span>, <span class="st">"int"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-8" class="level2">
<h2 class="anchored" data-anchor-id="part-2-8">Part 2</h2>
<p>…and part 2 is simple enough that it can be included in part 1 with a flag</p>
<div class="cell" data-execution_count="19">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(score(line, part<span class="op">=</span><span class="dv">2</span>) <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">9</span>, <span class="st">"int"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-10-pipe-maze" class="level1">
<h1><a href="https://adventofcode.com/2023/day/10">Day 10: Pipe Maze</a></h1>
<section id="part-1-9" class="level2">
<h2 class="anchored" data-anchor-id="part-1-9">Part 1</h2>
<p>For part 1 we find the two directions leading away from the starting point, and follow the path along each one at the same pace. The point where they overlap is the point furthest away from the start, so we return that.</p>
<div class="cell" data-execution_count="20">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.pad(</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    np.array([[char <span class="cf">for</span> char <span class="kw">in</span> line.strip()] <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">10</span>)]),</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>,</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    constant_values<span class="op">=</span><span class="st">"."</span>,</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>connections <span class="op">=</span> {</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"-"</span>: [(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>), (<span class="dv">0</span>, <span class="dv">1</span>)],</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"|"</span>: [(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="dv">0</span>)],</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"L"</span>: [(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">1</span>)],</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"J"</span>: [(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)],</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">"7"</span>: [(<span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)],</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"F"</span>: [(<span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">1</span>)],</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"."</span>: [],</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>Δs <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>], [<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>point <span class="op">=</span> np.array(<span class="bu">next</span>(<span class="bu">zip</span>(<span class="op">*</span>np.where(data <span class="op">==</span> <span class="st">"S"</span>))))</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>(lx, lv), (rx, rv) <span class="op">=</span> [</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    (point <span class="op">+</span> Δ, Δ) <span class="cf">for</span> Δ <span class="kw">in</span> Δs <span class="cf">if</span> <span class="bu">tuple</span>(<span class="op">-</span>Δ) <span class="kw">in</span> connections[data[<span class="bu">tuple</span>(point <span class="op">+</span> Δ)]]</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update(point, direction):</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    options <span class="op">=</span> connections[data[<span class="bu">tuple</span>(point)]]</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    new_direction <span class="op">=</span> np.array(</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>        options[<span class="dv">1</span>] <span class="cf">if</span> <span class="bu">tuple</span>(<span class="op">-</span>direction) <span class="op">==</span> options[<span class="dv">0</span>] <span class="cf">else</span> options[<span class="dv">0</span>]</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> point <span class="op">+</span> new_direction, new_direction</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>left_path <span class="op">=</span> [point, lx]</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>right_path <span class="op">=</span> [rx]</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="kw">not</span> np.allclose(lx, rx):</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>    lx, lv <span class="op">=</span> update(lx, lv)</span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>    left_path.append(lx)</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>    rx, rv <span class="op">=</span> update(rx, rv)</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>    right_path.append(rx)</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>i</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-9" class="level2">
<h2 class="anchored" data-anchor-id="part-2-9">Part 2</h2>
<p>For part 2, we need some way of distinguishing points inside from outside the circuit. Since the lines that make up the boundary of the circuit never cross, this is a point in polygon problem. We could solve it by raytracing: for every point in the polygon we can draw all rays to the outside edge and see if they cross the boundary of the polygon an odd number of times. If they do, the point is inside the polygon. We could also look at the winding number of the polygon with respect the the point: points inside will have a nonzero winding number, while points outside will have a positive winding number.</p>
<p>Ultimately, what I ended up doing was just blowing up the grid to double size, flood filling the outside and looking at the even coordinate values of whatever was left. It’s stupid, but it works.</p>
<div class="cell" data-execution_count="21">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>ys, xs <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>(left_path <span class="op">+</span> right_path[:<span class="op">-</span><span class="dv">1</span>][::<span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>dy, dx <span class="op">=</span> np.diff([ys <span class="op">+</span> (ys[<span class="dv">0</span>],), xs <span class="op">+</span> (xs[<span class="dv">0</span>],)], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>board <span class="op">=</span> np.ones((data.shape[<span class="dv">0</span>] <span class="op">*</span> <span class="dv">2</span>, data.shape[<span class="dv">1</span>] <span class="op">*</span> <span class="dv">2</span>))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>ys, xs <span class="op">=</span> <span class="bu">map</span>(np.array, [ys, xs])</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>board[<span class="dv">2</span> <span class="op">*</span> ys, <span class="dv">2</span> <span class="op">*</span> xs] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>board[<span class="dv">2</span> <span class="op">*</span> ys <span class="op">+</span> dy, <span class="dv">2</span> <span class="op">*</span> xs <span class="op">+</span> dx] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>board <span class="op">=</span> np.pad(board[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>], <span class="dv">1</span>, constant_values<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> deque([(<span class="dv">1</span>, <span class="dv">1</span>)])</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> points:</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    point <span class="op">=</span> points.popleft()</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> board[point] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    board[point] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> Δ <span class="kw">in</span> Δs:</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        nb <span class="op">=</span> <span class="bu">tuple</span>(Δ <span class="op">+</span> point)</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> board[nb]:</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>            points.append(nb)</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a><span class="bu">int</span>(board[::<span class="dv">2</span>, ::<span class="dv">2</span>].<span class="bu">sum</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-11-cosmic-expansion" class="level1">
<h1><a href="https://adventofcode.com/2023/day/11">Day 11: Cosmic Expansion</a></h1>
<section id="part-1-10" class="level2">
<h2 class="anchored" data-anchor-id="part-1-10">Part 1</h2>
<p>I liked this puzzle, and I feel that I managed to come up with an OK slick array solution. We can get the coordinates of the original galaxies and the empty rows using <code class="verbatim">np.where</code>. For each empty row we can increase the first coordinate of the galaxies below it by some amount, and, mutatis mutandis, we can do the same for the empty columns.</p>
<p>That gives us a set of new coordinates, and we need to find the sum of all the manhattan distances from one point to the others. for any pair of points <span class="math inline">\(i, j\)</span>, that’s <span class="math inline">\(\left|x_i - x_j\right| +\left|y_i - y_j\right|\)</span>; we can construct the entire matrix by taking the row vector of coordinates, and subtracting from it the column vector of the same coordinates and relying on <code class="verbatim">numpy</code>’s broadcasting magic.</p>
<div class="cell" data-execution_count="22">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> solve(s<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    y, x <span class="op">=</span> np.where(data <span class="op">==</span> <span class="st">"#"</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    empty_r <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(data)) <span class="cf">if</span> <span class="bu">all</span>(data[i] <span class="op">==</span> <span class="st">"."</span>)]</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    empty_c <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(data)) <span class="cf">if</span> <span class="bu">all</span>(data[:, i] <span class="op">==</span> <span class="st">"."</span>)]</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    new_y <span class="op">=</span> y <span class="op">+</span> s <span class="op">*</span> np.array([y <span class="op">&gt;</span> empty_r[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(empty_r))]).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    new_x <span class="op">=</span> x <span class="op">+</span> s <span class="op">*</span> np.array([x <span class="op">&gt;</span> empty_c[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(empty_c))]).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">abs</span>(new_y <span class="op">-</span> new_y.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">+</span> <span class="bu">abs</span>(new_x <span class="op">-</span> new_x.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    ).<span class="bu">sum</span>() <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">11</span>, <span class="st">"chararray"</span>)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>solve()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-10" class="level2">
<h2 class="anchored" data-anchor-id="part-2-10">Part 2</h2>
<p>The second part is pretty trivially included in the first</p>
<div class="cell" data-execution_count="23">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>solve(<span class="dv">999_999</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-12-hot-springs" class="level1">
<h1><a href="https://adventofcode.com/2023/day/12">Day 12: Hot Springs</a></h1>
<section id="part-1-11" class="level2">
<h2 class="anchored" data-anchor-id="part-1-11">Part 1</h2>
<p>The core of this solution is the <code class="verbatim">count</code> function, which takes a tuple of ints representing the three states (off, ambiguous and on), as well as a tuple of block lengths, and returns the number of assignments of the ambiguous values that work.</p>
<p>It’s recursive, with the following base cases; the third is checked last:</p>
<ul>
<li>If the number of on values is more than the sum of block lengths, no assignments are possible</li>
<li>If the sum of the number of on values and ambiguous values is less than the sum of block lengths, no assignments are possible</li>
<li>If the sum of block lengths is zero, exactly one assignment is possible</li>
</ul>
<p>Otherwise, if the first character is off, then the count is the same as the count ignoring that assignment and we can recurse.</p>
<p>If the first character is on, we can check whether the first <code class="verbatim">l</code> characters would fit the first block, and the <code class="verbatim">l+1</code>’th character is either the end of the string or compatible with an off state. If it is, the count is the same as the count for the remainder of the string on the remainder of the blocks and we can recurse.</p>
<p>Finally, if the first character is ambiguous, the count is the sum of the counts for the two possible assignments of the character, and we can recurse.</p>
<div class="cell" data-execution_count="24">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse(line):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    s, groups <span class="op">=</span> line.strip().split(<span class="st">" "</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    lookup <span class="op">=</span> {<span class="st">"#"</span>: <span class="dv">2</span>, <span class="st">"?"</span>: <span class="dv">1</span>, <span class="st">"."</span>: <span class="dv">0</span>}</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">tuple</span>(lookup[char] <span class="cf">for</span> char <span class="kw">in</span> s), <span class="bu">tuple</span>(<span class="bu">int</span>(g) <span class="cf">for</span> g <span class="kw">in</span> groups.split(<span class="st">","</span>))</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [parse(x) <span class="cf">for</span> x <span class="kw">in</span> load(<span class="dv">12</span>)]</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> match_beginning(data, length):</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">all</span>(x <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> data[:length]) <span class="kw">and</span> (</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>        (<span class="bu">len</span>(data) <span class="op">==</span> length) <span class="kw">or</span> data[length] <span class="op">&lt;</span> <span class="dv">2</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a><span class="at">@functools.cache</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count(data, blocks):</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="bu">sum</span>(blocks)</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    minimum <span class="op">=</span> <span class="bu">sum</span>(x <span class="op">==</span> <span class="dv">2</span> <span class="cf">for</span> x <span class="kw">in</span> data)</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    maximum <span class="op">=</span> <span class="bu">sum</span>(x <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> data)</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> minimum <span class="op">&gt;</span> total <span class="kw">or</span> maximum <span class="op">&lt;</span> total:</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> total <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> data[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count(data[<span class="dv">1</span>:], blocks)</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> data[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> blocks[<span class="dv">0</span>]</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> match_beginning(data, l):</span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> l <span class="op">==</span> <span class="bu">len</span>(data):</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> count(data[l <span class="op">+</span> <span class="dv">1</span> :], blocks[<span class="dv">1</span>:])</span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count(data[<span class="dv">1</span>:], blocks) <span class="op">+</span> count((<span class="dv">2</span>,) <span class="op">+</span> data[<span class="dv">1</span>:], blocks)</span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(count(<span class="op">*</span>line) <span class="cf">for</span> line <span class="kw">in</span> data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-11" class="level2">
<h2 class="anchored" data-anchor-id="part-2-11">Part 2</h2>
<p>With the memoization added to part 1, part 2 runs in 8s with no changes needed. Not great, but not terrible</p>
<div class="cell" data-execution_count="25">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(count(((chars <span class="op">+</span> (<span class="dv">1</span>,)) <span class="op">*</span> <span class="dv">5</span>)[:<span class="op">-</span><span class="dv">1</span>], blocks <span class="op">*</span> <span class="dv">5</span>) <span class="cf">for</span> chars, blocks <span class="kw">in</span> data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-13-point-of-incidence" class="level1">
<h1><a href="https://adventofcode.com/2023/day/13">Day 13: Point of Incidence</a></h1>
<section id="part-1-12" class="level2">
<h2 class="anchored" data-anchor-id="part-1-12">Part 1</h2>
<p>This wasn’t too tricky. The idea is that we test all horizontal lines of reflection to see if there are any that match the given condition; if none are found, we rotate the array by 90 degrees clockwise and try again. For part 1, the test is that the two halves should line up exactly after flipping.</p>
<p>The only bit that requires some thought is how to account for the points beyond the top/bottom edge. We do that by saying that the number of lines on either side of the mirror line is the shortest distance to the top/bottom edge, so that only relevant lines are compared.</p>
<div class="cell" data-execution_count="26">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_reflection(array, part<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> part <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        test <span class="op">=</span> <span class="kw">lambda</span> a, b: (a <span class="op">==</span> b[::<span class="op">-</span><span class="dv">1</span>]).<span class="bu">all</span>()</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        test <span class="op">=</span> <span class="kw">lambda</span> a, b: (a <span class="op">!=</span> b[::<span class="op">-</span><span class="dv">1</span>]).<span class="bu">sum</span>() <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(array)):</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> <span class="bu">min</span>(<span class="bu">len</span>(array) <span class="op">-</span> i, i)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> test(array[i <span class="op">-</span> l : i], array[i : i <span class="op">+</span> l]):</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> i</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>arrays <span class="op">=</span> [</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    np.array([[char <span class="cf">for</span> char <span class="kw">in</span> line.strip()] <span class="cf">for</span> line <span class="kw">in</span> array.split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)])</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> array <span class="kw">in</span> load(<span class="dv">13</span>, <span class="st">"raw"</span>).split(<span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    <span class="dv">100</span> <span class="op">*</span> y</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (y <span class="op">:=</span> find_reflection(array)) <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> find_reflection(np.rot90(array, <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> array <span class="kw">in</span> arrays</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-12" class="level2">
<h2 class="anchored" data-anchor-id="part-2-12">Part 2</h2>
<p>Part 2 is so similar to part 1 that we can include it as a flag there; instead of a perfect match, the test is that exactly one pair of elements should be different on the two sides of the mirror line. Conceptually, that means that the sum of the differences should be exactly 1.</p>
<div class="cell" data-execution_count="27">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">100</span> <span class="op">*</span> y</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (y <span class="op">:=</span> find_reflection(array, part<span class="op">=</span><span class="dv">2</span>)) <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> find_reflection(np.rot90(array, <span class="op">-</span><span class="dv">1</span>), part<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> array <span class="kw">in</span> arrays</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-14-parabolic-reflector-dish" class="level1">
<h1><a href="https://adventofcode.com/2023/day/14">Day 14: Parabolic Reflector Dish</a></h1>
<section id="part-1-13" class="level2">
<h2 class="anchored" data-anchor-id="part-1-13">Part 1</h2>
<p>Part 1 needs a bit of thought. I’ll represent the data as a <code class="verbatim">numpy</code> array, with -1 corresponding to unmoveable rock, 0 to rolling rock, and 1 to empty space. To roll all the rocks northwards, we should focus one column at a time, and between every pair of unmoveable rocks, we sort the intervening data.</p>
<p>Once that’s done, we can just score the whole array</p>
<div class="cell" data-execution_count="28">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>map_ <span class="op">=</span> {<span class="st">"#"</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">"O"</span>: <span class="dv">0</span>, <span class="st">"."</span>: <span class="dv">1</span>}</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>array <span class="op">=</span> np.array([[map_[char] <span class="cf">for</span> char <span class="kw">in</span> line] <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">14</span>)])</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>nrows, ncols <span class="op">=</span> array.shape</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> score(array):</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    rolls <span class="op">=</span> np.where(array <span class="op">==</span> <span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (nrows <span class="op">-</span> rolls).<span class="bu">sum</span>()</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> roll(array):</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncols):</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>        rocks <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="bu">list</span>(np.where(array[:, i] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>)[<span class="dv">0</span>]) <span class="op">+</span> [<span class="va">None</span>]</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(rocks) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>            left, right <span class="op">=</span> rocks[j] <span class="op">+</span> <span class="dv">1</span>, rocks[j <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>            array[left:right, i] <span class="op">=</span> np.sort(array[left:right, i])</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> array</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>score(roll(array))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-13" class="level2">
<h2 class="anchored" data-anchor-id="part-2-13">Part 2</h2>
<p>The numbers in part 2 are ridiculous enough that we obviously have to hope for some pattern in how the rocks move. We’ll store a fingerprint of the current state, and after each cycle, check if we’re in a state we’ve seen before. If we are, we’ve found a cycle and can skip straight to the end.</p>
<div class="cell" data-execution_count="29">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cycle(array):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        array <span class="op">=</span> roll(array)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>        array <span class="op">=</span> np.rot90(array, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> array</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hash_(array):</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">tuple</span>(array.ravel())</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>seen, scores <span class="op">=</span> {}, {}</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>maxval <span class="op">=</span> <span class="dv">1_000_000_000</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(maxval):</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> hash_(array)</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> h <span class="kw">in</span> seen:</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    seen[h] <span class="op">=</span> i</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>    scores[i] <span class="op">=</span> score(array)</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>    array <span class="op">=</span> cycle(array)</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>cycle_length <span class="op">=</span> i <span class="op">-</span> seen[h]</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> seen[h] <span class="op">+</span> (maxval <span class="op">-</span> seen[h]) <span class="op">%</span> cycle_length</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>scores[index]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-15-lens-library" class="level1">
<h1><a href="https://adventofcode.com/2023/day/15">Day 15: Lens Library</a></h1>
<section id="part-1-14" class="level2">
<h2 class="anchored" data-anchor-id="part-1-14">Part 1</h2>
<p>Part 1 can be done with a single expression. Always nice when that happens. I originally had both the hash function and the data loading directly in the sum generator expression, but I needed them for part two so I pulled them out to their own lines.</p>
<div class="cell" data-execution_count="30">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hash_(s):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> functools.<span class="bu">reduce</span>(<span class="kw">lambda</span> x, y: (<span class="dv">17</span> <span class="op">*</span> (x <span class="op">+</span> <span class="bu">ord</span>(y))) <span class="op">%</span> <span class="dv">256</span>, s, <span class="dv">0</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>instructions <span class="op">=</span> load(<span class="dv">15</span>, <span class="st">"raw"</span>).split(<span class="st">","</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(hash_(i) <span class="cf">for</span> i <span class="kw">in</span> instructions)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-14" class="level2">
<h2 class="anchored" data-anchor-id="part-2-14">Part 2</h2>
<p>Part 2 is fiddly and less fun. We need to run through each of the instructions and apply the procedure described. There might be better ways than this, but the below works:</p>
<div class="cell" data-execution_count="31">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>boxes <span class="op">=</span> [{} <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">256</span>)]</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> instruction <span class="kw">in</span> instructions:</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    label, f <span class="op">=</span> instruction.replace(<span class="st">"-"</span>, <span class="st">"="</span>).split(<span class="st">"="</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    destination <span class="op">=</span> hash_(label)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">"="</span> <span class="kw">in</span> instruction:</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>        boxes[destination][label] <span class="op">=</span> <span class="bu">int</span>(f)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> label <span class="kw">in</span> boxes[destination]:</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> boxes[destination][label]</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> score(box):</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="bu">list</span>(box.values()) <span class="op">*</span> np.arange(<span class="dv">1</span>, <span class="bu">len</span>(box) <span class="op">+</span> <span class="dv">1</span>)).<span class="bu">sum</span>()</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="bu">int</span>(<span class="bu">sum</span>(np.arange(<span class="dv">1</span>, <span class="dv">257</span>) <span class="op">*</span> [score(box) <span class="cf">for</span> box <span class="kw">in</span> boxes]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-16-the-floor-will-be-lava" class="level1">
<h1><a href="https://adventofcode.com/2023/day/16">Day 16: The Floor Will Be Lava</a></h1>
<section id="part-1-15" class="level2">
<h2 class="anchored" data-anchor-id="part-1-15">Part 1</h2>
<p>Part 1 is fairly straightforward. We’ll need a way of tracking states we’ve already seen, and a recipe for moving from one state to the next. A state consists of a (position, direction) pair; if we ever hit a position and direction we’ve seen before we know we’re not going to do anything new (and that there’s an infinite loop in the light circuit).</p>
<p>We’ll store the grid as a dictionary of coordinates -&gt; value, with the x and y coordinates encoded as a single complex number. That makes checking for when we’ve left the edge of the grid easy; we just have to check if the current coordinates are in the dictionary.</p>
<p>The diagonal mirrors transpose the coordinates of our direction, so that horizontal movement becomes vertical and vice versa. The beam splitters force us into vertical/horizontal movement and make us add an extra beam to the queue we’re going through.</p>
<div class="cell" data-execution_count="32">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">16</span>, <span class="st">"chararray"</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> {</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">1j</span> <span class="op">*</span> y <span class="op">+</span> x: data[y, x] <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(data.shape[<span class="dv">1</span>]) <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(data.shape[<span class="dv">0</span>])</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_points(position, direction):</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    positions <span class="op">=</span> deque([(position, direction)])</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> positions:</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>        position, direction <span class="op">=</span> positions.popleft()</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> position <span class="kw">in</span> grid:</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (position, direction) <span class="kw">in</span> seen:</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>            seen.add((position, direction))</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>            char <span class="op">=</span> grid[position]</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> char <span class="kw">in</span> <span class="st">"/</span><span class="ch">\\</span><span class="st">"</span>:</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>                direction <span class="op">=</span> <span class="bu">int</span>(direction.imag) <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> <span class="bu">int</span>(direction.real)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>                direction <span class="op">*=</span> <span class="op">-</span><span class="dv">1</span> <span class="cf">if</span> char <span class="op">==</span> <span class="st">"/"</span> <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> char <span class="op">==</span> <span class="st">"-"</span> <span class="kw">and</span> direction.imag:</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>                positions.append((position <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>                direction <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> char <span class="op">==</span> <span class="st">"|"</span> <span class="kw">and</span> direction.real:</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>                positions.append((position <span class="op">-</span> <span class="ot">1j</span>, <span class="op">-</span><span class="ot">1j</span>))</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>                direction <span class="op">=</span> <span class="ot">1j</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>            position <span class="op">+=</span> direction</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(<span class="bu">set</span>(x[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> seen))</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>count_points(<span class="dv">0</span>, <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-15" class="level2">
<h2 class="anchored" data-anchor-id="part-2-15">Part 2</h2>
<p>For part two we could probably do some clever memoization by making the above function recurse on beam splitters.</p>
<p>One potential disadvantage of that is that the input might contain infinite loops of light which require global information to be discovered. Passing this information to the memoized function would mean that we almost never get a cache hit, while not passing it risks getting stuck in an infinite loop.</p>
<p>Finally, brute force runs in an acceptable amount of time:</p>
<div class="cell" data-execution_count="33">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> starting_position(direction, length):</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">=</span> data.shape[<span class="dv">0</span>] <span class="cf">if</span> (direction.imag <span class="op">+</span> direction.real) <span class="op">&lt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">*=</span> <span class="ot">1j</span> <span class="cf">if</span> direction.imag <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> offset <span class="op">+</span> (<span class="ot">1j</span> <span class="cf">if</span> direction.real <span class="cf">else</span> <span class="dv">1</span>) <span class="op">*</span> length</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="bu">max</span>(</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    count_points(starting_position(direction, x), direction)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(data.shape[<span class="dv">0</span>])</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> direction <span class="kw">in</span> (<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="op">-</span><span class="ot">1j</span>, <span class="ot">1j</span>)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-17-clumsy-crucible" class="level1">
<h1><a href="https://adventofcode.com/2023/day/17">Day 17: Clumsy Crucible</a></h1>
<section id="part-1-16" class="level2">
<h2 class="anchored" data-anchor-id="part-1-16">Part 1</h2>
<p>Our first pathfinding task! I couldn’t think of a good &amp; simple-to-calculate heuristic, so we’ll just go with Dijkstra instead of A*.</p>
<p>We’re given the restriction that a cart must turn after at most three moves. The cost for a move can just be read out from the input grid, so the only question is how we represent a state and what the neighbors of each state are.</p>
<p>With the turning restriction, it makes sense to focus on where the cart turns, rather than where it moves. This means that a state can be represented by a tuple of <code class="verbatim">(y, x, direction)</code>, where direction is 0 if the cart is moving vertically after the turn and 1 if it’s moving horizontally. The neighbors of a state are then the places where the cart could have its next turn, i.e.&nbsp;the points up to three tiles away vertically or horizontally, with movement along the other axis after the turn.</p>
<p>Implementing it looks like this:</p>
<div class="cell" data-execution_count="34">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> navigate(grid, minval<span class="op">=</span><span class="dv">1</span>, maxval<span class="op">=</span><span class="dv">3</span>):</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> PriorityQueue()</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    max_y, max_x <span class="op">=</span> (v <span class="op">-</span> <span class="dv">1</span> <span class="cf">for</span> v <span class="kw">in</span> grid.shape)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    goal <span class="op">=</span> max_y, max_x</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    q.put((<span class="dv">0</span>, (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)))</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    q.put((<span class="dv">0</span>, (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>)))</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>        cost, (y, x, direction) <span class="op">=</span> q.get()</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (y, x) <span class="op">==</span> goal:</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (y, x, direction) <span class="kw">in</span> seen:</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>        seen.add((y, x, direction))</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>        original_cost <span class="op">=</span> cost</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>]:</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">=</span> original_cost</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>            new_y, new_x <span class="op">=</span> y, x</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, maxval <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> direction <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>                    new_x <span class="op">=</span> x <span class="op">+</span> i <span class="op">*</span> s</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>                    new_y <span class="op">=</span> y <span class="op">+</span> i <span class="op">*</span> s</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> new_x <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> new_y <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> new_x <span class="op">&gt;</span> max_x <span class="kw">or</span> new_y <span class="op">&gt;</span> max_y:</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>                cost <span class="op">+=</span> grid[new_y, new_x]</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> ((new_y, new_x, <span class="dv">1</span> <span class="op">-</span> direction)) <span class="kw">in</span> seen:</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">&gt;=</span> minval:</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>                    q.put((cost, (new_y, new_x, <span class="dv">1</span> <span class="op">-</span> direction)))</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cost</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> np.array([[<span class="bu">int</span>(char) <span class="cf">for</span> char <span class="kw">in</span> line.strip()] <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">17</span>)])</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>navigate(grid)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-16" class="level2">
<h2 class="anchored" data-anchor-id="part-2-16">Part 2</h2>
<p>Part 2 can be incorporated into the above code by changing the maximum number of allowed moves before a turn, and by only allowing turns after the crucible has moved at least <code class="verbatim">minval</code> steps. That’s easy to incorporate into the function for part 1, so the code just looks like:</p>
<div class="cell" data-execution_count="35">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>navigate(grid, <span class="dv">4</span>, <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-18-lavaduct-lagoon" class="level1">
<h1><a href="https://adventofcode.com/2023/day/18">Day 18: Lavaduct Lagoon</a></h1>
<section id="part-1-17" class="level2">
<h2 class="anchored" data-anchor-id="part-1-17">Part 1</h2>
<p>We’ll run through the list of instructions and make a list of the coordinates of all the vertices. Then we’ll use the shoelace formula to calculate the area of the described polygon. To account for the line of paint at the edge of the polygon, we’ll add half the perimeter of the polygon (which corresponds to increasing the total thickness of the polygon by 1 everywhere), and finally add one to correct for the missing paint in the exterior corners. There will always be four more exterior corners than interior corners, since going all the way around the polygon once is a 360 degree rotation.</p>
<div class="cell" data-execution_count="36">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>ys, xs <span class="op">=</span> [<span class="dv">0</span>], [<span class="dv">0</span>]</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>position <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>directions <span class="op">=</span> {<span class="st">"U"</span>: [<span class="dv">0</span>, <span class="dv">1</span>], <span class="st">"R"</span>: [<span class="dv">1</span>, <span class="dv">0</span>], <span class="st">"D"</span>: [<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>], <span class="st">"L"</span>: [<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>]}</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> direction, count, _ <span class="kw">in</span> <span class="bu">map</span>(<span class="bu">str</span>.split, load(<span class="dv">18</span>)):</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    position <span class="op">+=</span> np.array(directions[direction]) <span class="op">*</span> (<span class="bu">int</span>(count))</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    xs.append(position[<span class="dv">0</span>])</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    ys.append(position[<span class="dv">1</span>])</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="bu">int</span>(</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    ((xs <span class="op">*</span> (np.roll(ys, <span class="dv">1</span>) <span class="op">-</span> np.roll(ys, <span class="op">-</span><span class="dv">1</span>))).<span class="bu">sum</span>()) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> <span class="bu">sum</span>(<span class="bu">abs</span>(np.diff(ys)) <span class="op">+</span> <span class="bu">abs</span>(np.diff(xs))) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-17" class="level2">
<h2 class="anchored" data-anchor-id="part-2-17">Part 2</h2>
<p>I was not expecting part 2 to go there! Luckily, nothing changes with respect to what we did above apart from how we build the path around the polygon</p>
<div class="cell" data-execution_count="37">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>ys, xs <span class="op">=</span> [<span class="dv">0</span>], [<span class="dv">0</span>]</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>position <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>order <span class="op">=</span> <span class="st">"RDLU"</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> real_instruction <span class="kw">in</span> <span class="bu">map</span>(<span class="kw">lambda</span> x: x.split()[<span class="op">-</span><span class="dv">1</span>][<span class="dv">2</span>:<span class="op">-</span><span class="dv">1</span>], load(<span class="dv">18</span>)):</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    count, direction <span class="op">=</span> real_instruction[:<span class="op">-</span><span class="dv">1</span>], real_instruction[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    position <span class="op">+=</span> np.array(directions[order[<span class="bu">int</span>(direction)]]) <span class="op">*</span> <span class="bu">int</span>(count, <span class="dv">16</span>)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    xs.append(position[<span class="dv">0</span>])</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    ys.append(position[<span class="dv">1</span>])</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="bu">int</span>(</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    ((xs <span class="op">*</span> (np.roll(ys, <span class="dv">1</span>) <span class="op">-</span> np.roll(ys, <span class="op">-</span><span class="dv">1</span>))).<span class="bu">sum</span>()) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> <span class="bu">sum</span>(<span class="bu">abs</span>(np.diff(ys)) <span class="op">+</span> <span class="bu">abs</span>(np.diff(xs))) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-19-aplenty" class="level1">
<h1><a href="https://adventofcode.com/2023/day/19">Day 19: Aplenty</a></h1>
<section id="part-1-18" class="level2">
<h2 class="anchored" data-anchor-id="part-1-18">Part 1</h2>
<div class="cell" data-execution_count="38">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>workflows, parts <span class="op">=</span> [x.split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>) <span class="cf">for</span> x <span class="kw">in</span> load(<span class="dv">19</span>, <span class="st">"raw"</span>).split(<span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)]</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>Part <span class="op">=</span> namedtuple(<span class="st">"Part"</span>, <span class="st">"x m a s"</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>parts <span class="op">=</span> [Part(<span class="op">*</span>[<span class="bu">int</span>(x) <span class="cf">for</span> x <span class="kw">in</span> re.findall(<span class="vs">r"\+?-?\d+"</span>, part)]) <span class="cf">for</span> part <span class="kw">in</span> parts]</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>name, instructions <span class="op">=</span> workflows[<span class="dv">0</span>][:<span class="op">-</span><span class="dv">1</span>].split(<span class="st">"{"</span>)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>instruction_map <span class="op">=</span> {}</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, instructions <span class="kw">in</span> <span class="bu">map</span>(<span class="kw">lambda</span> x: x[:<span class="op">-</span><span class="dv">1</span>].split(<span class="st">"{"</span>), workflows):</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    rules <span class="op">=</span> [</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>        rule.split(<span class="st">":"</span>) <span class="cf">if</span> <span class="st">":"</span> <span class="kw">in</span> rule <span class="cf">else</span> [<span class="kw">lambda</span> y: <span class="va">True</span>, rule]</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> rule <span class="kw">in</span> instructions.split(<span class="st">","</span>)</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    rules <span class="op">=</span> [</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>        (<span class="bu">eval</span>(<span class="st">"lambda y: y."</span> <span class="op">+</span> rule[<span class="dv">0</span>]), rule[<span class="dv">1</span>]) <span class="cf">if</span> <span class="bu">isinstance</span>(rule[<span class="dv">0</span>], <span class="bu">str</span>) <span class="cf">else</span> rule</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> rule <span class="kw">in</span> rules</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    instruction_map[name] <span class="op">=</span> instructions, rules</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> follow(part, state):</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    s, tests <span class="op">=</span> instruction_map[state]</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> test, output <span class="kw">in</span> tests:</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> test(part):</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> output <span class="op">==</span> <span class="st">"A"</span>:</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> output <span class="op">==</span> <span class="st">"R"</span>:</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> follow(part, output)</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(x.x <span class="op">+</span> x.m <span class="op">+</span> x.a <span class="op">+</span> x.s <span class="cf">for</span> x <span class="kw">in</span> parts <span class="cf">if</span> follow(x, <span class="st">"in"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="part-2-18" class="level2">
<h2 class="anchored" data-anchor-id="part-2-18">Part 2</h2>
<p>So, I thought I was being clever above by <code class="verbatim">eval</code>’ing the instructions to convert them directly to python functions. Unfortunately we have to modify the above approach to work with ranges of values rather than specific values, which has the effect of converting the filters from pass/faill to ones that split ranges in two - the parts that pass the filter, and the parts that don’t. I could go back and rework how I parsed the instructions in part 1 to fit with what I need to do for part 2, or I could just redo the parsing.</p>
<p>I’ll store each range as a dataclass of tuples, and each filter splits a range into at most two parts. The are half-open on the left, so that x = tuple(0, 5) represents the values [1, 2, 3, 4, 5]. The fact that they’re half-open lets us find the size of a range by just subtracting the endpoints, without having to fiddle with off-by one errors, and I chose to do it on the left so that the inital range can be represented by the pair of numbers (0, 4000) rather than the more ugly (1, 4001).</p>
<div class="cell" data-execution_count="39">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclasses.dataclass</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PartRange:</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    x: <span class="bu">tuple</span>[<span class="bu">int</span>]</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    m: <span class="bu">tuple</span>[<span class="bu">int</span>]</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    a: <span class="bu">tuple</span>[<span class="bu">int</span>]</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    s: <span class="bu">tuple</span>[<span class="bu">int</span>]</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_valid(interval):</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> interval[<span class="dv">1</span>] <span class="op">&gt;</span> interval[<span class="dv">0</span>]</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_coords(part_range, coordinate, cutoff, test):</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    coord_range <span class="op">=</span> <span class="bu">getattr</span>(part_range, coordinate)</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> test <span class="op">==</span> <span class="st">"&gt;"</span>:</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>        new_coords <span class="op">=</span> ((cutoff, coord_range[<span class="dv">1</span>]), (coord_range[<span class="dv">0</span>], cutoff))</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> test <span class="op">==</span> <span class="st">"&lt;"</span>:</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>        new_coords <span class="op">=</span> ((coord_range[<span class="dv">0</span>], cutoff <span class="op">-</span> <span class="dv">1</span>), (cutoff <span class="op">-</span> <span class="dv">1</span>, coord_range[<span class="dv">1</span>]))</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"This shouldn't be possible"</span>)</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> interval <span class="kw">in</span> new_coords:</span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> is_valid(interval):</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>            result.append(<span class="va">None</span>)</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>            result.append(dataclasses.replace(part_range, <span class="op">**</span>{coordinate: interval}))</span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> size(part_range):</span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.product([np.diff(<span class="bu">getattr</span>(part_range, i)) <span class="cf">for</span> i <span class="kw">in</span> <span class="st">"xmas"</span>])</span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_rule_string(rule):</span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">":"</span> <span class="kw">not</span> <span class="kw">in</span> rule:</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rule</span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>    coordinate <span class="op">=</span> rule[<span class="dv">0</span>]</span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>    test <span class="op">=</span> rule[<span class="dv">1</span>]</span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>    cutoff, destination <span class="op">=</span> rule[<span class="dv">2</span>:].split(<span class="st">":"</span>)</span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> coordinate, <span class="bu">int</span>(cutoff), test, destination</span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>instructions <span class="op">=</span> {}</span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, rules <span class="kw">in</span> <span class="bu">map</span>(<span class="kw">lambda</span> x: x[:<span class="op">-</span><span class="dv">1</span>].split(<span class="st">"{"</span>), workflows):</span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>    instructions[name] <span class="op">=</span> [parse_rule_string(rule) <span class="cf">for</span> rule <span class="kw">in</span> rules.split(<span class="st">","</span>)]</span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> follow(instructions):</span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> inner(part_range, state):</span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> <span class="st">"R"</span>:</span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> <span class="st">"A"</span>:</span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> size(part_range)</span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a>        rules <span class="op">=</span> instructions[state]</span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a>        remainder <span class="op">=</span> part_range</span>
<span id="cb39-57"><a href="#cb39-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> rule <span class="kw">in</span> rules:</span>
<span id="cb39-58"><a href="#cb39-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> remainder <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb39-59"><a href="#cb39-59" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb39-60"><a href="#cb39-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(rule, <span class="bu">str</span>):</span>
<span id="cb39-61"><a href="#cb39-61" aria-hidden="true" tabindex="-1"></a>                result <span class="op">+=</span> inner(remainder, rule)</span>
<span id="cb39-62"><a href="#cb39-62" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb39-63"><a href="#cb39-63" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb39-64"><a href="#cb39-64" aria-hidden="true" tabindex="-1"></a>                coordinate, cutoff, test, destination <span class="op">=</span> rule</span>
<span id="cb39-65"><a href="#cb39-65" aria-hidden="true" tabindex="-1"></a>                passed, remainder <span class="op">=</span> split_coords(remainder, coordinate, cutoff, test)</span>
<span id="cb39-66"><a href="#cb39-66" aria-hidden="true" tabindex="-1"></a>                result <span class="op">+=</span> inner(passed, destination) <span class="cf">if</span> passed <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb39-67"><a href="#cb39-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result</span>
<span id="cb39-68"><a href="#cb39-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-69"><a href="#cb39-69" aria-hidden="true" tabindex="-1"></a>    initial <span class="op">=</span> PartRange((<span class="dv">0</span>, <span class="dv">4000</span>), (<span class="dv">0</span>, <span class="dv">4000</span>), (<span class="dv">0</span>, <span class="dv">4000</span>), (<span class="dv">0</span>, <span class="dv">4000</span>))</span>
<span id="cb39-70"><a href="#cb39-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> inner(initial, <span class="st">"in"</span>)</span>
<span id="cb39-71"><a href="#cb39-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-72"><a href="#cb39-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-73"><a href="#cb39-73" aria-hidden="true" tabindex="-1"></a>follow(instructions)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-20-pulse-propagation" class="level1">
<h1><a href="https://adventofcode.com/2023/day/20">Day 20: Pulse Propagation</a></h1>
<div class="cell" data-execution_count="40">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">20</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>bus <span class="op">=</span> []</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Module:</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, destinations):</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> name</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.destinations <span class="op">=</span> destinations</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> send(<span class="va">self</span>):</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> destination <span class="kw">in</span> <span class="va">self</span>.destinations:</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>            bus.append((<span class="va">self</span>.name, destination, <span class="va">self</span>.state))</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> instantiate_destinations(<span class="va">self</span>):</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>        destinations <span class="op">=</span> []</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dest <span class="kw">in</span> <span class="va">self</span>.destinations:</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(dest, <span class="bu">str</span>):</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">try</span>:</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>                    dest <span class="op">=</span> modules[dest]</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>                    dest <span class="op">=</span> Module(dest, [])</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>            destinations.append(dest)</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.destinations <span class="op">=</span> destinations</span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recv(<span class="va">self</span>, source, signal):</span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reset(<span class="va">self</span>):</span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FlipFlop(Module):</span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, destinations):</span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(name, destinations)</span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.state <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recv(<span class="va">self</span>, source, signal):</span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> signal <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">pass</span></span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.state <span class="op">^=</span> <span class="dv">1</span></span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.send()</span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reset(<span class="va">self</span>):</span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.state <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Conjunction(Module):</span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, destinations, sources):</span>
<span id="cb40-50"><a href="#cb40-50" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(name, destinations)</span>
<span id="cb40-51"><a href="#cb40-51" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.signals <span class="op">=</span> {x: <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> sources}</span>
<span id="cb40-52"><a href="#cb40-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-53"><a href="#cb40-53" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb40-54"><a href="#cb40-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> state(<span class="va">self</span>):</span>
<span id="cb40-55"><a href="#cb40-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">int</span>(<span class="kw">not</span> <span class="bu">all</span>(<span class="va">self</span>.signals.values()))</span>
<span id="cb40-56"><a href="#cb40-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-57"><a href="#cb40-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recv(<span class="va">self</span>, source, signal):</span>
<span id="cb40-58"><a href="#cb40-58" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.signals[source] <span class="op">=</span> signal</span>
<span id="cb40-59"><a href="#cb40-59" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.send()</span>
<span id="cb40-60"><a href="#cb40-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-61"><a href="#cb40-61" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reset(<span class="va">self</span>):</span>
<span id="cb40-62"><a href="#cb40-62" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.signals <span class="op">=</span> {x: <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.signals}</span>
<span id="cb40-63"><a href="#cb40-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-64"><a href="#cb40-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-65"><a href="#cb40-65" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Broadcaster(Module):</span>
<span id="cb40-66"><a href="#cb40-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recv(<span class="va">self</span>, source, signal):</span>
<span id="cb40-67"><a href="#cb40-67" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.state <span class="op">=</span> signal</span>
<span id="cb40-68"><a href="#cb40-68" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.send()</span>
<span id="cb40-69"><a href="#cb40-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-70"><a href="#cb40-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-71"><a href="#cb40-71" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> strip_prefix(name):</span>
<span id="cb40-72"><a href="#cb40-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> name[<span class="dv">1</span>:] <span class="cf">if</span> name[<span class="dv">0</span>] <span class="kw">in</span> <span class="st">"%&amp;"</span> <span class="cf">else</span> name</span>
<span id="cb40-73"><a href="#cb40-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-74"><a href="#cb40-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-75"><a href="#cb40-75" aria-hidden="true" tabindex="-1"></a>network <span class="op">=</span> {}</span>
<span id="cb40-76"><a href="#cb40-76" aria-hidden="true" tabindex="-1"></a>modules <span class="op">=</span> {}</span>
<span id="cb40-77"><a href="#cb40-77" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> source, destinations <span class="kw">in</span> <span class="bu">map</span>(<span class="kw">lambda</span> x: x.split(<span class="st">" -&gt; "</span>), data):</span>
<span id="cb40-78"><a href="#cb40-78" aria-hidden="true" tabindex="-1"></a>    network[source] <span class="op">=</span> destinations.split(<span class="st">", "</span>)</span>
<span id="cb40-79"><a href="#cb40-79" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key <span class="kw">in</span> network.keys():</span>
<span id="cb40-80"><a href="#cb40-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> key[<span class="dv">0</span>] <span class="op">==</span> <span class="st">"%"</span>:</span>
<span id="cb40-81"><a href="#cb40-81" aria-hidden="true" tabindex="-1"></a>        modules[key[<span class="dv">1</span>:]] <span class="op">=</span> FlipFlop(key[<span class="dv">1</span>:], network[key])</span>
<span id="cb40-82"><a href="#cb40-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> key[<span class="dv">0</span>] <span class="op">==</span> <span class="st">"&amp;"</span>:</span>
<span id="cb40-83"><a href="#cb40-83" aria-hidden="true" tabindex="-1"></a>        sources <span class="op">=</span> [strip_prefix(k) <span class="cf">for</span> k <span class="kw">in</span> network <span class="cf">if</span> key[<span class="dv">1</span>:] <span class="kw">in</span> network[k]]</span>
<span id="cb40-84"><a href="#cb40-84" aria-hidden="true" tabindex="-1"></a>        modules[key[<span class="dv">1</span>:]] <span class="op">=</span> Conjunction(key[<span class="dv">1</span>:], network[key], sources)</span>
<span id="cb40-85"><a href="#cb40-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> key <span class="op">==</span> <span class="st">"broadcaster"</span>:</span>
<span id="cb40-86"><a href="#cb40-86" aria-hidden="true" tabindex="-1"></a>        modules[key] <span class="op">=</span> Broadcaster(key, network[key])</span>
<span id="cb40-87"><a href="#cb40-87" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key <span class="kw">in</span> modules:</span>
<span id="cb40-88"><a href="#cb40-88" aria-hidden="true" tabindex="-1"></a>    modules[key].instantiate_destinations()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="41">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>counts <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1000</span>):</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    bus <span class="op">=</span> [(<span class="st">"button"</span>, modules[<span class="st">"broadcaster"</span>], <span class="dv">0</span>)]</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> bus:</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>        source, destination, signal <span class="op">=</span> bus.pop(<span class="dv">0</span>)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>        counts[signal] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>        destination.recv(source, signal)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>counts[<span class="dv">0</span>] <span class="op">*</span> counts[<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="part-2-19" class="level2">
<h2 class="anchored" data-anchor-id="part-2-19">Part 2</h2>
<div class="cell" data-execution_count="42">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># for module in modules:</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co">#     modules[module].reset()</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>bus <span class="op">=</span> [(<span class="st">"button"</span>, modules[<span class="st">"broadcaster"</span>], <span class="dv">0</span>)]</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> bus:</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    source, destination, signal <span class="op">=</span> bus.pop(<span class="dv">0</span>)</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>        source,</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>        destination.name,</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>        signal,</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">"conjunction"</span> <span class="cf">if</span> <span class="bu">hasattr</span>(destination, <span class="st">"signals"</span>) <span class="cf">else</span> <span class="st">"flipflop"</span>,</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    destination.recv(source, signal)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="43">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.from_dict_of_lists(</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    {strip_prefix(k): v <span class="cf">for</span> k, v <span class="kw">in</span> network.items()}, create_using<span class="op">=</span>nx.DiGraph</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>nodes, prefices <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>([(strip_prefix(k), k[<span class="dv">0</span>]) <span class="cf">for</span> k <span class="kw">in</span> network] <span class="op">+</span> [(<span class="st">"rx"</span>, <span class="st">"d"</span>)]))</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>colormap <span class="op">=</span> {<span class="st">"%"</span>: <span class="st">"#1f77b4"</span>, <span class="st">"&amp;"</span>: <span class="st">"#ff7f0e"</span>, <span class="st">"b"</span>: <span class="st">"#2ca02c"</span>, <span class="st">"d"</span>: <span class="st">"#d62728"</span>}</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [colormap[prefix] <span class="cf">for</span> prefix <span class="kw">in</span> prefices]</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    G, nodelist<span class="op">=</span>nodes, node_color<span class="op">=</span>colors, arrows<span class="op">=</span><span class="va">True</span>, pos<span class="op">=</span>nx.bfs_layout(G)</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"off"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="44">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> plt.cm.tab10.colors: <span class="bu">print</span>(matplotlib.colors.to_hex(c))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-21-step-counter" class="level1">
<h1><a href="https://adventofcode.com/2023/day/21">Day 21: Step Counter</a></h1>
<section id="part-1-19" class="level2">
<h2 class="anchored" data-anchor-id="part-1-19">Part 1</h2>
<div class="cell" data-execution_count="45">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.array([<span class="bu">list</span>(line) <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">21</span>)])</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.pad(data, <span class="dv">1</span>, constant_values<span class="op">=</span><span class="st">"#"</span>)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>y, x <span class="op">=</span> [x[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> np.where(data <span class="op">==</span> <span class="st">"S"</span>)]</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>data[y, x] <span class="op">=</span> <span class="st">"."</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> step(positions):</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y, x <span class="kw">in</span> positions:</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dy <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>]:</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> data[y <span class="op">+</span> dy, x] <span class="op">==</span> <span class="st">"."</span>:</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>                result.add((y <span class="op">+</span> dy, x))</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dx <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>]:</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> data[y, x <span class="op">+</span> dx] <span class="op">==</span> <span class="st">"."</span>:</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>                result.add((y, x <span class="op">+</span> dx))</span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> [(y, x)]</span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">64</span>):</span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>    positions <span class="op">=</span> step(positions)</span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(positions)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="day-25-snowverload" class="level1">
<h1><a href="https://adventofcode.com/2023/day/25">Day 25: Snowverload</a></h1>
<section id="part-1-20" class="level2">
<h2 class="anchored" data-anchor-id="part-1-20">Part 1</h2>
<p>This one stumped me for way too long. Or rather, finding a computational solution to it did. The first thing I tried to do to get a handle on what the problem was about was to plot the graph. And when I did that, it was immediately clear which three edges should be cut, and the problem was solved. That’s a perfectely reasonable solution plan – nowhere in the rules of AOC does it say that you have to run an algorithm on a computer to find the answer – but it felt a little unsatisfying.</p>
<p>So down into the rabbit hole we go.</p>
<p>The first thing I did was to load the data, and calculate the adjacency matrix of the graph</p>
<div class="cell" data-execution_count="46">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">25</span>)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>network <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> line <span class="kw">in</span> data:</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    key, values <span class="op">=</span> line.split(<span class="st">":"</span>)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    values <span class="op">=</span> values.split()</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> value <span class="kw">in</span> values:</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>        network[key].append(value)</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>        network[value].append(key)</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> <span class="bu">list</span>(network.keys())</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>adjacency_matrix <span class="op">=</span> np.zeros((<span class="bu">len</span>(nodes), <span class="bu">len</span>(nodes)), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>node_numbers <span class="op">=</span> {k : v <span class="cf">for</span> v, k <span class="kw">in</span> <span class="bu">enumerate</span>(nodes)}</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> nodes:</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> neighbor <span class="kw">in</span> network[node]:</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>        adjacency_matrix[node_numbers[node], node_numbers[neighbor]] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.from_dict_of_lists(network)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>I know enough about graph theory to know that what the problem is asking for is the min-cut of the graph, and I even remembered that there are a bunch of standard approaches to solving this problem. I’ve never implemented any of them myself. The <code>networkx</code> library implements the Stoer Wagner algorithm for doing this, so that might be a good place to start – if only to see how long I can expect things to actually take.</p>
<p>If I let myself use the library, the problem is as simple as</p>
<div class="cell" data-execution_count="47">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>value, partition <span class="op">=</span> nx.stoer_wagner(G)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(partition[<span class="dv">0</span>] <span class="op">*</span> <span class="bu">len</span>(partition[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Note that this takes 15s on my old laptop. So I don’t have high hopes that my implementation is going to run in any reasonable amount of time!</p>
<p>I can look at the <a href="https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm">wikipedia page</a> for the algorithm, and read the original paper, and the algorithm itself is as straightforward as</p>
<div class="cell" data-execution_count="48">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_indices(indices: <span class="bu">list</span>[<span class="bu">int</span>] <span class="op">|</span> <span class="bu">int</span>, a):</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(indices, <span class="bu">list</span>):</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>        indices <span class="op">=</span> [<span class="dv">0</span>, indices]</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    smallest_index <span class="op">=</span> <span class="bu">min</span>(indices)</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    good_indices <span class="op">=</span> np.setdiff1d(<span class="bu">range</span>(<span class="bu">len</span>(a)), indices)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    good_mask <span class="op">=</span> np.ix_(good_indices, good_indices)</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    bad_mask <span class="op">=</span> np.ix_(indices, good_indices)</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> a[bad_mask].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    new_a <span class="op">=</span> a[good_mask].copy()</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    new_a <span class="op">=</span> np.insert(new_a, smallest_index, row, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> np.insert(row, <span class="bu">min</span>(indices), <span class="dv">0</span>)</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.insert(new_a, smallest_index, row, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimum_cut_phase(adjacency_matrix, node_labels):</span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">len</span>(node_labels) <span class="op">==</span> <span class="bu">len</span>(adjacency_matrix)</span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> node_labels.copy()</span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(adjacency_matrix) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>        cut_value <span class="op">=</span> adjacency_matrix[<span class="dv">1</span>, <span class="dv">0</span>]</span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>        node_index <span class="op">=</span> adjacency_matrix[<span class="dv">0</span>].argmax()</span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> labels.pop(node_index)</span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span>:</span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(labels, adjacency_matrix)</span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>        adjacency_matrix <span class="op">=</span> merge_indices(node_index, adjacency_matrix)</span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>    node_index <span class="op">=</span> adjacency_matrix[<span class="op">-</span><span class="dv">1</span>].argmax()</span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> labels.pop(node_index)</span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s, t, cut_value</span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimum_cut(adjacency_matrix, node_labels, target<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a>    min_cut_weight <span class="op">=</span> np.inf</span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(adjacency_matrix) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a>        s, t, cut_weight <span class="op">=</span> minimum_cut_phase(adjacency_matrix, node_labels)</span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cut_weight <span class="op">&lt;</span> min_cut_weight:</span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a>            min_cut_weight <span class="op">=</span> cut_weight</span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a>            min_cut <span class="op">=</span> s</span>
<span id="cb48-39"><a href="#cb48-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> min_cut_weight <span class="op">&lt;=</span> target:</span>
<span id="cb48-40"><a href="#cb48-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb48-41"><a href="#cb48-41" aria-hidden="true" tabindex="-1"></a>        new_label <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>s<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>t<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb48-42"><a href="#cb48-42" aria-hidden="true" tabindex="-1"></a>        s_idx <span class="op">=</span> node_labels.index(s)</span>
<span id="cb48-43"><a href="#cb48-43" aria-hidden="true" tabindex="-1"></a>        t_idx <span class="op">=</span> node_labels.index(t)</span>
<span id="cb48-44"><a href="#cb48-44" aria-hidden="true" tabindex="-1"></a>        first, second <span class="op">=</span> <span class="bu">sorted</span>([s_idx, t_idx])</span>
<span id="cb48-45"><a href="#cb48-45" aria-hidden="true" tabindex="-1"></a>        node_labels[first] <span class="op">=</span> new_label</span>
<span id="cb48-46"><a href="#cb48-46" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> node_labels[second]</span>
<span id="cb48-47"><a href="#cb48-47" aria-hidden="true" tabindex="-1"></a>        adjacency_matrix <span class="op">=</span> merge_indices([first, second], adjacency_matrix)</span>
<span id="cb48-48"><a href="#cb48-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min_cut_weight, min_cut</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Unfortunately, this runs much too slowly to be of any use at all. That’s probably because I should be using a heap to store the closest neighbors to my active set. I’m fairly sure the implementation is correct; based on the various tests I’ve done with smaller graphs. Since that was my main goal with this implementation, I’m not going optimize it.</p>
<p>Another approach is to just pick edges at random and merge the nodes connecting them, and keep going until there are only two nodes left – this represents a cut in the original graph. The idea is that there are many more edges that are not part of a minimum cut than there are edges which are, so the chances of selecting a bad edge is low. You run this algorithm a bunch of times and pick the partition that leads to the lowest cut weight.</p>
<div class="cell" data-execution_count="49">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pick_edge(adjacency_matrix, rng<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Pick an edge uniformly at random from an adjacency matrix representation of a graph.</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rng <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>        rng <span class="op">=</span> np.random.default_rng()</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    n_edges <span class="op">=</span> (adjacency_matrix <span class="op">&gt;</span> <span class="dv">0</span>).<span class="bu">sum</span>()</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> rng.integers(n_edges)</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    totals <span class="op">=</span> (adjacency_matrix <span class="op">&gt;</span> <span class="dv">0</span>).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>).cumsum()</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> (totals <span class="op">&gt;</span> idx).argmax()</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    previous <span class="op">=</span> totals[row <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> row <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>([row, np.where(adjacency_matrix[row])[<span class="dv">0</span>][idx <span class="op">-</span> previous]])</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng()</span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>pick_edge(adjacency_matrix, rng)</span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> contract(adjacency_matrix, labels, limit):</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> labels.copy()</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(adjacency_matrix) <span class="op">&gt;</span> limit:</span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>        n1, n2 <span class="op">=</span> pick_edge(adjacency_matrix)</span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>        l1, l2 <span class="op">=</span> labels[n1], labels[n2]</span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>        labels[n1] <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>l1<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>l2<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> labels[n2]</span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>        adjacency_matrix <span class="op">=</span> merge_indices([n1, n2], adjacency_matrix)</span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> adjacency_matrix, labels</span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fastmincut(adjacency_matrix, labels):</span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(adjacency_matrix) <span class="op">&lt;=</span> <span class="dv">6</span>:</span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> contract(adjacency_matrix, labels, <span class="dv">2</span>)</span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="bu">int</span>(np.ceil(<span class="dv">1</span> <span class="op">+</span> <span class="bu">len</span>(adjacency_matrix) <span class="op">/</span> np.sqrt(<span class="dv">2</span>)))</span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>    c1, l1 <span class="op">=</span> contract(adjacency_matrix, labels, t)</span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>    c2, l2 <span class="op">=</span> contract(adjacency_matrix, labels, t)</span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(fastmincut(c1, l1), fastmincut(c2, l2), key<span class="op">=</span><span class="kw">lambda</span> x:x[<span class="dv">0</span>][<span class="dv">0</span>, <span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Again, I was unable to get this to run in a reasonable amount of time.</p>
<p>Finally, (based on having plotted the graph), spectral clustering seems like a nice approach to assign each node to one of two groups. Sklearn <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html">implements this</a> for us, so we don’t even need to do anthing, or something.</p>
<div class="cell" data-execution_count="50">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> SpectralClustering</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>sc <span class="op">=</span> SpectralClustering(<span class="dv">2</span>, affinity<span class="op">=</span><span class="st">'precomputed'</span>, n_init<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>                        assign_labels<span class="op">=</span><span class="st">'discretize'</span>)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> sc.fit_predict(adjacency_matrix)</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>c1 <span class="op">=</span> np.where(fit <span class="op">==</span> <span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>c2 <span class="op">=</span> np.where(fit <span class="op">==</span> <span class="dv">1</span>)[<span class="dv">0</span>]</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(c1) <span class="op">*</span> <span class="bu">len</span>(c2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>With all that meandering out of the way, here’s my graph visualized,</p>
<div class="cell" data-execution_count="51">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>centrality <span class="op">=</span> nx.betweenness_centrality(G)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>nx.set_node_attributes(G, centrality, name<span class="op">=</span><span class="st">"centrality"</span>)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>nx.set_node_attributes(G, pos, name<span class="op">=</span><span class="st">"pos"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="52">
<details>
<summary>A lot of plotly code</summary>
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.graph_objects <span class="im">as</span> go</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>edge_x <span class="op">=</span> []</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>edge_y <span class="op">=</span> []</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> edge <span class="kw">in</span> G.edges():</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    x0, y0 <span class="op">=</span> G.nodes[edge[<span class="dv">0</span>]][<span class="st">"pos"</span>]</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    x1, y1 <span class="op">=</span> G.nodes[edge[<span class="dv">1</span>]][<span class="st">"pos"</span>]</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    edge_x.append(x0)</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>    edge_x.append(x1)</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    edge_x.append(<span class="va">None</span>)</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    edge_y.append(y0)</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    edge_y.append(y1)</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>    edge_y.append(<span class="va">None</span>)</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>edge_trace <span class="op">=</span> go.Scatter(</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>edge_x,</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span>edge_y,</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>    line<span class="op">=</span><span class="bu">dict</span>(width<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">"#888"</span>),</span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>    hoverinfo<span class="op">=</span><span class="st">"none"</span>,</span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span><span class="st">"lines"</span>,</span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a>node_x <span class="op">=</span> []</span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a>node_y <span class="op">=</span> []</span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> []</span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label <span class="kw">in</span> G.nodes():</span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a>    node <span class="op">=</span> G.nodes[label]</span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> node[<span class="st">"pos"</span>]</span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a>    node_x.append(x)</span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a>    node_y.append(y)</span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a>    colors.append(node[<span class="st">"centrality"</span>])</span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-33"><a href="#cb52-33" aria-hidden="true" tabindex="-1"></a>node_trace <span class="op">=</span> go.Scatter(</span>
<span id="cb52-34"><a href="#cb52-34" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>node_x,</span>
<span id="cb52-35"><a href="#cb52-35" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span>node_y,</span>
<span id="cb52-36"><a href="#cb52-36" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span><span class="st">"markers"</span>,</span>
<span id="cb52-37"><a href="#cb52-37" aria-hidden="true" tabindex="-1"></a>    hoverinfo<span class="op">=</span><span class="st">"text"</span>,</span>
<span id="cb52-38"><a href="#cb52-38" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span><span class="bu">dict</span>(</span>
<span id="cb52-39"><a href="#cb52-39" aria-hidden="true" tabindex="-1"></a>        showscale<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb52-40"><a href="#cb52-40" aria-hidden="true" tabindex="-1"></a>        colorscale<span class="op">=</span><span class="st">"Viridis"</span>,</span>
<span id="cb52-41"><a href="#cb52-41" aria-hidden="true" tabindex="-1"></a>        reversescale<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb52-42"><a href="#cb52-42" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span>colors,</span>
<span id="cb52-43"><a href="#cb52-43" aria-hidden="true" tabindex="-1"></a>        size<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb52-44"><a href="#cb52-44" aria-hidden="true" tabindex="-1"></a>        colorbar<span class="op">=</span><span class="bu">dict</span>(</span>
<span id="cb52-45"><a href="#cb52-45" aria-hidden="true" tabindex="-1"></a>            thickness<span class="op">=</span><span class="dv">15</span>,</span>
<span id="cb52-46"><a href="#cb52-46" aria-hidden="true" tabindex="-1"></a>            title<span class="op">=</span><span class="bu">dict</span>(text<span class="op">=</span><span class="st">"Node Connections"</span>, side<span class="op">=</span><span class="st">"right"</span>),</span>
<span id="cb52-47"><a href="#cb52-47" aria-hidden="true" tabindex="-1"></a>            xanchor<span class="op">=</span><span class="st">"left"</span>,</span>
<span id="cb52-48"><a href="#cb52-48" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb52-49"><a href="#cb52-49" aria-hidden="true" tabindex="-1"></a>        line_width<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb52-50"><a href="#cb52-50" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb52-51"><a href="#cb52-51" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb52-52"><a href="#cb52-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-53"><a href="#cb52-53" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> go.Figure(data<span class="op">=</span>[edge_trace, node_trace],</span>
<span id="cb52-54"><a href="#cb52-54" aria-hidden="true" tabindex="-1"></a>             layout<span class="op">=</span>go.Layout(</span>
<span id="cb52-55"><a href="#cb52-55" aria-hidden="true" tabindex="-1"></a>                showlegend<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb52-56"><a href="#cb52-56" aria-hidden="true" tabindex="-1"></a>                hovermode<span class="op">=</span><span class="st">'closest'</span>,</span>
<span id="cb52-57"><a href="#cb52-57" aria-hidden="true" tabindex="-1"></a>                margin<span class="op">=</span><span class="bu">dict</span>(b<span class="op">=</span><span class="dv">20</span>,l<span class="op">=</span><span class="dv">5</span>,r<span class="op">=</span><span class="dv">5</span>,t<span class="op">=</span><span class="dv">40</span>),</span>
<span id="cb52-58"><a href="#cb52-58" aria-hidden="true" tabindex="-1"></a>                xaxis<span class="op">=</span><span class="bu">dict</span>(showgrid<span class="op">=</span><span class="va">False</span>, zeroline<span class="op">=</span><span class="va">False</span>, showticklabels<span class="op">=</span><span class="va">False</span>),</span>
<span id="cb52-59"><a href="#cb52-59" aria-hidden="true" tabindex="-1"></a>                yaxis<span class="op">=</span><span class="bu">dict</span>(showgrid<span class="op">=</span><span class="va">False</span>, zeroline<span class="op">=</span><span class="va">False</span>, showticklabels<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb52-60"><a href="#cb52-60" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb52-61"><a href="#cb52-61" aria-hidden="true" tabindex="-1"></a>fig.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<pre><code>Unable to display output for mime type(s): application/vnd.plotly.v1+json</code></pre>
</div>
</div>


<!-- -->

</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb54" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> 2023 Solutions</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="fu"># Imports</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="co"># | eval: true</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="co"># | output: false</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dataclasses</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> functools</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict, deque, namedtuple</span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> queue <span class="im">import</span> PriorityQueue</span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> more_itertools</span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy</span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a>sys.path.insert(<span class="dv">1</span>, <span class="st">".."</span>)</span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> utils</span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-31"><a href="#cb54-31" aria-hidden="true" tabindex="-1"></a>load <span class="op">=</span> utils.year_load(<span class="dv">2023</span>)</span>
<span id="cb54-32"><a href="#cb54-32" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-33"><a href="#cb54-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-34"><a href="#cb54-34" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 1: Trebuchet?!](https://adventofcode.com/2023/day/1)</span></span>
<span id="cb54-35"><a href="#cb54-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-36"><a href="#cb54-36" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-37"><a href="#cb54-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-38"><a href="#cb54-38" aria-hidden="true" tabindex="-1"></a>Not much going on in part one. We need to extract the digits in each line and then add together $10\times$ all the first digits and all the last digits.</span>
<span id="cb54-39"><a href="#cb54-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-42"><a href="#cb54-42" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-43"><a href="#cb54-43" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [[<span class="bu">int</span>(char) <span class="cf">for</span> char <span class="kw">in</span> line <span class="cf">if</span> char <span class="kw">in</span> <span class="st">"0123456879"</span>] <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">1</span>)]</span>
<span id="cb54-44"><a href="#cb54-44" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span> <span class="op">*</span> <span class="bu">sum</span>(x[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> data) <span class="op">+</span> <span class="bu">sum</span>(x[<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> data)</span>
<span id="cb54-45"><a href="#cb54-45" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-46"><a href="#cb54-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-47"><a href="#cb54-47" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-48"><a href="#cb54-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-49"><a href="#cb54-49" aria-hidden="true" tabindex="-1"></a>For part two, we need to work with the string representation of the numbers. The examples show that the numbers can overlap, so we want a string like "fiveight" to show a "5" first and then an "8".</span>
<span id="cb54-50"><a href="#cb54-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-51"><a href="#cb54-51" aria-hidden="true" tabindex="-1"></a>We are only interested in the first and last digits of the string, so this could be done using a sliding window. Or we could hack it by padding the string representation of the number and doing a search and replace:</span>
<span id="cb54-52"><a href="#cb54-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-55"><a href="#cb54-55" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-56"><a href="#cb54-56" aria-hidden="true" tabindex="-1"></a>number_names <span class="op">=</span> [</span>
<span id="cb54-57"><a href="#cb54-57" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"one"</span>, <span class="st">"one1one"</span>),</span>
<span id="cb54-58"><a href="#cb54-58" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"two"</span>, <span class="st">"two2two"</span>),</span>
<span id="cb54-59"><a href="#cb54-59" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"three"</span>, <span class="st">"three3three"</span>),</span>
<span id="cb54-60"><a href="#cb54-60" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"four"</span>, <span class="st">"four4four"</span>),</span>
<span id="cb54-61"><a href="#cb54-61" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"five"</span>, <span class="st">"five5five"</span>),</span>
<span id="cb54-62"><a href="#cb54-62" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"six"</span>, <span class="st">"six6six"</span>),</span>
<span id="cb54-63"><a href="#cb54-63" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"seven"</span>, <span class="st">"seven7seven"</span>),</span>
<span id="cb54-64"><a href="#cb54-64" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"eight"</span>, <span class="st">"eight8eight"</span>),</span>
<span id="cb54-65"><a href="#cb54-65" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"nine"</span>, <span class="st">"nine9nine"</span>),</span>
<span id="cb54-66"><a href="#cb54-66" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb54-67"><a href="#cb54-67" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">1</span>, <span class="st">"raw"</span>)</span>
<span id="cb54-68"><a href="#cb54-68" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> pair <span class="kw">in</span> number_names:</span>
<span id="cb54-69"><a href="#cb54-69" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> data.replace(pair[<span class="dv">0</span>], pair[<span class="dv">1</span>])</span>
<span id="cb54-70"><a href="#cb54-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-71"><a href="#cb54-71" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> data.split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb54-72"><a href="#cb54-72" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [[<span class="bu">int</span>(char) <span class="cf">for</span> char <span class="kw">in</span> line <span class="cf">if</span> char <span class="kw">in</span> <span class="st">"0123456879"</span>] <span class="cf">for</span> line <span class="kw">in</span> data]</span>
<span id="cb54-73"><a href="#cb54-73" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span> <span class="op">*</span> <span class="bu">sum</span>(x[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> data) <span class="op">+</span> <span class="bu">sum</span>(x[<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> data)</span>
<span id="cb54-74"><a href="#cb54-74" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-75"><a href="#cb54-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-76"><a href="#cb54-76" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 2: Cube Conundrum](https://adventofcode.com/2023/day/2)</span></span>
<span id="cb54-77"><a href="#cb54-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-78"><a href="#cb54-78" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-79"><a href="#cb54-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-80"><a href="#cb54-80" aria-hidden="true" tabindex="-1"></a>The most fiddly task in part 1 is parsing the input. Each line is a single game, with the game id appearing first and then the game outcome, separated by a colon. Each game consists of multiple rounds (delimited by a semicolon) and each round reveals multiple colours (delimited by commas).</span>
<span id="cb54-81"><a href="#cb54-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-82"><a href="#cb54-82" aria-hidden="true" tabindex="-1"></a>So we split on the colon to separate the game id from the outcome, then split the outcome on semicolons to get each round, and finally split each round on commas to find the colours. A bit of regex let's us finally get to a list of three integers as the representation of a round.</span>
<span id="cb54-83"><a href="#cb54-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-84"><a href="#cb54-84" aria-hidden="true" tabindex="-1"></a>Once we have that, we can compare each round in a game with the maximum number of <span class="in">`[red, green, blue]`</span>{.verbatim} cubes available and see if it is possible. A game fails if any single round is impossible.</span>
<span id="cb54-85"><a href="#cb54-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-88"><a href="#cb54-88" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-89"><a href="#cb54-89" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_game_round(game_round):</span>
<span id="cb54-90"><a href="#cb54-90" aria-hidden="true" tabindex="-1"></a>    colormap <span class="op">=</span> {<span class="st">"red"</span>: <span class="dv">0</span>, <span class="st">"green"</span>: <span class="dv">1</span>, <span class="st">"blue"</span>: <span class="dv">2</span>}</span>
<span id="cb54-91"><a href="#cb54-91" aria-hidden="true" tabindex="-1"></a>    regex <span class="op">=</span> <span class="vs">r"([0-9]*) (red|green|blue)"</span></span>
<span id="cb54-92"><a href="#cb54-92" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb54-93"><a href="#cb54-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v, c <span class="kw">in</span> [re.search(regex, entry).groups() <span class="cf">for</span> entry <span class="kw">in</span> game_round.split(<span class="st">","</span>)]:</span>
<span id="cb54-94"><a href="#cb54-94" aria-hidden="true" tabindex="-1"></a>        result[colormap[c]] <span class="op">=</span> <span class="bu">int</span>(v)</span>
<span id="cb54-95"><a href="#cb54-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb54-96"><a href="#cb54-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-97"><a href="#cb54-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-98"><a href="#cb54-98" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-99"><a href="#cb54-99" aria-hidden="true" tabindex="-1"></a>games <span class="op">=</span> [</span>
<span id="cb54-100"><a href="#cb54-100" aria-hidden="true" tabindex="-1"></a>    np.array([parse_game_round(x) <span class="cf">for</span> x <span class="kw">in</span> line.split(<span class="st">":"</span>)[<span class="dv">1</span>].split(<span class="st">";"</span>)])</span>
<span id="cb54-101"><a href="#cb54-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">2</span>)</span>
<span id="cb54-102"><a href="#cb54-102" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb54-103"><a href="#cb54-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-104"><a href="#cb54-104" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, game <span class="kw">in</span> <span class="bu">enumerate</span>(games):</span>
<span id="cb54-105"><a href="#cb54-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ((game <span class="op">-</span> [<span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>]) <span class="op">&lt;=</span> <span class="dv">0</span>).<span class="bu">all</span>():</span>
<span id="cb54-106"><a href="#cb54-106" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> idx <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb54-107"><a href="#cb54-107" aria-hidden="true" tabindex="-1"></a>total</span>
<span id="cb54-108"><a href="#cb54-108" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-109"><a href="#cb54-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-110"><a href="#cb54-110" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-111"><a href="#cb54-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-112"><a href="#cb54-112" aria-hidden="true" tabindex="-1"></a>With part 1 out of the way, part 2 is trivial: we get the same representation for each game as before, and just calculate the maximum for each coordinate in any round, and then multiply those three numbers together.</span>
<span id="cb54-113"><a href="#cb54-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-116"><a href="#cb54-116" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-117"><a href="#cb54-117" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(np.product(game.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">0</span>)) <span class="cf">for</span> game <span class="kw">in</span> games)</span>
<span id="cb54-118"><a href="#cb54-118" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-119"><a href="#cb54-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-120"><a href="#cb54-120" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 3: Gear Ratios](https://adventofcode.com/2023/day/3)</span></span>
<span id="cb54-121"><a href="#cb54-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-122"><a href="#cb54-122" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-123"><a href="#cb54-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-124"><a href="#cb54-124" aria-hidden="true" tabindex="-1"></a>It seems the theme for AOC this year is "let's make things annoying to parse".</span>
<span id="cb54-125"><a href="#cb54-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-126"><a href="#cb54-126" aria-hidden="true" tabindex="-1"></a>We'll need to extract the values and locations of all the numbers in the grid, and then compare that with the locations of the symbols. To get the coordinates that neighbor a symbol we can use a neat convolution trick. To get the coordinates of each number we'll loop over all the lines in the grid, and use a regex to find the numbers.</span>
<span id="cb54-127"><a href="#cb54-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-128"><a href="#cb54-128" aria-hidden="true" tabindex="-1"></a>Once we have that, we can find the desired value by finding the set intersetion of the number-coordinates and the neighbor coordinates; if that's non-empty, we add the number to a running total.</span>
<span id="cb54-129"><a href="#cb54-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-132"><a href="#cb54-132" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-133"><a href="#cb54-133" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">3</span>)</span>
<span id="cb54-134"><a href="#cb54-134" aria-hidden="true" tabindex="-1"></a>symbols <span class="op">=</span> np.array([[(c <span class="kw">not</span> <span class="kw">in</span> <span class="st">"0123456789"</span>) <span class="kw">and</span> c <span class="op">!=</span> <span class="st">"."</span> <span class="cf">for</span> c <span class="kw">in</span> l] <span class="cf">for</span> l <span class="kw">in</span> data])</span>
<span id="cb54-135"><a href="#cb54-135" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> [[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>]]</span>
<span id="cb54-136"><a href="#cb54-136" aria-hidden="true" tabindex="-1"></a>neighbors <span class="op">=</span> scipy.ndimage.convolve(symbols, w, mode<span class="op">=</span><span class="st">"constant"</span>)</span>
<span id="cb54-137"><a href="#cb54-137" aria-hidden="true" tabindex="-1"></a>neighbors <span class="op">=</span> <span class="bu">set</span>(<span class="bu">zip</span>(<span class="op">*</span>np.where(neighbors)))</span>
<span id="cb54-138"><a href="#cb54-138" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> {}</span>
<span id="cb54-139"><a href="#cb54-139" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, row <span class="kw">in</span> <span class="bu">enumerate</span>(data):</span>
<span id="cb54-140"><a href="#cb54-140" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> re.finditer(<span class="st">"\d+"</span>, row):</span>
<span id="cb54-141"><a href="#cb54-141" aria-hidden="true" tabindex="-1"></a>        numbers[<span class="bu">frozenset</span>((i, j) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="op">*</span>n.span()))] <span class="op">=</span> <span class="bu">int</span>(n.group())</span>
<span id="cb54-142"><a href="#cb54-142" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(numbers[key] <span class="cf">if</span> key <span class="op">&amp;</span> neighbors <span class="cf">else</span> <span class="dv">0</span> <span class="cf">for</span> key <span class="kw">in</span> numbers)</span>
<span id="cb54-143"><a href="#cb54-143" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-144"><a href="#cb54-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-145"><a href="#cb54-145" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-146"><a href="#cb54-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-147"><a href="#cb54-147" aria-hidden="true" tabindex="-1"></a>After part 1, part 2 is pretty simple. We can use the same (coordinates) -<span class="sc">\&gt;</span> number mapping as before, and then just loop over all locations in the grid that have a value of "<span class="sc">\*</span>". We find the neighbors of each star, intersect with all the numbers coordinates, and only use the ones that intersect exactly two numbers</span>
<span id="cb54-148"><a href="#cb54-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-151"><a href="#cb54-151" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-152"><a href="#cb54-152" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-153"><a href="#cb54-153" aria-hidden="true" tabindex="-1"></a>offsets <span class="op">=</span> np.array(<span class="bu">list</span>(<span class="bu">zip</span>(<span class="op">*</span>np.where(w)))) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb54-154"><a href="#cb54-154" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> star <span class="kw">in</span> <span class="bu">zip</span>(<span class="op">*</span>np.where(np.array([[c <span class="cf">for</span> c <span class="kw">in</span> l] <span class="cf">for</span> l <span class="kw">in</span> data]) <span class="op">==</span> <span class="st">"*"</span>)):</span>
<span id="cb54-155"><a href="#cb54-155" aria-hidden="true" tabindex="-1"></a>    neighbors <span class="op">=</span> <span class="bu">set</span>([<span class="bu">tuple</span>(x) <span class="cf">for</span> x <span class="kw">in</span> star <span class="op">+</span> offsets])</span>
<span id="cb54-156"><a href="#cb54-156" aria-hidden="true" tabindex="-1"></a>    values <span class="op">=</span> [numbers[key] <span class="cf">for</span> key <span class="kw">in</span> numbers <span class="cf">if</span> key <span class="op">&amp;</span> neighbors]</span>
<span id="cb54-157"><a href="#cb54-157" aria-hidden="true" tabindex="-1"></a>    total <span class="op">+=</span> values[<span class="dv">0</span>] <span class="op">*</span> values[<span class="dv">1</span>] <span class="cf">if</span> <span class="bu">len</span>(values) <span class="op">==</span> <span class="dv">2</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb54-158"><a href="#cb54-158" aria-hidden="true" tabindex="-1"></a>total</span>
<span id="cb54-159"><a href="#cb54-159" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-160"><a href="#cb54-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-161"><a href="#cb54-161" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 4: Scratchcards](https://adventofcode.com/2023/day/4)</span></span>
<span id="cb54-162"><a href="#cb54-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-163"><a href="#cb54-163" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-164"><a href="#cb54-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-165"><a href="#cb54-165" aria-hidden="true" tabindex="-1"></a>After the interesting parsing tasks of the last few days, today was straightforward. Part one can be boiled down to this oneliner, which I don't even think is completely illegible</span>
<span id="cb54-166"><a href="#cb54-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-169"><a href="#cb54-169" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-170"><a href="#cb54-170" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(<span class="bu">int</span>(<span class="dv">2</span> <span class="op">**</span> (<span class="bu">len</span>(<span class="bu">set</span>(row[<span class="dv">1</span>:<span class="dv">11</span>]) <span class="op">&amp;</span> <span class="bu">set</span>(row[<span class="dv">11</span>:])) <span class="op">-</span> <span class="dv">1</span>)) <span class="cf">for</span> row <span class="kw">in</span> load(<span class="dv">4</span>, <span class="st">"int"</span>))</span>
<span id="cb54-171"><a href="#cb54-171" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-172"><a href="#cb54-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-173"><a href="#cb54-173" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-174"><a href="#cb54-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-175"><a href="#cb54-175" aria-hidden="true" tabindex="-1"></a>I could have found some way of saving the intersections from part 1 so that I didn't have to recalculate in part two, but it's not that complicated.</span>
<span id="cb54-176"><a href="#cb54-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-179"><a href="#cb54-179" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-180"><a href="#cb54-180" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">4</span>, <span class="st">"int"</span>)</span>
<span id="cb54-181"><a href="#cb54-181" aria-hidden="true" tabindex="-1"></a>counts <span class="op">=</span> np.ones(<span class="bu">len</span>(data), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb54-182"><a href="#cb54-182" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, row <span class="kw">in</span> <span class="bu">enumerate</span>(data):</span>
<span id="cb54-183"><a href="#cb54-183" aria-hidden="true" tabindex="-1"></a>    wins <span class="op">=</span> <span class="bu">len</span>(<span class="bu">set</span>(row[<span class="dv">1</span>:<span class="dv">11</span>]) <span class="op">&amp;</span> <span class="bu">set</span>(row[<span class="dv">11</span>:]))</span>
<span id="cb54-184"><a href="#cb54-184" aria-hidden="true" tabindex="-1"></a>    counts[i <span class="op">+</span> <span class="dv">1</span> : i <span class="op">+</span> wins <span class="op">+</span> <span class="dv">1</span>] <span class="op">+=</span> counts[i]</span>
<span id="cb54-185"><a href="#cb54-185" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(counts)</span>
<span id="cb54-186"><a href="#cb54-186" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-187"><a href="#cb54-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-188"><a href="#cb54-188" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 5: If You Give A Seed A Fertilizer](https://adventofcode.com/2023/day/5)</span></span>
<span id="cb54-189"><a href="#cb54-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-190"><a href="#cb54-190" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-191"><a href="#cb54-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-192"><a href="#cb54-192" aria-hidden="true" tabindex="-1"></a>The first part is a straightforward implementation of the requirements.</span>
<span id="cb54-193"><a href="#cb54-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-194"><a href="#cb54-194" aria-hidden="true" tabindex="-1"></a>To parse the file, we first split on "<span class="in">`\n`</span>{=latex}<span class="in">`\n`</span>{=latex}" to get each of the sections separately, then for each line of each section, we extract all of the integers. These are all positive, so we can do that with the regex "(+̣)". After skipping through lines which don't contain integers, we have a sensible representation for our data.</span>
<span id="cb54-195"><a href="#cb54-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-196"><a href="#cb54-196" aria-hidden="true" tabindex="-1"></a>After that it's just a question of following through what happens to each initial value: for each one we scan through the rulesets in order, and when we find a rule in a ruleset that matches we convert it to the new value and move on. If we don't find a rule that matches we're told that the converted value is the same as the original one.</span>
<span id="cb54-197"><a href="#cb54-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-200"><a href="#cb54-200" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-201"><a href="#cb54-201" aria-hidden="true" tabindex="-1"></a>[seeds], <span class="op">*</span>rules <span class="op">=</span> [</span>
<span id="cb54-202"><a href="#cb54-202" aria-hidden="true" tabindex="-1"></a>    [</span>
<span id="cb54-203"><a href="#cb54-203" aria-hidden="true" tabindex="-1"></a>        [<span class="bu">int</span>(x) <span class="cf">for</span> x <span class="kw">in</span> ints]</span>
<span id="cb54-204"><a href="#cb54-204" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> line <span class="kw">in</span> groups.split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb54-205"><a href="#cb54-205" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (ints <span class="op">:=</span> re.findall(<span class="st">"(\d+)"</span>, line))</span>
<span id="cb54-206"><a href="#cb54-206" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb54-207"><a href="#cb54-207" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> groups <span class="kw">in</span> load(<span class="dv">5</span>, <span class="st">"raw"</span>).split(<span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb54-208"><a href="#cb54-208" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb54-209"><a href="#cb54-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-210"><a href="#cb54-210" aria-hidden="true" tabindex="-1"></a>minval <span class="op">=</span> np.inf</span>
<span id="cb54-211"><a href="#cb54-211" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> seed <span class="kw">in</span> seeds:</span>
<span id="cb54-212"><a href="#cb54-212" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> seed</span>
<span id="cb54-213"><a href="#cb54-213" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ruleset <span class="kw">in</span> rules:</span>
<span id="cb54-214"><a href="#cb54-214" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> destination, source, length <span class="kw">in</span> ruleset:</span>
<span id="cb54-215"><a href="#cb54-215" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> source <span class="op">&lt;=</span> current <span class="op">&lt;</span> source <span class="op">+</span> length:</span>
<span id="cb54-216"><a href="#cb54-216" aria-hidden="true" tabindex="-1"></a>                current <span class="op">=</span> current <span class="op">+</span> destination <span class="op">-</span> source</span>
<span id="cb54-217"><a href="#cb54-217" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb54-218"><a href="#cb54-218" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current <span class="op">&lt;</span> minval:</span>
<span id="cb54-219"><a href="#cb54-219" aria-hidden="true" tabindex="-1"></a>        minval <span class="op">=</span> current</span>
<span id="cb54-220"><a href="#cb54-220" aria-hidden="true" tabindex="-1"></a>minval</span>
<span id="cb54-221"><a href="#cb54-221" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-222"><a href="#cb54-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-223"><a href="#cb54-223" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-224"><a href="#cb54-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-225"><a href="#cb54-225" aria-hidden="true" tabindex="-1"></a>For part two we need to be a bit cleverer. We know that each rule converts a specific source range to a specific destination range. So to apply a rule to an arbitrary range, we split the range into three: The parts of the range before the rule applies, the parts of the range that intersect the rule and the parts of the range after the rule. Some of these parts can be empty, but that's OK.</span>
<span id="cb54-226"><a href="#cb54-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-227"><a href="#cb54-227" aria-hidden="true" tabindex="-1"></a>From there, building a routine to iteratively apply each ruleset to the original ranges is not too tricky.</span>
<span id="cb54-228"><a href="#cb54-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-231"><a href="#cb54-231" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-232"><a href="#cb54-232" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_range(r, rule):</span>
<span id="cb54-233"><a href="#cb54-233" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [</span>
<span id="cb54-234"><a href="#cb54-234" aria-hidden="true" tabindex="-1"></a>        x <span class="cf">if</span> x[<span class="dv">0</span>] <span class="op">&lt;</span> x[<span class="dv">1</span>] <span class="cf">else</span> []</span>
<span id="cb54-235"><a href="#cb54-235" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> [</span>
<span id="cb54-236"><a href="#cb54-236" aria-hidden="true" tabindex="-1"></a>            (r[<span class="dv">0</span>], <span class="bu">min</span>(rule[<span class="dv">0</span>], r[<span class="dv">1</span>])),</span>
<span id="cb54-237"><a href="#cb54-237" aria-hidden="true" tabindex="-1"></a>            (<span class="bu">max</span>(r[<span class="dv">0</span>], rule[<span class="dv">0</span>]), <span class="bu">min</span>(r[<span class="dv">1</span>], rule[<span class="dv">1</span>])),</span>
<span id="cb54-238"><a href="#cb54-238" aria-hidden="true" tabindex="-1"></a>            (<span class="bu">max</span>(rule[<span class="dv">1</span>], r[<span class="dv">0</span>]), r[<span class="dv">1</span>]),</span>
<span id="cb54-239"><a href="#cb54-239" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb54-240"><a href="#cb54-240" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb54-241"><a href="#cb54-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-242"><a href="#cb54-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-243"><a href="#cb54-243" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_ranges(ranges, rule):</span>
<span id="cb54-244"><a href="#cb54-244" aria-hidden="true" tabindex="-1"></a>    dest, src, length <span class="op">=</span> rule</span>
<span id="cb54-245"><a href="#cb54-245" aria-hidden="true" tabindex="-1"></a>    done, todo <span class="op">=</span> [], []</span>
<span id="cb54-246"><a href="#cb54-246" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l, m, r <span class="kw">in</span> [split_range(r, [src, src <span class="op">+</span> length]) <span class="cf">for</span> r <span class="kw">in</span> ranges]:</span>
<span id="cb54-247"><a href="#cb54-247" aria-hidden="true" tabindex="-1"></a>        todo <span class="op">+=</span> [l] <span class="cf">if</span> l <span class="cf">else</span> []</span>
<span id="cb54-248"><a href="#cb54-248" aria-hidden="true" tabindex="-1"></a>        todo <span class="op">+=</span> [r] <span class="cf">if</span> r <span class="cf">else</span> []</span>
<span id="cb54-249"><a href="#cb54-249" aria-hidden="true" tabindex="-1"></a>        done <span class="op">+=</span> [(m[<span class="dv">0</span>] <span class="op">+</span> dest <span class="op">-</span> src, m[<span class="dv">1</span>] <span class="op">+</span> dest <span class="op">-</span> src)] <span class="cf">if</span> m <span class="cf">else</span> []</span>
<span id="cb54-250"><a href="#cb54-250" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> done, todo</span>
<span id="cb54-251"><a href="#cb54-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-252"><a href="#cb54-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-253"><a href="#cb54-253" aria-hidden="true" tabindex="-1"></a>ranges <span class="op">=</span> [(start, start <span class="op">+</span> l) <span class="cf">for</span> start, l <span class="kw">in</span> more_itertools.chunked(seeds, <span class="dv">2</span>)]</span>
<span id="cb54-254"><a href="#cb54-254" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ruleset <span class="kw">in</span> rules:</span>
<span id="cb54-255"><a href="#cb54-255" aria-hidden="true" tabindex="-1"></a>    todo <span class="op">=</span> ranges</span>
<span id="cb54-256"><a href="#cb54-256" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> []</span>
<span id="cb54-257"><a href="#cb54-257" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> rule <span class="kw">in</span> ruleset:</span>
<span id="cb54-258"><a href="#cb54-258" aria-hidden="true" tabindex="-1"></a>        new_ranges, todo <span class="op">=</span> split_ranges(todo, rule)</span>
<span id="cb54-259"><a href="#cb54-259" aria-hidden="true" tabindex="-1"></a>        ranges <span class="op">+=</span> new_ranges</span>
<span id="cb54-260"><a href="#cb54-260" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">+=</span> todo</span>
<span id="cb54-261"><a href="#cb54-261" aria-hidden="true" tabindex="-1"></a><span class="bu">min</span>(x[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> ranges)</span>
<span id="cb54-262"><a href="#cb54-262" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-263"><a href="#cb54-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-264"><a href="#cb54-264" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 6: Wait For It](https://adventofcode.com/2023/day/6)</span></span>
<span id="cb54-265"><a href="#cb54-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-266"><a href="#cb54-266" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-267"><a href="#cb54-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-268"><a href="#cb54-268" aria-hidden="true" tabindex="-1"></a>We can set up an equation for how far the boat will move in a given time, $t$ when waiting for a given period $w$ at the start, to wit $$</span>
<span id="cb54-269"><a href="#cb54-269" aria-hidden="true" tabindex="-1"></a>d(t, w) = w(t-w)</span>
<span id="cb54-270"><a href="#cb54-270" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb54-271"><a href="#cb54-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-272"><a href="#cb54-272" aria-hidden="true" tabindex="-1"></a>We are interested in which values of $w$ give $d(t_0, w) &gt; d_0$, for the $d_0, t_0$ pairs we are given in the input, which is the same as exploring when the parabola described by $-w^2 +wt_0 - d_0$ is positive. This parabola has a maximum at $w = \frac{t_0}{2}$, and it's positive region (if any) will lie between the two roots. The roots are given by</span>
<span id="cb54-273"><a href="#cb54-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-274"><a href="#cb54-274" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb54-275"><a href="#cb54-275" aria-hidden="true" tabindex="-1"></a>w_{1,2} = \frac{t_0 \mp \sqrt{t_0^2 - 4d_0^2}}{2};</span>
<span id="cb54-276"><a href="#cb54-276" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb54-277"><a href="#cb54-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-278"><a href="#cb54-278" aria-hidden="true" tabindex="-1"></a>and for each $(d_0, t_0)$ pair we are interested in how many integers lie in the open interval $(w_1, w_2)$</span>
<span id="cb54-279"><a href="#cb54-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-282"><a href="#cb54-282" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-283"><a href="#cb54-283" aria-hidden="true" tabindex="-1"></a>ts, ds <span class="op">=</span> np.array(load(<span class="dv">6</span>, <span class="st">"int"</span>))</span>
<span id="cb54-284"><a href="#cb54-284" aria-hidden="true" tabindex="-1"></a>Δs <span class="op">=</span> np.sqrt(ts<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> ds)</span>
<span id="cb54-285"><a href="#cb54-285" aria-hidden="true" tabindex="-1"></a>np.prod(np.floor(ts <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> Δs <span class="op">/</span> <span class="dv">2</span> <span class="op">-</span> <span class="fl">1e-10</span>) <span class="op">-</span> np.ceil(ts <span class="op">/</span> <span class="dv">2</span> <span class="op">-</span> Δs <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> <span class="fl">1e-10</span>) <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb54-286"><a href="#cb54-286" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-287"><a href="#cb54-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-288"><a href="#cb54-288" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-289"><a href="#cb54-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-290"><a href="#cb54-290" aria-hidden="true" tabindex="-1"></a>For part 2, we don't need to change anything.</span>
<span id="cb54-291"><a href="#cb54-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-294"><a href="#cb54-294" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-295"><a href="#cb54-295" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="bu">int</span>(<span class="st">""</span>.join([<span class="bu">str</span>(x) <span class="cf">for</span> x <span class="kw">in</span> ts]))</span>
<span id="cb54-296"><a href="#cb54-296" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="bu">int</span>(<span class="st">""</span>.join([<span class="bu">str</span>(x) <span class="cf">for</span> x <span class="kw">in</span> ds]))</span>
<span id="cb54-297"><a href="#cb54-297" aria-hidden="true" tabindex="-1"></a>Δ <span class="op">=</span> np.sqrt(t<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> d)</span>
<span id="cb54-298"><a href="#cb54-298" aria-hidden="true" tabindex="-1"></a>np.floor(t <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> Δ <span class="op">/</span> <span class="dv">2</span> <span class="op">-</span> <span class="fl">1e-10</span>) <span class="op">-</span> np.ceil(t <span class="op">/</span> <span class="dv">2</span> <span class="op">-</span> Δ <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> <span class="fl">1e-10</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb54-299"><a href="#cb54-299" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-300"><a href="#cb54-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-301"><a href="#cb54-301" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 7: Camel Cards](https://adventofcode.com/2023/day/7)</span></span>
<span id="cb54-302"><a href="#cb54-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-303"><a href="#cb54-303" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-304"><a href="#cb54-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-305"><a href="#cb54-305" aria-hidden="true" tabindex="-1"></a>This feels doable. The key is to find a method to compare two hands of cards. We can use <span class="in">`np.unique`</span>{.verbatim} to get the count of how many times each unique value appears in the hand, which is almost exactly what we need. If we sort this count, then two hands will compare correctly if we compare their count tuples, since tuples sort lexicographically. The final comparator is <span class="in">`[counts, [card_value for card in hand]]`</span>{.verbatim}, to correctly sort hands of the same type but with different values.</span>
<span id="cb54-306"><a href="#cb54-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-309"><a href="#cb54-309" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-310"><a href="#cb54-310" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> counts(hand, part<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb54-311"><a href="#cb54-311" aria-hidden="true" tabindex="-1"></a>    hand <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> hand <span class="cf">if</span> x <span class="op">!=</span> <span class="st">"J"</span>] <span class="cf">if</span> part <span class="op">==</span> <span class="dv">2</span> <span class="cf">else</span> hand</span>
<span id="cb54-312"><a href="#cb54-312" aria-hidden="true" tabindex="-1"></a>    _, counts <span class="op">=</span> np.unique([x <span class="cf">for</span> x <span class="kw">in</span> hand], return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb54-313"><a href="#cb54-313" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> <span class="bu">sorted</span>(counts, reverse<span class="op">=</span><span class="va">True</span>) <span class="cf">if</span> hand <span class="cf">else</span> [<span class="dv">0</span>]</span>
<span id="cb54-314"><a href="#cb54-314" aria-hidden="true" tabindex="-1"></a>    counts[<span class="dv">0</span>] <span class="op">+=</span> <span class="dv">5</span> <span class="op">-</span> <span class="bu">len</span>(hand)</span>
<span id="cb54-315"><a href="#cb54-315" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> counts</span>
<span id="cb54-316"><a href="#cb54-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-317"><a href="#cb54-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-318"><a href="#cb54-318" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [x.strip().split() <span class="cf">for</span> x <span class="kw">in</span> load(<span class="dv">7</span>)]</span>
<span id="cb54-319"><a href="#cb54-319" aria-hidden="true" tabindex="-1"></a>order <span class="op">=</span> <span class="bu">sorted</span>(</span>
<span id="cb54-320"><a href="#cb54-320" aria-hidden="true" tabindex="-1"></a>    data, key<span class="op">=</span><span class="kw">lambda</span> row: [counts(row[<span class="dv">0</span>]), [<span class="st">"23456789TJQKA"</span>.index(c) <span class="cf">for</span> c <span class="kw">in</span> row[<span class="dv">0</span>]]]</span>
<span id="cb54-321"><a href="#cb54-321" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-322"><a href="#cb54-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-323"><a href="#cb54-323" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>([<span class="bu">int</span>(x[<span class="dv">1</span>]) <span class="cf">for</span> x <span class="kw">in</span> order] <span class="op">*</span> np.arange(<span class="dv">1</span>, <span class="dv">1</span> <span class="op">+</span> <span class="bu">len</span>(order)))</span>
<span id="cb54-324"><a href="#cb54-324" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-325"><a href="#cb54-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-326"><a href="#cb54-326" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-327"><a href="#cb54-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-328"><a href="#cb54-328" aria-hidden="true" tabindex="-1"></a>Part 2 was similar enough to part 1 that I just made a flag in the <span class="in">`counts`</span>{.verbatim} function and changed the order of the card values</span>
<span id="cb54-329"><a href="#cb54-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-332"><a href="#cb54-332" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-333"><a href="#cb54-333" aria-hidden="true" tabindex="-1"></a>order <span class="op">=</span> <span class="bu">sorted</span>(</span>
<span id="cb54-334"><a href="#cb54-334" aria-hidden="true" tabindex="-1"></a>    data,</span>
<span id="cb54-335"><a href="#cb54-335" aria-hidden="true" tabindex="-1"></a>    key<span class="op">=</span><span class="kw">lambda</span> row: [</span>
<span id="cb54-336"><a href="#cb54-336" aria-hidden="true" tabindex="-1"></a>        counts(row[<span class="dv">0</span>], part<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb54-337"><a href="#cb54-337" aria-hidden="true" tabindex="-1"></a>        [<span class="st">"J23456789TQKA"</span>.index(c) <span class="cf">for</span> c <span class="kw">in</span> row[<span class="dv">0</span>]],</span>
<span id="cb54-338"><a href="#cb54-338" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb54-339"><a href="#cb54-339" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-340"><a href="#cb54-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-341"><a href="#cb54-341" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>([<span class="bu">int</span>(x[<span class="dv">1</span>]) <span class="cf">for</span> x <span class="kw">in</span> order] <span class="op">*</span> np.arange(<span class="dv">1</span>, <span class="dv">1</span> <span class="op">+</span> <span class="bu">len</span>(order)))</span>
<span id="cb54-342"><a href="#cb54-342" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-343"><a href="#cb54-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-344"><a href="#cb54-344" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 8: Haunted Wasteland](https://adventofcode.com/2023/day/8)</span></span>
<span id="cb54-345"><a href="#cb54-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-346"><a href="#cb54-346" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-347"><a href="#cb54-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-348"><a href="#cb54-348" aria-hidden="true" tabindex="-1"></a>For part 1 we build a dictionary of left, right instructions for each node, which makes following a path from start to end easy.</span>
<span id="cb54-349"><a href="#cb54-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-352"><a href="#cb54-352" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-353"><a href="#cb54-353" aria-hidden="true" tabindex="-1"></a>instructions, lines <span class="op">=</span> load(<span class="dv">8</span>, <span class="st">"raw"</span>).split(<span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb54-354"><a href="#cb54-354" aria-hidden="true" tabindex="-1"></a>instructions <span class="op">=</span> instructions.strip()</span>
<span id="cb54-355"><a href="#cb54-355" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [words <span class="cf">for</span> line <span class="kw">in</span> lines.split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>) <span class="cf">if</span> (words <span class="op">:=</span> re.findall(<span class="st">"[A-Z]+"</span>, line))]</span>
<span id="cb54-356"><a href="#cb54-356" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> {node: {<span class="st">"L"</span>: left, <span class="st">"R"</span>: right} <span class="cf">for</span> node, left, right <span class="kw">in</span> data}</span>
<span id="cb54-357"><a href="#cb54-357" aria-hidden="true" tabindex="-1"></a>node <span class="op">=</span> <span class="st">"AAA"</span></span>
<span id="cb54-358"><a href="#cb54-358" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-359"><a href="#cb54-359" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> node <span class="op">!=</span> <span class="st">"ZZZ"</span>:</span>
<span id="cb54-360"><a href="#cb54-360" aria-hidden="true" tabindex="-1"></a>    node <span class="op">=</span> nodes[node][instructions[i <span class="op">%</span> <span class="bu">len</span>(instructions)]]</span>
<span id="cb54-361"><a href="#cb54-361" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb54-362"><a href="#cb54-362" aria-hidden="true" tabindex="-1"></a>i</span>
<span id="cb54-363"><a href="#cb54-363" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-364"><a href="#cb54-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-365"><a href="#cb54-365" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-366"><a href="#cb54-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-367"><a href="#cb54-367" aria-hidden="true" tabindex="-1"></a>Part 2 screams cycle checking, and indeed it is. The state at any given time is given by the current node and the index of the instruction list. If we ever see the same state twice, we know we're in a cycle, and can figure out the period. All of the cycles turn out to have periods that match the offset from the start, so we can just use the <span class="in">`lcm`</span>{.verbatim} to find the common period. If some of the cycles had had a different offset, we would have need the full chinese remainder theorem.</span>
<span id="cb54-368"><a href="#cb54-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-371"><a href="#cb54-371" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-372"><a href="#cb54-372" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb54-373"><a href="#cb54-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-374"><a href="#cb54-374" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-375"><a href="#cb54-375" aria-hidden="true" tabindex="-1"></a>periods <span class="op">=</span> []</span>
<span id="cb54-376"><a href="#cb54-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-377"><a href="#cb54-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-378"><a href="#cb54-378" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_cycle(node):</span>
<span id="cb54-379"><a href="#cb54-379" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> {}</span>
<span id="cb54-380"><a href="#cb54-380" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-381"><a href="#cb54-381" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> <span class="va">None</span></span>
<span id="cb54-382"><a href="#cb54-382" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (node, i <span class="op">%</span> <span class="bu">len</span>(instructions)) <span class="kw">not</span> <span class="kw">in</span> seen:</span>
<span id="cb54-383"><a href="#cb54-383" aria-hidden="true" tabindex="-1"></a>        seen[node, i <span class="op">%</span> <span class="bu">len</span>(instructions)] <span class="op">=</span> i</span>
<span id="cb54-384"><a href="#cb54-384" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> nodes[node][instructions[i <span class="op">%</span> <span class="bu">len</span>(instructions)]]</span>
<span id="cb54-385"><a href="#cb54-385" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb54-386"><a href="#cb54-386" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="st">"Z"</span>:</span>
<span id="cb54-387"><a href="#cb54-387" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> i</span>
<span id="cb54-388"><a href="#cb54-388" aria-hidden="true" tabindex="-1"></a>    period <span class="op">=</span> i <span class="op">-</span> seen[(node, i <span class="op">%</span> <span class="bu">len</span>(instructions))]</span>
<span id="cb54-389"><a href="#cb54-389" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> period, z <span class="op">%</span> period</span>
<span id="cb54-390"><a href="#cb54-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-391"><a href="#cb54-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-392"><a href="#cb54-392" aria-hidden="true" tabindex="-1"></a>periods, congruences <span class="op">=</span> <span class="bu">list</span>(</span>
<span id="cb54-393"><a href="#cb54-393" aria-hidden="true" tabindex="-1"></a>    <span class="bu">zip</span>(<span class="op">*</span>[find_cycle(node) <span class="cf">for</span> node <span class="kw">in</span> nodes <span class="cf">if</span> node[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="st">"A"</span>])</span>
<span id="cb54-394"><a href="#cb54-394" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-395"><a href="#cb54-395" aria-hidden="true" tabindex="-1"></a>math.lcm(<span class="op">*</span>periods)</span>
<span id="cb54-396"><a href="#cb54-396" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-397"><a href="#cb54-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-398"><a href="#cb54-398" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 9: Mirage Maintenance](https://adventofcode.com/2023/day/9)</span></span>
<span id="cb54-399"><a href="#cb54-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-400"><a href="#cb54-400" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-401"><a href="#cb54-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-402"><a href="#cb54-402" aria-hidden="true" tabindex="-1"></a>This one's pretty straightforward: calculate all the needed differences; add the last element of each difference to the calculation.</span>
<span id="cb54-403"><a href="#cb54-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-406"><a href="#cb54-406" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-407"><a href="#cb54-407" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> score(line, part<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb54-408"><a href="#cb54-408" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-409"><a href="#cb54-409" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> part <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb54-410"><a href="#cb54-410" aria-hidden="true" tabindex="-1"></a>        line <span class="op">=</span> line[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb54-411"><a href="#cb54-411" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">any</span>(line):</span>
<span id="cb54-412"><a href="#cb54-412" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> line[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb54-413"><a href="#cb54-413" aria-hidden="true" tabindex="-1"></a>        line <span class="op">=</span> [line[i] <span class="op">-</span> line[i <span class="op">-</span> <span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(line))]</span>
<span id="cb54-414"><a href="#cb54-414" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span>
<span id="cb54-415"><a href="#cb54-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-416"><a href="#cb54-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-417"><a href="#cb54-417" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(score(line) <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">9</span>, <span class="st">"int"</span>))</span>
<span id="cb54-418"><a href="#cb54-418" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-419"><a href="#cb54-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-420"><a href="#cb54-420" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-421"><a href="#cb54-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-422"><a href="#cb54-422" aria-hidden="true" tabindex="-1"></a>…and part 2 is simple enough that it can be included in part 1 with a flag</span>
<span id="cb54-423"><a href="#cb54-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-426"><a href="#cb54-426" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-427"><a href="#cb54-427" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(score(line, part<span class="op">=</span><span class="dv">2</span>) <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">9</span>, <span class="st">"int"</span>))</span>
<span id="cb54-428"><a href="#cb54-428" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-429"><a href="#cb54-429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-430"><a href="#cb54-430" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 10: Pipe Maze](https://adventofcode.com/2023/day/10)</span></span>
<span id="cb54-431"><a href="#cb54-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-432"><a href="#cb54-432" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-433"><a href="#cb54-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-434"><a href="#cb54-434" aria-hidden="true" tabindex="-1"></a>For part 1 we find the two directions leading away from the starting point, and follow the path along each one at the same pace. The point where they overlap is the point furthest away from the start, so we return that.</span>
<span id="cb54-435"><a href="#cb54-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-438"><a href="#cb54-438" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-439"><a href="#cb54-439" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.pad(</span>
<span id="cb54-440"><a href="#cb54-440" aria-hidden="true" tabindex="-1"></a>    np.array([[char <span class="cf">for</span> char <span class="kw">in</span> line.strip()] <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">10</span>)]),</span>
<span id="cb54-441"><a href="#cb54-441" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>,</span>
<span id="cb54-442"><a href="#cb54-442" aria-hidden="true" tabindex="-1"></a>    constant_values<span class="op">=</span><span class="st">"."</span>,</span>
<span id="cb54-443"><a href="#cb54-443" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-444"><a href="#cb54-444" aria-hidden="true" tabindex="-1"></a>connections <span class="op">=</span> {</span>
<span id="cb54-445"><a href="#cb54-445" aria-hidden="true" tabindex="-1"></a>    <span class="st">"-"</span>: [(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>), (<span class="dv">0</span>, <span class="dv">1</span>)],</span>
<span id="cb54-446"><a href="#cb54-446" aria-hidden="true" tabindex="-1"></a>    <span class="st">"|"</span>: [(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="dv">0</span>)],</span>
<span id="cb54-447"><a href="#cb54-447" aria-hidden="true" tabindex="-1"></a>    <span class="st">"L"</span>: [(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">1</span>)],</span>
<span id="cb54-448"><a href="#cb54-448" aria-hidden="true" tabindex="-1"></a>    <span class="st">"J"</span>: [(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)],</span>
<span id="cb54-449"><a href="#cb54-449" aria-hidden="true" tabindex="-1"></a>    <span class="st">"7"</span>: [(<span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)],</span>
<span id="cb54-450"><a href="#cb54-450" aria-hidden="true" tabindex="-1"></a>    <span class="st">"F"</span>: [(<span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">1</span>)],</span>
<span id="cb54-451"><a href="#cb54-451" aria-hidden="true" tabindex="-1"></a>    <span class="st">"."</span>: [],</span>
<span id="cb54-452"><a href="#cb54-452" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb54-453"><a href="#cb54-453" aria-hidden="true" tabindex="-1"></a>Δs <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>], [<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb54-454"><a href="#cb54-454" aria-hidden="true" tabindex="-1"></a>point <span class="op">=</span> np.array(<span class="bu">next</span>(<span class="bu">zip</span>(<span class="op">*</span>np.where(data <span class="op">==</span> <span class="st">"S"</span>))))</span>
<span id="cb54-455"><a href="#cb54-455" aria-hidden="true" tabindex="-1"></a>(lx, lv), (rx, rv) <span class="op">=</span> [</span>
<span id="cb54-456"><a href="#cb54-456" aria-hidden="true" tabindex="-1"></a>    (point <span class="op">+</span> Δ, Δ) <span class="cf">for</span> Δ <span class="kw">in</span> Δs <span class="cf">if</span> <span class="bu">tuple</span>(<span class="op">-</span>Δ) <span class="kw">in</span> connections[data[<span class="bu">tuple</span>(point <span class="op">+</span> Δ)]]</span>
<span id="cb54-457"><a href="#cb54-457" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb54-458"><a href="#cb54-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-459"><a href="#cb54-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-460"><a href="#cb54-460" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update(point, direction):</span>
<span id="cb54-461"><a href="#cb54-461" aria-hidden="true" tabindex="-1"></a>    options <span class="op">=</span> connections[data[<span class="bu">tuple</span>(point)]]</span>
<span id="cb54-462"><a href="#cb54-462" aria-hidden="true" tabindex="-1"></a>    new_direction <span class="op">=</span> np.array(</span>
<span id="cb54-463"><a href="#cb54-463" aria-hidden="true" tabindex="-1"></a>        options[<span class="dv">1</span>] <span class="cf">if</span> <span class="bu">tuple</span>(<span class="op">-</span>direction) <span class="op">==</span> options[<span class="dv">0</span>] <span class="cf">else</span> options[<span class="dv">0</span>]</span>
<span id="cb54-464"><a href="#cb54-464" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb54-465"><a href="#cb54-465" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> point <span class="op">+</span> new_direction, new_direction</span>
<span id="cb54-466"><a href="#cb54-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-467"><a href="#cb54-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-468"><a href="#cb54-468" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb54-469"><a href="#cb54-469" aria-hidden="true" tabindex="-1"></a>left_path <span class="op">=</span> [point, lx]</span>
<span id="cb54-470"><a href="#cb54-470" aria-hidden="true" tabindex="-1"></a>right_path <span class="op">=</span> [rx]</span>
<span id="cb54-471"><a href="#cb54-471" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="kw">not</span> np.allclose(lx, rx):</span>
<span id="cb54-472"><a href="#cb54-472" aria-hidden="true" tabindex="-1"></a>    lx, lv <span class="op">=</span> update(lx, lv)</span>
<span id="cb54-473"><a href="#cb54-473" aria-hidden="true" tabindex="-1"></a>    left_path.append(lx)</span>
<span id="cb54-474"><a href="#cb54-474" aria-hidden="true" tabindex="-1"></a>    rx, rv <span class="op">=</span> update(rx, rv)</span>
<span id="cb54-475"><a href="#cb54-475" aria-hidden="true" tabindex="-1"></a>    right_path.append(rx)</span>
<span id="cb54-476"><a href="#cb54-476" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb54-477"><a href="#cb54-477" aria-hidden="true" tabindex="-1"></a>i</span>
<span id="cb54-478"><a href="#cb54-478" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-479"><a href="#cb54-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-480"><a href="#cb54-480" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-481"><a href="#cb54-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-482"><a href="#cb54-482" aria-hidden="true" tabindex="-1"></a>For part 2, we need some way of distinguishing points inside from outside the circuit. Since the lines that make up the boundary of the circuit never cross, this is a point in polygon problem. We could solve it by raytracing: for every point in the polygon we can draw all rays to the outside edge and see if they cross the boundary of the polygon an odd number of times. If they do, the point is inside the polygon. We could also look at the winding number of the polygon with respect the the point: points inside will have a nonzero winding number, while points outside will have a positive winding number.</span>
<span id="cb54-483"><a href="#cb54-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-484"><a href="#cb54-484" aria-hidden="true" tabindex="-1"></a>Ultimately, what I ended up doing was just blowing up the grid to double size, flood filling the outside and looking at the even coordinate values of whatever was left. It's stupid, but it works.</span>
<span id="cb54-485"><a href="#cb54-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-488"><a href="#cb54-488" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-489"><a href="#cb54-489" aria-hidden="true" tabindex="-1"></a>ys, xs <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>(left_path <span class="op">+</span> right_path[:<span class="op">-</span><span class="dv">1</span>][::<span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb54-490"><a href="#cb54-490" aria-hidden="true" tabindex="-1"></a>dy, dx <span class="op">=</span> np.diff([ys <span class="op">+</span> (ys[<span class="dv">0</span>],), xs <span class="op">+</span> (xs[<span class="dv">0</span>],)], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb54-491"><a href="#cb54-491" aria-hidden="true" tabindex="-1"></a>board <span class="op">=</span> np.ones((data.shape[<span class="dv">0</span>] <span class="op">*</span> <span class="dv">2</span>, data.shape[<span class="dv">1</span>] <span class="op">*</span> <span class="dv">2</span>))</span>
<span id="cb54-492"><a href="#cb54-492" aria-hidden="true" tabindex="-1"></a>ys, xs <span class="op">=</span> <span class="bu">map</span>(np.array, [ys, xs])</span>
<span id="cb54-493"><a href="#cb54-493" aria-hidden="true" tabindex="-1"></a>board[<span class="dv">2</span> <span class="op">*</span> ys, <span class="dv">2</span> <span class="op">*</span> xs] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-494"><a href="#cb54-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-495"><a href="#cb54-495" aria-hidden="true" tabindex="-1"></a>board[<span class="dv">2</span> <span class="op">*</span> ys <span class="op">+</span> dy, <span class="dv">2</span> <span class="op">*</span> xs <span class="op">+</span> dx] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-496"><a href="#cb54-496" aria-hidden="true" tabindex="-1"></a>board <span class="op">=</span> np.pad(board[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>], <span class="dv">1</span>, constant_values<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb54-497"><a href="#cb54-497" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> deque([(<span class="dv">1</span>, <span class="dv">1</span>)])</span>
<span id="cb54-498"><a href="#cb54-498" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> points:</span>
<span id="cb54-499"><a href="#cb54-499" aria-hidden="true" tabindex="-1"></a>    point <span class="op">=</span> points.popleft()</span>
<span id="cb54-500"><a href="#cb54-500" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> board[point] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb54-501"><a href="#cb54-501" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb54-502"><a href="#cb54-502" aria-hidden="true" tabindex="-1"></a>    board[point] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-503"><a href="#cb54-503" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> Δ <span class="kw">in</span> Δs:</span>
<span id="cb54-504"><a href="#cb54-504" aria-hidden="true" tabindex="-1"></a>        nb <span class="op">=</span> <span class="bu">tuple</span>(Δ <span class="op">+</span> point)</span>
<span id="cb54-505"><a href="#cb54-505" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> board[nb]:</span>
<span id="cb54-506"><a href="#cb54-506" aria-hidden="true" tabindex="-1"></a>            points.append(nb)</span>
<span id="cb54-507"><a href="#cb54-507" aria-hidden="true" tabindex="-1"></a><span class="bu">int</span>(board[::<span class="dv">2</span>, ::<span class="dv">2</span>].<span class="bu">sum</span>())</span>
<span id="cb54-508"><a href="#cb54-508" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-509"><a href="#cb54-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-510"><a href="#cb54-510" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 11: Cosmic Expansion](https://adventofcode.com/2023/day/11)</span></span>
<span id="cb54-511"><a href="#cb54-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-512"><a href="#cb54-512" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-513"><a href="#cb54-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-514"><a href="#cb54-514" aria-hidden="true" tabindex="-1"></a>I liked this puzzle, and I feel that I managed to come up with an OK slick array solution. We can get the coordinates of the original galaxies and the empty rows using <span class="in">`np.where`</span>{.verbatim}. For each empty row we can increase the first coordinate of the galaxies below it by some amount, and, mutatis mutandis, we can do the same for the empty columns.</span>
<span id="cb54-515"><a href="#cb54-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-516"><a href="#cb54-516" aria-hidden="true" tabindex="-1"></a>That gives us a set of new coordinates, and we need to find the sum of all the manhattan distances from one point to the others. for any pair of points $i, j$, that's $\left|x_i - x_j\right| +\left|y_i - y_j\right|$; we can construct the entire matrix by taking the row vector of coordinates, and subtracting from it the column vector of the same coordinates and relying on <span class="in">`numpy`</span>{.verbatim}'s broadcasting magic.</span>
<span id="cb54-517"><a href="#cb54-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-520"><a href="#cb54-520" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-521"><a href="#cb54-521" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> solve(s<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb54-522"><a href="#cb54-522" aria-hidden="true" tabindex="-1"></a>    y, x <span class="op">=</span> np.where(data <span class="op">==</span> <span class="st">"#"</span>)</span>
<span id="cb54-523"><a href="#cb54-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-524"><a href="#cb54-524" aria-hidden="true" tabindex="-1"></a>    empty_r <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(data)) <span class="cf">if</span> <span class="bu">all</span>(data[i] <span class="op">==</span> <span class="st">"."</span>)]</span>
<span id="cb54-525"><a href="#cb54-525" aria-hidden="true" tabindex="-1"></a>    empty_c <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(data)) <span class="cf">if</span> <span class="bu">all</span>(data[:, i] <span class="op">==</span> <span class="st">"."</span>)]</span>
<span id="cb54-526"><a href="#cb54-526" aria-hidden="true" tabindex="-1"></a>    new_y <span class="op">=</span> y <span class="op">+</span> s <span class="op">*</span> np.array([y <span class="op">&gt;</span> empty_r[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(empty_r))]).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb54-527"><a href="#cb54-527" aria-hidden="true" tabindex="-1"></a>    new_x <span class="op">=</span> x <span class="op">+</span> s <span class="op">*</span> np.array([x <span class="op">&gt;</span> empty_c[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(empty_c))]).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb54-528"><a href="#cb54-528" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (</span>
<span id="cb54-529"><a href="#cb54-529" aria-hidden="true" tabindex="-1"></a>        <span class="bu">abs</span>(new_y <span class="op">-</span> new_y.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">+</span> <span class="bu">abs</span>(new_x <span class="op">-</span> new_x.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb54-530"><a href="#cb54-530" aria-hidden="true" tabindex="-1"></a>    ).<span class="bu">sum</span>() <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb54-531"><a href="#cb54-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-532"><a href="#cb54-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-533"><a href="#cb54-533" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">11</span>, <span class="st">"chararray"</span>)</span>
<span id="cb54-534"><a href="#cb54-534" aria-hidden="true" tabindex="-1"></a>solve()</span>
<span id="cb54-535"><a href="#cb54-535" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-536"><a href="#cb54-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-537"><a href="#cb54-537" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-538"><a href="#cb54-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-539"><a href="#cb54-539" aria-hidden="true" tabindex="-1"></a>The second part is pretty trivially included in the first</span>
<span id="cb54-540"><a href="#cb54-540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-543"><a href="#cb54-543" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-544"><a href="#cb54-544" aria-hidden="true" tabindex="-1"></a>solve(<span class="dv">999_999</span>)</span>
<span id="cb54-545"><a href="#cb54-545" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-546"><a href="#cb54-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-547"><a href="#cb54-547" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 12: Hot Springs](https://adventofcode.com/2023/day/12)</span></span>
<span id="cb54-548"><a href="#cb54-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-549"><a href="#cb54-549" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-550"><a href="#cb54-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-551"><a href="#cb54-551" aria-hidden="true" tabindex="-1"></a>The core of this solution is the <span class="in">`count`</span>{.verbatim} function, which takes a tuple of ints representing the three states (off, ambiguous and on), as well as a tuple of block lengths, and returns the number of assignments of the ambiguous values that work.</span>
<span id="cb54-552"><a href="#cb54-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-553"><a href="#cb54-553" aria-hidden="true" tabindex="-1"></a>It's recursive, with the following base cases; the third is checked last:</span>
<span id="cb54-554"><a href="#cb54-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-555"><a href="#cb54-555" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>If the number of on values is more than the sum of block lengths, no assignments are possible</span>
<span id="cb54-556"><a href="#cb54-556" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>If the sum of the number of on values and ambiguous values is less than the sum of block lengths, no assignments are possible</span>
<span id="cb54-557"><a href="#cb54-557" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>If the sum of block lengths is zero, exactly one assignment is possible</span>
<span id="cb54-558"><a href="#cb54-558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-559"><a href="#cb54-559" aria-hidden="true" tabindex="-1"></a>Otherwise, if the first character is off, then the count is the same as the count ignoring that assignment and we can recurse.</span>
<span id="cb54-560"><a href="#cb54-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-561"><a href="#cb54-561" aria-hidden="true" tabindex="-1"></a>If the first character is on, we can check whether the first <span class="in">`l`</span>{.verbatim} characters would fit the first block, and the <span class="in">`l+1`</span>{.verbatim}'th character is either the end of the string or compatible with an off state. If it is, the count is the same as the count for the remainder of the string on the remainder of the blocks and we can recurse.</span>
<span id="cb54-562"><a href="#cb54-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-563"><a href="#cb54-563" aria-hidden="true" tabindex="-1"></a>Finally, if the first character is ambiguous, the count is the sum of the counts for the two possible assignments of the character, and we can recurse.</span>
<span id="cb54-564"><a href="#cb54-564" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-567"><a href="#cb54-567" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-568"><a href="#cb54-568" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse(line):</span>
<span id="cb54-569"><a href="#cb54-569" aria-hidden="true" tabindex="-1"></a>    s, groups <span class="op">=</span> line.strip().split(<span class="st">" "</span>)</span>
<span id="cb54-570"><a href="#cb54-570" aria-hidden="true" tabindex="-1"></a>    lookup <span class="op">=</span> {<span class="st">"#"</span>: <span class="dv">2</span>, <span class="st">"?"</span>: <span class="dv">1</span>, <span class="st">"."</span>: <span class="dv">0</span>}</span>
<span id="cb54-571"><a href="#cb54-571" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">tuple</span>(lookup[char] <span class="cf">for</span> char <span class="kw">in</span> s), <span class="bu">tuple</span>(<span class="bu">int</span>(g) <span class="cf">for</span> g <span class="kw">in</span> groups.split(<span class="st">","</span>))</span>
<span id="cb54-572"><a href="#cb54-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-573"><a href="#cb54-573" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-574"><a href="#cb54-574" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [parse(x) <span class="cf">for</span> x <span class="kw">in</span> load(<span class="dv">12</span>)]</span>
<span id="cb54-575"><a href="#cb54-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-576"><a href="#cb54-576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-577"><a href="#cb54-577" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> match_beginning(data, length):</span>
<span id="cb54-578"><a href="#cb54-578" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">all</span>(x <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> data[:length]) <span class="kw">and</span> (</span>
<span id="cb54-579"><a href="#cb54-579" aria-hidden="true" tabindex="-1"></a>        (<span class="bu">len</span>(data) <span class="op">==</span> length) <span class="kw">or</span> data[length] <span class="op">&lt;</span> <span class="dv">2</span></span>
<span id="cb54-580"><a href="#cb54-580" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb54-581"><a href="#cb54-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-582"><a href="#cb54-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-583"><a href="#cb54-583" aria-hidden="true" tabindex="-1"></a><span class="at">@functools.cache</span></span>
<span id="cb54-584"><a href="#cb54-584" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count(data, blocks):</span>
<span id="cb54-585"><a href="#cb54-585" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="bu">sum</span>(blocks)</span>
<span id="cb54-586"><a href="#cb54-586" aria-hidden="true" tabindex="-1"></a>    minimum <span class="op">=</span> <span class="bu">sum</span>(x <span class="op">==</span> <span class="dv">2</span> <span class="cf">for</span> x <span class="kw">in</span> data)</span>
<span id="cb54-587"><a href="#cb54-587" aria-hidden="true" tabindex="-1"></a>    maximum <span class="op">=</span> <span class="bu">sum</span>(x <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> data)</span>
<span id="cb54-588"><a href="#cb54-588" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> minimum <span class="op">&gt;</span> total <span class="kw">or</span> maximum <span class="op">&lt;</span> total:</span>
<span id="cb54-589"><a href="#cb54-589" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb54-590"><a href="#cb54-590" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> total <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb54-591"><a href="#cb54-591" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb54-592"><a href="#cb54-592" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> data[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb54-593"><a href="#cb54-593" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count(data[<span class="dv">1</span>:], blocks)</span>
<span id="cb54-594"><a href="#cb54-594" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> data[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb54-595"><a href="#cb54-595" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> blocks[<span class="dv">0</span>]</span>
<span id="cb54-596"><a href="#cb54-596" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> match_beginning(data, l):</span>
<span id="cb54-597"><a href="#cb54-597" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> l <span class="op">==</span> <span class="bu">len</span>(data):</span>
<span id="cb54-598"><a href="#cb54-598" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb54-599"><a href="#cb54-599" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> count(data[l <span class="op">+</span> <span class="dv">1</span> :], blocks[<span class="dv">1</span>:])</span>
<span id="cb54-600"><a href="#cb54-600" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb54-601"><a href="#cb54-601" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count(data[<span class="dv">1</span>:], blocks) <span class="op">+</span> count((<span class="dv">2</span>,) <span class="op">+</span> data[<span class="dv">1</span>:], blocks)</span>
<span id="cb54-602"><a href="#cb54-602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-603"><a href="#cb54-603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-604"><a href="#cb54-604" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(count(<span class="op">*</span>line) <span class="cf">for</span> line <span class="kw">in</span> data)</span>
<span id="cb54-605"><a href="#cb54-605" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-606"><a href="#cb54-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-607"><a href="#cb54-607" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-608"><a href="#cb54-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-609"><a href="#cb54-609" aria-hidden="true" tabindex="-1"></a>With the memoization added to part 1, part 2 runs in 8s with no changes needed. Not great, but not terrible</span>
<span id="cb54-610"><a href="#cb54-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-613"><a href="#cb54-613" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-614"><a href="#cb54-614" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(count(((chars <span class="op">+</span> (<span class="dv">1</span>,)) <span class="op">*</span> <span class="dv">5</span>)[:<span class="op">-</span><span class="dv">1</span>], blocks <span class="op">*</span> <span class="dv">5</span>) <span class="cf">for</span> chars, blocks <span class="kw">in</span> data)</span>
<span id="cb54-615"><a href="#cb54-615" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-616"><a href="#cb54-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-617"><a href="#cb54-617" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 13: Point of Incidence](https://adventofcode.com/2023/day/13)</span></span>
<span id="cb54-618"><a href="#cb54-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-619"><a href="#cb54-619" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-620"><a href="#cb54-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-621"><a href="#cb54-621" aria-hidden="true" tabindex="-1"></a>This wasn't too tricky. The idea is that we test all horizontal lines of reflection to see if there are any that match the given condition; if none are found, we rotate the array by 90 degrees clockwise and try again. For part 1, the test is that the two halves should line up exactly after flipping.</span>
<span id="cb54-622"><a href="#cb54-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-623"><a href="#cb54-623" aria-hidden="true" tabindex="-1"></a>The only bit that requires some thought is how to account for the points beyond the top/bottom edge. We do that by saying that the number of lines on either side of the mirror line is the shortest distance to the top/bottom edge, so that only relevant lines are compared.</span>
<span id="cb54-624"><a href="#cb54-624" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-627"><a href="#cb54-627" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-628"><a href="#cb54-628" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_reflection(array, part<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb54-629"><a href="#cb54-629" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> part <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb54-630"><a href="#cb54-630" aria-hidden="true" tabindex="-1"></a>        test <span class="op">=</span> <span class="kw">lambda</span> a, b: (a <span class="op">==</span> b[::<span class="op">-</span><span class="dv">1</span>]).<span class="bu">all</span>()</span>
<span id="cb54-631"><a href="#cb54-631" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb54-632"><a href="#cb54-632" aria-hidden="true" tabindex="-1"></a>        test <span class="op">=</span> <span class="kw">lambda</span> a, b: (a <span class="op">!=</span> b[::<span class="op">-</span><span class="dv">1</span>]).<span class="bu">sum</span>() <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb54-633"><a href="#cb54-633" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(array)):</span>
<span id="cb54-634"><a href="#cb54-634" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> <span class="bu">min</span>(<span class="bu">len</span>(array) <span class="op">-</span> i, i)</span>
<span id="cb54-635"><a href="#cb54-635" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> test(array[i <span class="op">-</span> l : i], array[i : i <span class="op">+</span> l]):</span>
<span id="cb54-636"><a href="#cb54-636" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> i</span>
<span id="cb54-637"><a href="#cb54-637" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb54-638"><a href="#cb54-638" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-639"><a href="#cb54-639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-640"><a href="#cb54-640" aria-hidden="true" tabindex="-1"></a>arrays <span class="op">=</span> [</span>
<span id="cb54-641"><a href="#cb54-641" aria-hidden="true" tabindex="-1"></a>    np.array([[char <span class="cf">for</span> char <span class="kw">in</span> line.strip()] <span class="cf">for</span> line <span class="kw">in</span> array.split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)])</span>
<span id="cb54-642"><a href="#cb54-642" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> array <span class="kw">in</span> load(<span class="dv">13</span>, <span class="st">"raw"</span>).split(<span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb54-643"><a href="#cb54-643" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb54-644"><a href="#cb54-644" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-645"><a href="#cb54-645" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(</span>
<span id="cb54-646"><a href="#cb54-646" aria-hidden="true" tabindex="-1"></a>    <span class="dv">100</span> <span class="op">*</span> y</span>
<span id="cb54-647"><a href="#cb54-647" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (y <span class="op">:=</span> find_reflection(array)) <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span></span>
<span id="cb54-648"><a href="#cb54-648" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> find_reflection(np.rot90(array, <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb54-649"><a href="#cb54-649" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> array <span class="kw">in</span> arrays</span>
<span id="cb54-650"><a href="#cb54-650" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-651"><a href="#cb54-651" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-652"><a href="#cb54-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-653"><a href="#cb54-653" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-654"><a href="#cb54-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-655"><a href="#cb54-655" aria-hidden="true" tabindex="-1"></a>Part 2 is so similar to part 1 that we can include it as a flag there; instead of a perfect match, the test is that exactly one pair of elements should be different on the two sides of the mirror line. Conceptually, that means that the sum of the differences should be exactly 1.</span>
<span id="cb54-656"><a href="#cb54-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-659"><a href="#cb54-659" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-660"><a href="#cb54-660" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(</span>
<span id="cb54-661"><a href="#cb54-661" aria-hidden="true" tabindex="-1"></a>    <span class="dv">100</span> <span class="op">*</span> y</span>
<span id="cb54-662"><a href="#cb54-662" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (y <span class="op">:=</span> find_reflection(array, part<span class="op">=</span><span class="dv">2</span>)) <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span></span>
<span id="cb54-663"><a href="#cb54-663" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> find_reflection(np.rot90(array, <span class="op">-</span><span class="dv">1</span>), part<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb54-664"><a href="#cb54-664" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> array <span class="kw">in</span> arrays</span>
<span id="cb54-665"><a href="#cb54-665" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-666"><a href="#cb54-666" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-667"><a href="#cb54-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-668"><a href="#cb54-668" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 14: Parabolic Reflector Dish](https://adventofcode.com/2023/day/14)</span></span>
<span id="cb54-669"><a href="#cb54-669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-670"><a href="#cb54-670" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-671"><a href="#cb54-671" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-672"><a href="#cb54-672" aria-hidden="true" tabindex="-1"></a>Part 1 needs a bit of thought. I'll represent the data as a <span class="in">`numpy`</span>{.verbatim} array, with -1 corresponding to unmoveable rock, 0 to rolling rock, and 1 to empty space. To roll all the rocks northwards, we should focus one column at a time, and between every pair of unmoveable rocks, we sort the intervening data.</span>
<span id="cb54-673"><a href="#cb54-673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-674"><a href="#cb54-674" aria-hidden="true" tabindex="-1"></a>Once that's done, we can just score the whole array</span>
<span id="cb54-675"><a href="#cb54-675" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-678"><a href="#cb54-678" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-679"><a href="#cb54-679" aria-hidden="true" tabindex="-1"></a>map_ <span class="op">=</span> {<span class="st">"#"</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">"O"</span>: <span class="dv">0</span>, <span class="st">"."</span>: <span class="dv">1</span>}</span>
<span id="cb54-680"><a href="#cb54-680" aria-hidden="true" tabindex="-1"></a>array <span class="op">=</span> np.array([[map_[char] <span class="cf">for</span> char <span class="kw">in</span> line] <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">14</span>)])</span>
<span id="cb54-681"><a href="#cb54-681" aria-hidden="true" tabindex="-1"></a>nrows, ncols <span class="op">=</span> array.shape</span>
<span id="cb54-682"><a href="#cb54-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-683"><a href="#cb54-683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-684"><a href="#cb54-684" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> score(array):</span>
<span id="cb54-685"><a href="#cb54-685" aria-hidden="true" tabindex="-1"></a>    rolls <span class="op">=</span> np.where(array <span class="op">==</span> <span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb54-686"><a href="#cb54-686" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (nrows <span class="op">-</span> rolls).<span class="bu">sum</span>()</span>
<span id="cb54-687"><a href="#cb54-687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-688"><a href="#cb54-688" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-689"><a href="#cb54-689" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> roll(array):</span>
<span id="cb54-690"><a href="#cb54-690" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ncols):</span>
<span id="cb54-691"><a href="#cb54-691" aria-hidden="true" tabindex="-1"></a>        rocks <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="bu">list</span>(np.where(array[:, i] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>)[<span class="dv">0</span>]) <span class="op">+</span> [<span class="va">None</span>]</span>
<span id="cb54-692"><a href="#cb54-692" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(rocks) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb54-693"><a href="#cb54-693" aria-hidden="true" tabindex="-1"></a>            left, right <span class="op">=</span> rocks[j] <span class="op">+</span> <span class="dv">1</span>, rocks[j <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb54-694"><a href="#cb54-694" aria-hidden="true" tabindex="-1"></a>            array[left:right, i] <span class="op">=</span> np.sort(array[left:right, i])</span>
<span id="cb54-695"><a href="#cb54-695" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> array</span>
<span id="cb54-696"><a href="#cb54-696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-697"><a href="#cb54-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-698"><a href="#cb54-698" aria-hidden="true" tabindex="-1"></a>score(roll(array))</span>
<span id="cb54-699"><a href="#cb54-699" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-700"><a href="#cb54-700" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-701"><a href="#cb54-701" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-702"><a href="#cb54-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-703"><a href="#cb54-703" aria-hidden="true" tabindex="-1"></a>The numbers in part 2 are ridiculous enough that we obviously have to hope for some pattern in how the rocks move. We'll store a fingerprint of the current state, and after each cycle, check if we're in a state we've seen before. If we are, we've found a cycle and can skip straight to the end.</span>
<span id="cb54-704"><a href="#cb54-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-707"><a href="#cb54-707" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-708"><a href="#cb54-708" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cycle(array):</span>
<span id="cb54-709"><a href="#cb54-709" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb54-710"><a href="#cb54-710" aria-hidden="true" tabindex="-1"></a>        array <span class="op">=</span> roll(array)</span>
<span id="cb54-711"><a href="#cb54-711" aria-hidden="true" tabindex="-1"></a>        array <span class="op">=</span> np.rot90(array, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb54-712"><a href="#cb54-712" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> array</span>
<span id="cb54-713"><a href="#cb54-713" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-714"><a href="#cb54-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-715"><a href="#cb54-715" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hash_(array):</span>
<span id="cb54-716"><a href="#cb54-716" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">tuple</span>(array.ravel())</span>
<span id="cb54-717"><a href="#cb54-717" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-718"><a href="#cb54-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-719"><a href="#cb54-719" aria-hidden="true" tabindex="-1"></a>seen, scores <span class="op">=</span> {}, {}</span>
<span id="cb54-720"><a href="#cb54-720" aria-hidden="true" tabindex="-1"></a>maxval <span class="op">=</span> <span class="dv">1_000_000_000</span></span>
<span id="cb54-721"><a href="#cb54-721" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(maxval):</span>
<span id="cb54-722"><a href="#cb54-722" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> hash_(array)</span>
<span id="cb54-723"><a href="#cb54-723" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> h <span class="kw">in</span> seen:</span>
<span id="cb54-724"><a href="#cb54-724" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb54-725"><a href="#cb54-725" aria-hidden="true" tabindex="-1"></a>    seen[h] <span class="op">=</span> i</span>
<span id="cb54-726"><a href="#cb54-726" aria-hidden="true" tabindex="-1"></a>    scores[i] <span class="op">=</span> score(array)</span>
<span id="cb54-727"><a href="#cb54-727" aria-hidden="true" tabindex="-1"></a>    array <span class="op">=</span> cycle(array)</span>
<span id="cb54-728"><a href="#cb54-728" aria-hidden="true" tabindex="-1"></a>cycle_length <span class="op">=</span> i <span class="op">-</span> seen[h]</span>
<span id="cb54-729"><a href="#cb54-729" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> seen[h] <span class="op">+</span> (maxval <span class="op">-</span> seen[h]) <span class="op">%</span> cycle_length</span>
<span id="cb54-730"><a href="#cb54-730" aria-hidden="true" tabindex="-1"></a>scores[index]</span>
<span id="cb54-731"><a href="#cb54-731" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-732"><a href="#cb54-732" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-733"><a href="#cb54-733" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 15: Lens Library](https://adventofcode.com/2023/day/15)</span></span>
<span id="cb54-734"><a href="#cb54-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-735"><a href="#cb54-735" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-736"><a href="#cb54-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-737"><a href="#cb54-737" aria-hidden="true" tabindex="-1"></a>Part 1 can be done with a single expression. Always nice when that happens. I originally had both the hash function and the data loading directly in the sum generator expression, but I needed them for part two so I pulled them out to their own lines.</span>
<span id="cb54-738"><a href="#cb54-738" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-741"><a href="#cb54-741" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-742"><a href="#cb54-742" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hash_(s):</span>
<span id="cb54-743"><a href="#cb54-743" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> functools.<span class="bu">reduce</span>(<span class="kw">lambda</span> x, y: (<span class="dv">17</span> <span class="op">*</span> (x <span class="op">+</span> <span class="bu">ord</span>(y))) <span class="op">%</span> <span class="dv">256</span>, s, <span class="dv">0</span>)</span>
<span id="cb54-744"><a href="#cb54-744" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-745"><a href="#cb54-745" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-746"><a href="#cb54-746" aria-hidden="true" tabindex="-1"></a>instructions <span class="op">=</span> load(<span class="dv">15</span>, <span class="st">"raw"</span>).split(<span class="st">","</span>)</span>
<span id="cb54-747"><a href="#cb54-747" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(hash_(i) <span class="cf">for</span> i <span class="kw">in</span> instructions)</span>
<span id="cb54-748"><a href="#cb54-748" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-749"><a href="#cb54-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-750"><a href="#cb54-750" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-751"><a href="#cb54-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-752"><a href="#cb54-752" aria-hidden="true" tabindex="-1"></a>Part 2 is fiddly and less fun. We need to run through each of the instructions and apply the procedure described. There might be better ways than this, but the below works:</span>
<span id="cb54-753"><a href="#cb54-753" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-756"><a href="#cb54-756" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-757"><a href="#cb54-757" aria-hidden="true" tabindex="-1"></a>boxes <span class="op">=</span> [{} <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">256</span>)]</span>
<span id="cb54-758"><a href="#cb54-758" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> instruction <span class="kw">in</span> instructions:</span>
<span id="cb54-759"><a href="#cb54-759" aria-hidden="true" tabindex="-1"></a>    label, f <span class="op">=</span> instruction.replace(<span class="st">"-"</span>, <span class="st">"="</span>).split(<span class="st">"="</span>)</span>
<span id="cb54-760"><a href="#cb54-760" aria-hidden="true" tabindex="-1"></a>    destination <span class="op">=</span> hash_(label)</span>
<span id="cb54-761"><a href="#cb54-761" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">"="</span> <span class="kw">in</span> instruction:</span>
<span id="cb54-762"><a href="#cb54-762" aria-hidden="true" tabindex="-1"></a>        boxes[destination][label] <span class="op">=</span> <span class="bu">int</span>(f)</span>
<span id="cb54-763"><a href="#cb54-763" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> label <span class="kw">in</span> boxes[destination]:</span>
<span id="cb54-764"><a href="#cb54-764" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> boxes[destination][label]</span>
<span id="cb54-765"><a href="#cb54-765" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-766"><a href="#cb54-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-767"><a href="#cb54-767" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> score(box):</span>
<span id="cb54-768"><a href="#cb54-768" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="bu">list</span>(box.values()) <span class="op">*</span> np.arange(<span class="dv">1</span>, <span class="bu">len</span>(box) <span class="op">+</span> <span class="dv">1</span>)).<span class="bu">sum</span>()</span>
<span id="cb54-769"><a href="#cb54-769" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-770"><a href="#cb54-770" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-771"><a href="#cb54-771" aria-hidden="true" tabindex="-1"></a><span class="bu">int</span>(<span class="bu">sum</span>(np.arange(<span class="dv">1</span>, <span class="dv">257</span>) <span class="op">*</span> [score(box) <span class="cf">for</span> box <span class="kw">in</span> boxes]))</span>
<span id="cb54-772"><a href="#cb54-772" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-773"><a href="#cb54-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-774"><a href="#cb54-774" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 16: The Floor Will Be Lava](https://adventofcode.com/2023/day/16)</span></span>
<span id="cb54-775"><a href="#cb54-775" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-776"><a href="#cb54-776" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-777"><a href="#cb54-777" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-778"><a href="#cb54-778" aria-hidden="true" tabindex="-1"></a>Part 1 is fairly straightforward. We'll need a way of tracking states we've already seen, and a recipe for moving from one state to the next. A state consists of a (position, direction) pair; if we ever hit a position and direction we've seen before we know we're not going to do anything new (and that there's an infinite loop in the light circuit).</span>
<span id="cb54-779"><a href="#cb54-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-780"><a href="#cb54-780" aria-hidden="true" tabindex="-1"></a>We'll store the grid as a dictionary of coordinates -<span class="sc">\&gt;</span> value, with the x and y coordinates encoded as a single complex number. That makes checking for when we've left the edge of the grid easy; we just have to check if the current coordinates are in the dictionary.</span>
<span id="cb54-781"><a href="#cb54-781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-782"><a href="#cb54-782" aria-hidden="true" tabindex="-1"></a>The diagonal mirrors transpose the coordinates of our direction, so that horizontal movement becomes vertical and vice versa. The beam splitters force us into vertical/horizontal movement and make us add an extra beam to the queue we're going through.</span>
<span id="cb54-783"><a href="#cb54-783" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-786"><a href="#cb54-786" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-787"><a href="#cb54-787" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">16</span>, <span class="st">"chararray"</span>)</span>
<span id="cb54-788"><a href="#cb54-788" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> {</span>
<span id="cb54-789"><a href="#cb54-789" aria-hidden="true" tabindex="-1"></a>    <span class="ot">1j</span> <span class="op">*</span> y <span class="op">+</span> x: data[y, x] <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(data.shape[<span class="dv">1</span>]) <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(data.shape[<span class="dv">0</span>])</span>
<span id="cb54-790"><a href="#cb54-790" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb54-791"><a href="#cb54-791" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-792"><a href="#cb54-792" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-793"><a href="#cb54-793" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_points(position, direction):</span>
<span id="cb54-794"><a href="#cb54-794" aria-hidden="true" tabindex="-1"></a>    positions <span class="op">=</span> deque([(position, direction)])</span>
<span id="cb54-795"><a href="#cb54-795" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb54-796"><a href="#cb54-796" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> positions:</span>
<span id="cb54-797"><a href="#cb54-797" aria-hidden="true" tabindex="-1"></a>        position, direction <span class="op">=</span> positions.popleft()</span>
<span id="cb54-798"><a href="#cb54-798" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> position <span class="kw">in</span> grid:</span>
<span id="cb54-799"><a href="#cb54-799" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (position, direction) <span class="kw">in</span> seen:</span>
<span id="cb54-800"><a href="#cb54-800" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb54-801"><a href="#cb54-801" aria-hidden="true" tabindex="-1"></a>            seen.add((position, direction))</span>
<span id="cb54-802"><a href="#cb54-802" aria-hidden="true" tabindex="-1"></a>            char <span class="op">=</span> grid[position]</span>
<span id="cb54-803"><a href="#cb54-803" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> char <span class="kw">in</span> <span class="st">"/</span><span class="ch">\\</span><span class="st">"</span>:</span>
<span id="cb54-804"><a href="#cb54-804" aria-hidden="true" tabindex="-1"></a>                direction <span class="op">=</span> <span class="bu">int</span>(direction.imag) <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> <span class="bu">int</span>(direction.real)</span>
<span id="cb54-805"><a href="#cb54-805" aria-hidden="true" tabindex="-1"></a>                direction <span class="op">*=</span> <span class="op">-</span><span class="dv">1</span> <span class="cf">if</span> char <span class="op">==</span> <span class="st">"/"</span> <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb54-806"><a href="#cb54-806" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> char <span class="op">==</span> <span class="st">"-"</span> <span class="kw">and</span> direction.imag:</span>
<span id="cb54-807"><a href="#cb54-807" aria-hidden="true" tabindex="-1"></a>                positions.append((position <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb54-808"><a href="#cb54-808" aria-hidden="true" tabindex="-1"></a>                direction <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb54-809"><a href="#cb54-809" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> char <span class="op">==</span> <span class="st">"|"</span> <span class="kw">and</span> direction.real:</span>
<span id="cb54-810"><a href="#cb54-810" aria-hidden="true" tabindex="-1"></a>                positions.append((position <span class="op">-</span> <span class="ot">1j</span>, <span class="op">-</span><span class="ot">1j</span>))</span>
<span id="cb54-811"><a href="#cb54-811" aria-hidden="true" tabindex="-1"></a>                direction <span class="op">=</span> <span class="ot">1j</span></span>
<span id="cb54-812"><a href="#cb54-812" aria-hidden="true" tabindex="-1"></a>            position <span class="op">+=</span> direction</span>
<span id="cb54-813"><a href="#cb54-813" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(<span class="bu">set</span>(x[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> seen))</span>
<span id="cb54-814"><a href="#cb54-814" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-815"><a href="#cb54-815" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-816"><a href="#cb54-816" aria-hidden="true" tabindex="-1"></a>count_points(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb54-817"><a href="#cb54-817" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-818"><a href="#cb54-818" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-819"><a href="#cb54-819" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-820"><a href="#cb54-820" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-821"><a href="#cb54-821" aria-hidden="true" tabindex="-1"></a>For part two we could probably do some clever memoization by making the above function recurse on beam splitters.</span>
<span id="cb54-822"><a href="#cb54-822" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-823"><a href="#cb54-823" aria-hidden="true" tabindex="-1"></a>One potential disadvantage of that is that the input might contain infinite loops of light which require global information to be discovered. Passing this information to the memoized function would mean that we almost never get a cache hit, while not passing it risks getting stuck in an infinite loop.</span>
<span id="cb54-824"><a href="#cb54-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-825"><a href="#cb54-825" aria-hidden="true" tabindex="-1"></a>Finally, brute force runs in an acceptable amount of time:</span>
<span id="cb54-826"><a href="#cb54-826" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-829"><a href="#cb54-829" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-830"><a href="#cb54-830" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> starting_position(direction, length):</span>
<span id="cb54-831"><a href="#cb54-831" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">=</span> data.shape[<span class="dv">0</span>] <span class="cf">if</span> (direction.imag <span class="op">+</span> direction.real) <span class="op">&lt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb54-832"><a href="#cb54-832" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">*=</span> <span class="ot">1j</span> <span class="cf">if</span> direction.imag <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb54-833"><a href="#cb54-833" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> offset <span class="op">+</span> (<span class="ot">1j</span> <span class="cf">if</span> direction.real <span class="cf">else</span> <span class="dv">1</span>) <span class="op">*</span> length</span>
<span id="cb54-834"><a href="#cb54-834" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-835"><a href="#cb54-835" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-836"><a href="#cb54-836" aria-hidden="true" tabindex="-1"></a><span class="bu">max</span>(</span>
<span id="cb54-837"><a href="#cb54-837" aria-hidden="true" tabindex="-1"></a>    count_points(starting_position(direction, x), direction)</span>
<span id="cb54-838"><a href="#cb54-838" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(data.shape[<span class="dv">0</span>])</span>
<span id="cb54-839"><a href="#cb54-839" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> direction <span class="kw">in</span> (<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="op">-</span><span class="ot">1j</span>, <span class="ot">1j</span>)</span>
<span id="cb54-840"><a href="#cb54-840" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-841"><a href="#cb54-841" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-842"><a href="#cb54-842" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-843"><a href="#cb54-843" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 17: Clumsy Crucible](https://adventofcode.com/2023/day/17)</span></span>
<span id="cb54-844"><a href="#cb54-844" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-845"><a href="#cb54-845" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-846"><a href="#cb54-846" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-847"><a href="#cb54-847" aria-hidden="true" tabindex="-1"></a>Our first pathfinding task! I couldn't think of a good &amp; simple-to-calculate heuristic, so we'll just go with Dijkstra instead of A<span class="sc">\*</span>.</span>
<span id="cb54-848"><a href="#cb54-848" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-849"><a href="#cb54-849" aria-hidden="true" tabindex="-1"></a>We're given the restriction that a cart must turn after at most three moves. The cost for a move can just be read out from the input grid, so the only question is how we represent a state and what the neighbors of each state are.</span>
<span id="cb54-850"><a href="#cb54-850" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-851"><a href="#cb54-851" aria-hidden="true" tabindex="-1"></a>With the turning restriction, it makes sense to focus on where the cart turns, rather than where it moves. This means that a state can be represented by a tuple of <span class="in">`(y, x, direction)`</span>{.verbatim}, where direction is 0 if the cart is moving vertically after the turn and 1 if it's moving horizontally. The neighbors of a state are then the places where the cart could have its next turn, i.e. the points up to three tiles away vertically or horizontally, with movement along the other axis after the turn.</span>
<span id="cb54-852"><a href="#cb54-852" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-853"><a href="#cb54-853" aria-hidden="true" tabindex="-1"></a>Implementing it looks like this:</span>
<span id="cb54-854"><a href="#cb54-854" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-857"><a href="#cb54-857" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-858"><a href="#cb54-858" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> navigate(grid, minval<span class="op">=</span><span class="dv">1</span>, maxval<span class="op">=</span><span class="dv">3</span>):</span>
<span id="cb54-859"><a href="#cb54-859" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> PriorityQueue()</span>
<span id="cb54-860"><a href="#cb54-860" aria-hidden="true" tabindex="-1"></a>    max_y, max_x <span class="op">=</span> (v <span class="op">-</span> <span class="dv">1</span> <span class="cf">for</span> v <span class="kw">in</span> grid.shape)</span>
<span id="cb54-861"><a href="#cb54-861" aria-hidden="true" tabindex="-1"></a>    goal <span class="op">=</span> max_y, max_x</span>
<span id="cb54-862"><a href="#cb54-862" aria-hidden="true" tabindex="-1"></a>    q.put((<span class="dv">0</span>, (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)))</span>
<span id="cb54-863"><a href="#cb54-863" aria-hidden="true" tabindex="-1"></a>    q.put((<span class="dv">0</span>, (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>)))</span>
<span id="cb54-864"><a href="#cb54-864" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb54-865"><a href="#cb54-865" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-866"><a href="#cb54-866" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb54-867"><a href="#cb54-867" aria-hidden="true" tabindex="-1"></a>        cost, (y, x, direction) <span class="op">=</span> q.get()</span>
<span id="cb54-868"><a href="#cb54-868" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (y, x) <span class="op">==</span> goal:</span>
<span id="cb54-869"><a href="#cb54-869" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb54-870"><a href="#cb54-870" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (y, x, direction) <span class="kw">in</span> seen:</span>
<span id="cb54-871"><a href="#cb54-871" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb54-872"><a href="#cb54-872" aria-hidden="true" tabindex="-1"></a>        seen.add((y, x, direction))</span>
<span id="cb54-873"><a href="#cb54-873" aria-hidden="true" tabindex="-1"></a>        original_cost <span class="op">=</span> cost</span>
<span id="cb54-874"><a href="#cb54-874" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>]:</span>
<span id="cb54-875"><a href="#cb54-875" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">=</span> original_cost</span>
<span id="cb54-876"><a href="#cb54-876" aria-hidden="true" tabindex="-1"></a>            new_y, new_x <span class="op">=</span> y, x</span>
<span id="cb54-877"><a href="#cb54-877" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, maxval <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb54-878"><a href="#cb54-878" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> direction <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb54-879"><a href="#cb54-879" aria-hidden="true" tabindex="-1"></a>                    new_x <span class="op">=</span> x <span class="op">+</span> i <span class="op">*</span> s</span>
<span id="cb54-880"><a href="#cb54-880" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb54-881"><a href="#cb54-881" aria-hidden="true" tabindex="-1"></a>                    new_y <span class="op">=</span> y <span class="op">+</span> i <span class="op">*</span> s</span>
<span id="cb54-882"><a href="#cb54-882" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> new_x <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> new_y <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> new_x <span class="op">&gt;</span> max_x <span class="kw">or</span> new_y <span class="op">&gt;</span> max_y:</span>
<span id="cb54-883"><a href="#cb54-883" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb54-884"><a href="#cb54-884" aria-hidden="true" tabindex="-1"></a>                cost <span class="op">+=</span> grid[new_y, new_x]</span>
<span id="cb54-885"><a href="#cb54-885" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> ((new_y, new_x, <span class="dv">1</span> <span class="op">-</span> direction)) <span class="kw">in</span> seen:</span>
<span id="cb54-886"><a href="#cb54-886" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb54-887"><a href="#cb54-887" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">&gt;=</span> minval:</span>
<span id="cb54-888"><a href="#cb54-888" aria-hidden="true" tabindex="-1"></a>                    q.put((cost, (new_y, new_x, <span class="dv">1</span> <span class="op">-</span> direction)))</span>
<span id="cb54-889"><a href="#cb54-889" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cost</span>
<span id="cb54-890"><a href="#cb54-890" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-891"><a href="#cb54-891" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-892"><a href="#cb54-892" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> np.array([[<span class="bu">int</span>(char) <span class="cf">for</span> char <span class="kw">in</span> line.strip()] <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">17</span>)])</span>
<span id="cb54-893"><a href="#cb54-893" aria-hidden="true" tabindex="-1"></a>navigate(grid)</span>
<span id="cb54-894"><a href="#cb54-894" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-895"><a href="#cb54-895" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-896"><a href="#cb54-896" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-897"><a href="#cb54-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-898"><a href="#cb54-898" aria-hidden="true" tabindex="-1"></a>Part 2 can be incorporated into the above code by changing the maximum number of allowed moves before a turn, and by only allowing turns after the crucible has moved at least <span class="in">`minval`</span>{.verbatim} steps. That's easy to incorporate into the function for part 1, so the code just looks like:</span>
<span id="cb54-899"><a href="#cb54-899" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-902"><a href="#cb54-902" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-903"><a href="#cb54-903" aria-hidden="true" tabindex="-1"></a>navigate(grid, <span class="dv">4</span>, <span class="dv">10</span>)</span>
<span id="cb54-904"><a href="#cb54-904" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-905"><a href="#cb54-905" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-906"><a href="#cb54-906" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 18: Lavaduct Lagoon](https://adventofcode.com/2023/day/18)</span></span>
<span id="cb54-907"><a href="#cb54-907" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-908"><a href="#cb54-908" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-909"><a href="#cb54-909" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-910"><a href="#cb54-910" aria-hidden="true" tabindex="-1"></a>We'll run through the list of instructions and make a list of the coordinates of all the vertices. Then we'll use the shoelace formula to calculate the area of the described polygon. To account for the line of paint at the edge of the polygon, we'll add half the perimeter of the polygon (which corresponds to increasing the total thickness of the polygon by 1 everywhere), and finally add one to correct for the missing paint in the exterior corners. There will always be four more exterior corners than interior corners, since going all the way around the polygon once is a 360 degree rotation.</span>
<span id="cb54-911"><a href="#cb54-911" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-914"><a href="#cb54-914" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-915"><a href="#cb54-915" aria-hidden="true" tabindex="-1"></a>ys, xs <span class="op">=</span> [<span class="dv">0</span>], [<span class="dv">0</span>]</span>
<span id="cb54-916"><a href="#cb54-916" aria-hidden="true" tabindex="-1"></a>position <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb54-917"><a href="#cb54-917" aria-hidden="true" tabindex="-1"></a>directions <span class="op">=</span> {<span class="st">"U"</span>: [<span class="dv">0</span>, <span class="dv">1</span>], <span class="st">"R"</span>: [<span class="dv">1</span>, <span class="dv">0</span>], <span class="st">"D"</span>: [<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>], <span class="st">"L"</span>: [<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>]}</span>
<span id="cb54-918"><a href="#cb54-918" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> direction, count, _ <span class="kw">in</span> <span class="bu">map</span>(<span class="bu">str</span>.split, load(<span class="dv">18</span>)):</span>
<span id="cb54-919"><a href="#cb54-919" aria-hidden="true" tabindex="-1"></a>    position <span class="op">+=</span> np.array(directions[direction]) <span class="op">*</span> (<span class="bu">int</span>(count))</span>
<span id="cb54-920"><a href="#cb54-920" aria-hidden="true" tabindex="-1"></a>    xs.append(position[<span class="dv">0</span>])</span>
<span id="cb54-921"><a href="#cb54-921" aria-hidden="true" tabindex="-1"></a>    ys.append(position[<span class="dv">1</span>])</span>
<span id="cb54-922"><a href="#cb54-922" aria-hidden="true" tabindex="-1"></a><span class="bu">int</span>(</span>
<span id="cb54-923"><a href="#cb54-923" aria-hidden="true" tabindex="-1"></a>    ((xs <span class="op">*</span> (np.roll(ys, <span class="dv">1</span>) <span class="op">-</span> np.roll(ys, <span class="op">-</span><span class="dv">1</span>))).<span class="bu">sum</span>()) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb54-924"><a href="#cb54-924" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> <span class="bu">sum</span>(<span class="bu">abs</span>(np.diff(ys)) <span class="op">+</span> <span class="bu">abs</span>(np.diff(xs))) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb54-925"><a href="#cb54-925" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb54-926"><a href="#cb54-926" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-927"><a href="#cb54-927" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-928"><a href="#cb54-928" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-929"><a href="#cb54-929" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-930"><a href="#cb54-930" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-931"><a href="#cb54-931" aria-hidden="true" tabindex="-1"></a>I was not expecting part 2 to go there! Luckily, nothing changes with respect to what we did above apart from how we build the path around the polygon</span>
<span id="cb54-932"><a href="#cb54-932" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-935"><a href="#cb54-935" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-936"><a href="#cb54-936" aria-hidden="true" tabindex="-1"></a>ys, xs <span class="op">=</span> [<span class="dv">0</span>], [<span class="dv">0</span>]</span>
<span id="cb54-937"><a href="#cb54-937" aria-hidden="true" tabindex="-1"></a>position <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb54-938"><a href="#cb54-938" aria-hidden="true" tabindex="-1"></a>order <span class="op">=</span> <span class="st">"RDLU"</span></span>
<span id="cb54-939"><a href="#cb54-939" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> real_instruction <span class="kw">in</span> <span class="bu">map</span>(<span class="kw">lambda</span> x: x.split()[<span class="op">-</span><span class="dv">1</span>][<span class="dv">2</span>:<span class="op">-</span><span class="dv">1</span>], load(<span class="dv">18</span>)):</span>
<span id="cb54-940"><a href="#cb54-940" aria-hidden="true" tabindex="-1"></a>    count, direction <span class="op">=</span> real_instruction[:<span class="op">-</span><span class="dv">1</span>], real_instruction[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb54-941"><a href="#cb54-941" aria-hidden="true" tabindex="-1"></a>    position <span class="op">+=</span> np.array(directions[order[<span class="bu">int</span>(direction)]]) <span class="op">*</span> <span class="bu">int</span>(count, <span class="dv">16</span>)</span>
<span id="cb54-942"><a href="#cb54-942" aria-hidden="true" tabindex="-1"></a>    xs.append(position[<span class="dv">0</span>])</span>
<span id="cb54-943"><a href="#cb54-943" aria-hidden="true" tabindex="-1"></a>    ys.append(position[<span class="dv">1</span>])</span>
<span id="cb54-944"><a href="#cb54-944" aria-hidden="true" tabindex="-1"></a><span class="bu">int</span>(</span>
<span id="cb54-945"><a href="#cb54-945" aria-hidden="true" tabindex="-1"></a>    ((xs <span class="op">*</span> (np.roll(ys, <span class="dv">1</span>) <span class="op">-</span> np.roll(ys, <span class="op">-</span><span class="dv">1</span>))).<span class="bu">sum</span>()) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb54-946"><a href="#cb54-946" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> <span class="bu">sum</span>(<span class="bu">abs</span>(np.diff(ys)) <span class="op">+</span> <span class="bu">abs</span>(np.diff(xs))) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb54-947"><a href="#cb54-947" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb54-948"><a href="#cb54-948" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-949"><a href="#cb54-949" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-950"><a href="#cb54-950" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-951"><a href="#cb54-951" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 19: Aplenty](https://adventofcode.com/2023/day/19)</span></span>
<span id="cb54-952"><a href="#cb54-952" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-953"><a href="#cb54-953" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-954"><a href="#cb54-954" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-957"><a href="#cb54-957" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-958"><a href="#cb54-958" aria-hidden="true" tabindex="-1"></a>workflows, parts <span class="op">=</span> [x.split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>) <span class="cf">for</span> x <span class="kw">in</span> load(<span class="dv">19</span>, <span class="st">"raw"</span>).split(<span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)]</span>
<span id="cb54-959"><a href="#cb54-959" aria-hidden="true" tabindex="-1"></a>Part <span class="op">=</span> namedtuple(<span class="st">"Part"</span>, <span class="st">"x m a s"</span>)</span>
<span id="cb54-960"><a href="#cb54-960" aria-hidden="true" tabindex="-1"></a>parts <span class="op">=</span> [Part(<span class="op">*</span>[<span class="bu">int</span>(x) <span class="cf">for</span> x <span class="kw">in</span> re.findall(<span class="vs">r"\+?-?\d+"</span>, part)]) <span class="cf">for</span> part <span class="kw">in</span> parts]</span>
<span id="cb54-961"><a href="#cb54-961" aria-hidden="true" tabindex="-1"></a>name, instructions <span class="op">=</span> workflows[<span class="dv">0</span>][:<span class="op">-</span><span class="dv">1</span>].split(<span class="st">"{"</span>)</span>
<span id="cb54-962"><a href="#cb54-962" aria-hidden="true" tabindex="-1"></a>instruction_map <span class="op">=</span> {}</span>
<span id="cb54-963"><a href="#cb54-963" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, instructions <span class="kw">in</span> <span class="bu">map</span>(<span class="kw">lambda</span> x: x[:<span class="op">-</span><span class="dv">1</span>].split(<span class="st">"{"</span>), workflows):</span>
<span id="cb54-964"><a href="#cb54-964" aria-hidden="true" tabindex="-1"></a>    rules <span class="op">=</span> [</span>
<span id="cb54-965"><a href="#cb54-965" aria-hidden="true" tabindex="-1"></a>        rule.split(<span class="st">":"</span>) <span class="cf">if</span> <span class="st">":"</span> <span class="kw">in</span> rule <span class="cf">else</span> [<span class="kw">lambda</span> y: <span class="va">True</span>, rule]</span>
<span id="cb54-966"><a href="#cb54-966" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> rule <span class="kw">in</span> instructions.split(<span class="st">","</span>)</span>
<span id="cb54-967"><a href="#cb54-967" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb54-968"><a href="#cb54-968" aria-hidden="true" tabindex="-1"></a>    rules <span class="op">=</span> [</span>
<span id="cb54-969"><a href="#cb54-969" aria-hidden="true" tabindex="-1"></a>        (<span class="bu">eval</span>(<span class="st">"lambda y: y."</span> <span class="op">+</span> rule[<span class="dv">0</span>]), rule[<span class="dv">1</span>]) <span class="cf">if</span> <span class="bu">isinstance</span>(rule[<span class="dv">0</span>], <span class="bu">str</span>) <span class="cf">else</span> rule</span>
<span id="cb54-970"><a href="#cb54-970" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> rule <span class="kw">in</span> rules</span>
<span id="cb54-971"><a href="#cb54-971" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb54-972"><a href="#cb54-972" aria-hidden="true" tabindex="-1"></a>    instruction_map[name] <span class="op">=</span> instructions, rules</span>
<span id="cb54-973"><a href="#cb54-973" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-974"><a href="#cb54-974" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-975"><a href="#cb54-975" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> follow(part, state):</span>
<span id="cb54-976"><a href="#cb54-976" aria-hidden="true" tabindex="-1"></a>    s, tests <span class="op">=</span> instruction_map[state]</span>
<span id="cb54-977"><a href="#cb54-977" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> test, output <span class="kw">in</span> tests:</span>
<span id="cb54-978"><a href="#cb54-978" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> test(part):</span>
<span id="cb54-979"><a href="#cb54-979" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> output <span class="op">==</span> <span class="st">"A"</span>:</span>
<span id="cb54-980"><a href="#cb54-980" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb54-981"><a href="#cb54-981" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> output <span class="op">==</span> <span class="st">"R"</span>:</span>
<span id="cb54-982"><a href="#cb54-982" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb54-983"><a href="#cb54-983" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> follow(part, output)</span>
<span id="cb54-984"><a href="#cb54-984" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-985"><a href="#cb54-985" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-986"><a href="#cb54-986" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span>(x.x <span class="op">+</span> x.m <span class="op">+</span> x.a <span class="op">+</span> x.s <span class="cf">for</span> x <span class="kw">in</span> parts <span class="cf">if</span> follow(x, <span class="st">"in"</span>))</span>
<span id="cb54-987"><a href="#cb54-987" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-988"><a href="#cb54-988" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-989"><a href="#cb54-989" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-990"><a href="#cb54-990" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-991"><a href="#cb54-991" aria-hidden="true" tabindex="-1"></a>So, I thought I was being clever above by <span class="in">`eval`</span>{.verbatim}'ing the instructions to convert them directly to python functions. Unfortunately we have to modify the above approach to work with ranges of values rather than specific values, which has the effect of converting the filters from pass/faill to ones that split ranges in two - the parts that pass the filter, and the parts that don't. I could go back and rework how I parsed the instructions in part 1 to fit with what I need to do for part 2, or I could just redo the parsing.</span>
<span id="cb54-992"><a href="#cb54-992" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-993"><a href="#cb54-993" aria-hidden="true" tabindex="-1"></a>I'll store each range as a dataclass of tuples, and each filter splits a range into at most two parts. The are half-open on the left, so that x = tuple(0, 5) represents the values <span class="sc">\[</span>1, 2, 3, 4, 5<span class="sc">\]</span>. The fact that they're half-open lets us find the size of a range by just subtracting the endpoints, without having to fiddle with off-by one errors, and I chose to do it on the left so that the inital range can be represented by the pair of numbers (0, 4000) rather than the more ugly (1, 4001).</span>
<span id="cb54-994"><a href="#cb54-994" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-997"><a href="#cb54-997" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-998"><a href="#cb54-998" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclasses.dataclass</span></span>
<span id="cb54-999"><a href="#cb54-999" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PartRange:</span>
<span id="cb54-1000"><a href="#cb54-1000" aria-hidden="true" tabindex="-1"></a>    x: <span class="bu">tuple</span>[<span class="bu">int</span>]</span>
<span id="cb54-1001"><a href="#cb54-1001" aria-hidden="true" tabindex="-1"></a>    m: <span class="bu">tuple</span>[<span class="bu">int</span>]</span>
<span id="cb54-1002"><a href="#cb54-1002" aria-hidden="true" tabindex="-1"></a>    a: <span class="bu">tuple</span>[<span class="bu">int</span>]</span>
<span id="cb54-1003"><a href="#cb54-1003" aria-hidden="true" tabindex="-1"></a>    s: <span class="bu">tuple</span>[<span class="bu">int</span>]</span>
<span id="cb54-1004"><a href="#cb54-1004" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1005"><a href="#cb54-1005" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1006"><a href="#cb54-1006" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_valid(interval):</span>
<span id="cb54-1007"><a href="#cb54-1007" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> interval[<span class="dv">1</span>] <span class="op">&gt;</span> interval[<span class="dv">0</span>]</span>
<span id="cb54-1008"><a href="#cb54-1008" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1009"><a href="#cb54-1009" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1010"><a href="#cb54-1010" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_coords(part_range, coordinate, cutoff, test):</span>
<span id="cb54-1011"><a href="#cb54-1011" aria-hidden="true" tabindex="-1"></a>    coord_range <span class="op">=</span> <span class="bu">getattr</span>(part_range, coordinate)</span>
<span id="cb54-1012"><a href="#cb54-1012" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> test <span class="op">==</span> <span class="st">"&gt;"</span>:</span>
<span id="cb54-1013"><a href="#cb54-1013" aria-hidden="true" tabindex="-1"></a>        new_coords <span class="op">=</span> ((cutoff, coord_range[<span class="dv">1</span>]), (coord_range[<span class="dv">0</span>], cutoff))</span>
<span id="cb54-1014"><a href="#cb54-1014" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> test <span class="op">==</span> <span class="st">"&lt;"</span>:</span>
<span id="cb54-1015"><a href="#cb54-1015" aria-hidden="true" tabindex="-1"></a>        new_coords <span class="op">=</span> ((coord_range[<span class="dv">0</span>], cutoff <span class="op">-</span> <span class="dv">1</span>), (cutoff <span class="op">-</span> <span class="dv">1</span>, coord_range[<span class="dv">1</span>]))</span>
<span id="cb54-1016"><a href="#cb54-1016" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb54-1017"><a href="#cb54-1017" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"This shouldn't be possible"</span>)</span>
<span id="cb54-1018"><a href="#cb54-1018" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb54-1019"><a href="#cb54-1019" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> interval <span class="kw">in</span> new_coords:</span>
<span id="cb54-1020"><a href="#cb54-1020" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> is_valid(interval):</span>
<span id="cb54-1021"><a href="#cb54-1021" aria-hidden="true" tabindex="-1"></a>            result.append(<span class="va">None</span>)</span>
<span id="cb54-1022"><a href="#cb54-1022" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb54-1023"><a href="#cb54-1023" aria-hidden="true" tabindex="-1"></a>            result.append(dataclasses.replace(part_range, <span class="op">**</span>{coordinate: interval}))</span>
<span id="cb54-1024"><a href="#cb54-1024" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb54-1025"><a href="#cb54-1025" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1026"><a href="#cb54-1026" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1027"><a href="#cb54-1027" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> size(part_range):</span>
<span id="cb54-1028"><a href="#cb54-1028" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.product([np.diff(<span class="bu">getattr</span>(part_range, i)) <span class="cf">for</span> i <span class="kw">in</span> <span class="st">"xmas"</span>])</span>
<span id="cb54-1029"><a href="#cb54-1029" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1030"><a href="#cb54-1030" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1031"><a href="#cb54-1031" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_rule_string(rule):</span>
<span id="cb54-1032"><a href="#cb54-1032" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">":"</span> <span class="kw">not</span> <span class="kw">in</span> rule:</span>
<span id="cb54-1033"><a href="#cb54-1033" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rule</span>
<span id="cb54-1034"><a href="#cb54-1034" aria-hidden="true" tabindex="-1"></a>    coordinate <span class="op">=</span> rule[<span class="dv">0</span>]</span>
<span id="cb54-1035"><a href="#cb54-1035" aria-hidden="true" tabindex="-1"></a>    test <span class="op">=</span> rule[<span class="dv">1</span>]</span>
<span id="cb54-1036"><a href="#cb54-1036" aria-hidden="true" tabindex="-1"></a>    cutoff, destination <span class="op">=</span> rule[<span class="dv">2</span>:].split(<span class="st">":"</span>)</span>
<span id="cb54-1037"><a href="#cb54-1037" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> coordinate, <span class="bu">int</span>(cutoff), test, destination</span>
<span id="cb54-1038"><a href="#cb54-1038" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1039"><a href="#cb54-1039" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1040"><a href="#cb54-1040" aria-hidden="true" tabindex="-1"></a>instructions <span class="op">=</span> {}</span>
<span id="cb54-1041"><a href="#cb54-1041" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, rules <span class="kw">in</span> <span class="bu">map</span>(<span class="kw">lambda</span> x: x[:<span class="op">-</span><span class="dv">1</span>].split(<span class="st">"{"</span>), workflows):</span>
<span id="cb54-1042"><a href="#cb54-1042" aria-hidden="true" tabindex="-1"></a>    instructions[name] <span class="op">=</span> [parse_rule_string(rule) <span class="cf">for</span> rule <span class="kw">in</span> rules.split(<span class="st">","</span>)]</span>
<span id="cb54-1043"><a href="#cb54-1043" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1044"><a href="#cb54-1044" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1045"><a href="#cb54-1045" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> follow(instructions):</span>
<span id="cb54-1046"><a href="#cb54-1046" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> inner(part_range, state):</span>
<span id="cb54-1047"><a href="#cb54-1047" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> <span class="st">"R"</span>:</span>
<span id="cb54-1048"><a href="#cb54-1048" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb54-1049"><a href="#cb54-1049" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> <span class="st">"A"</span>:</span>
<span id="cb54-1050"><a href="#cb54-1050" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> size(part_range)</span>
<span id="cb54-1051"><a href="#cb54-1051" aria-hidden="true" tabindex="-1"></a>        rules <span class="op">=</span> instructions[state]</span>
<span id="cb54-1052"><a href="#cb54-1052" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-1053"><a href="#cb54-1053" aria-hidden="true" tabindex="-1"></a>        remainder <span class="op">=</span> part_range</span>
<span id="cb54-1054"><a href="#cb54-1054" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> rule <span class="kw">in</span> rules:</span>
<span id="cb54-1055"><a href="#cb54-1055" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> remainder <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb54-1056"><a href="#cb54-1056" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb54-1057"><a href="#cb54-1057" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(rule, <span class="bu">str</span>):</span>
<span id="cb54-1058"><a href="#cb54-1058" aria-hidden="true" tabindex="-1"></a>                result <span class="op">+=</span> inner(remainder, rule)</span>
<span id="cb54-1059"><a href="#cb54-1059" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb54-1060"><a href="#cb54-1060" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb54-1061"><a href="#cb54-1061" aria-hidden="true" tabindex="-1"></a>                coordinate, cutoff, test, destination <span class="op">=</span> rule</span>
<span id="cb54-1062"><a href="#cb54-1062" aria-hidden="true" tabindex="-1"></a>                passed, remainder <span class="op">=</span> split_coords(remainder, coordinate, cutoff, test)</span>
<span id="cb54-1063"><a href="#cb54-1063" aria-hidden="true" tabindex="-1"></a>                result <span class="op">+=</span> inner(passed, destination) <span class="cf">if</span> passed <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb54-1064"><a href="#cb54-1064" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result</span>
<span id="cb54-1065"><a href="#cb54-1065" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1066"><a href="#cb54-1066" aria-hidden="true" tabindex="-1"></a>    initial <span class="op">=</span> PartRange((<span class="dv">0</span>, <span class="dv">4000</span>), (<span class="dv">0</span>, <span class="dv">4000</span>), (<span class="dv">0</span>, <span class="dv">4000</span>), (<span class="dv">0</span>, <span class="dv">4000</span>))</span>
<span id="cb54-1067"><a href="#cb54-1067" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> inner(initial, <span class="st">"in"</span>)</span>
<span id="cb54-1068"><a href="#cb54-1068" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1069"><a href="#cb54-1069" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1070"><a href="#cb54-1070" aria-hidden="true" tabindex="-1"></a>follow(instructions)</span>
<span id="cb54-1071"><a href="#cb54-1071" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-1072"><a href="#cb54-1072" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1073"><a href="#cb54-1073" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 20: Pulse Propagation](https://adventofcode.com/2023/day/20)</span></span>
<span id="cb54-1074"><a href="#cb54-1074" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1077"><a href="#cb54-1077" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1078"><a href="#cb54-1078" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">20</span>)</span>
<span id="cb54-1079"><a href="#cb54-1079" aria-hidden="true" tabindex="-1"></a>bus <span class="op">=</span> []</span>
<span id="cb54-1080"><a href="#cb54-1080" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1081"><a href="#cb54-1081" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1082"><a href="#cb54-1082" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Module:</span>
<span id="cb54-1083"><a href="#cb54-1083" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, destinations):</span>
<span id="cb54-1084"><a href="#cb54-1084" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> name</span>
<span id="cb54-1085"><a href="#cb54-1085" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.destinations <span class="op">=</span> destinations</span>
<span id="cb54-1086"><a href="#cb54-1086" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1087"><a href="#cb54-1087" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> send(<span class="va">self</span>):</span>
<span id="cb54-1088"><a href="#cb54-1088" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> destination <span class="kw">in</span> <span class="va">self</span>.destinations:</span>
<span id="cb54-1089"><a href="#cb54-1089" aria-hidden="true" tabindex="-1"></a>            bus.append((<span class="va">self</span>.name, destination, <span class="va">self</span>.state))</span>
<span id="cb54-1090"><a href="#cb54-1090" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1091"><a href="#cb54-1091" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> instantiate_destinations(<span class="va">self</span>):</span>
<span id="cb54-1092"><a href="#cb54-1092" aria-hidden="true" tabindex="-1"></a>        destinations <span class="op">=</span> []</span>
<span id="cb54-1093"><a href="#cb54-1093" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dest <span class="kw">in</span> <span class="va">self</span>.destinations:</span>
<span id="cb54-1094"><a href="#cb54-1094" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(dest, <span class="bu">str</span>):</span>
<span id="cb54-1095"><a href="#cb54-1095" aria-hidden="true" tabindex="-1"></a>                <span class="cf">try</span>:</span>
<span id="cb54-1096"><a href="#cb54-1096" aria-hidden="true" tabindex="-1"></a>                    dest <span class="op">=</span> modules[dest]</span>
<span id="cb54-1097"><a href="#cb54-1097" aria-hidden="true" tabindex="-1"></a>                <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb54-1098"><a href="#cb54-1098" aria-hidden="true" tabindex="-1"></a>                    dest <span class="op">=</span> Module(dest, [])</span>
<span id="cb54-1099"><a href="#cb54-1099" aria-hidden="true" tabindex="-1"></a>            destinations.append(dest)</span>
<span id="cb54-1100"><a href="#cb54-1100" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.destinations <span class="op">=</span> destinations</span>
<span id="cb54-1101"><a href="#cb54-1101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1102"><a href="#cb54-1102" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recv(<span class="va">self</span>, source, signal):</span>
<span id="cb54-1103"><a href="#cb54-1103" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb54-1104"><a href="#cb54-1104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1105"><a href="#cb54-1105" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reset(<span class="va">self</span>):</span>
<span id="cb54-1106"><a href="#cb54-1106" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb54-1107"><a href="#cb54-1107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1108"><a href="#cb54-1108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1109"><a href="#cb54-1109" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FlipFlop(Module):</span>
<span id="cb54-1110"><a href="#cb54-1110" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, destinations):</span>
<span id="cb54-1111"><a href="#cb54-1111" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(name, destinations)</span>
<span id="cb54-1112"><a href="#cb54-1112" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.state <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-1113"><a href="#cb54-1113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1114"><a href="#cb54-1114" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recv(<span class="va">self</span>, source, signal):</span>
<span id="cb54-1115"><a href="#cb54-1115" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> signal <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb54-1116"><a href="#cb54-1116" aria-hidden="true" tabindex="-1"></a>            <span class="cf">pass</span></span>
<span id="cb54-1117"><a href="#cb54-1117" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb54-1118"><a href="#cb54-1118" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.state <span class="op">^=</span> <span class="dv">1</span></span>
<span id="cb54-1119"><a href="#cb54-1119" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.send()</span>
<span id="cb54-1120"><a href="#cb54-1120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1121"><a href="#cb54-1121" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reset(<span class="va">self</span>):</span>
<span id="cb54-1122"><a href="#cb54-1122" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.state <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-1123"><a href="#cb54-1123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1124"><a href="#cb54-1124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1125"><a href="#cb54-1125" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Conjunction(Module):</span>
<span id="cb54-1126"><a href="#cb54-1126" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, destinations, sources):</span>
<span id="cb54-1127"><a href="#cb54-1127" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(name, destinations)</span>
<span id="cb54-1128"><a href="#cb54-1128" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.signals <span class="op">=</span> {x: <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> sources}</span>
<span id="cb54-1129"><a href="#cb54-1129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1130"><a href="#cb54-1130" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb54-1131"><a href="#cb54-1131" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> state(<span class="va">self</span>):</span>
<span id="cb54-1132"><a href="#cb54-1132" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">int</span>(<span class="kw">not</span> <span class="bu">all</span>(<span class="va">self</span>.signals.values()))</span>
<span id="cb54-1133"><a href="#cb54-1133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1134"><a href="#cb54-1134" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recv(<span class="va">self</span>, source, signal):</span>
<span id="cb54-1135"><a href="#cb54-1135" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.signals[source] <span class="op">=</span> signal</span>
<span id="cb54-1136"><a href="#cb54-1136" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.send()</span>
<span id="cb54-1137"><a href="#cb54-1137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1138"><a href="#cb54-1138" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reset(<span class="va">self</span>):</span>
<span id="cb54-1139"><a href="#cb54-1139" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.signals <span class="op">=</span> {x: <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.signals}</span>
<span id="cb54-1140"><a href="#cb54-1140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1141"><a href="#cb54-1141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1142"><a href="#cb54-1142" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Broadcaster(Module):</span>
<span id="cb54-1143"><a href="#cb54-1143" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recv(<span class="va">self</span>, source, signal):</span>
<span id="cb54-1144"><a href="#cb54-1144" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.state <span class="op">=</span> signal</span>
<span id="cb54-1145"><a href="#cb54-1145" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.send()</span>
<span id="cb54-1146"><a href="#cb54-1146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1147"><a href="#cb54-1147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1148"><a href="#cb54-1148" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> strip_prefix(name):</span>
<span id="cb54-1149"><a href="#cb54-1149" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> name[<span class="dv">1</span>:] <span class="cf">if</span> name[<span class="dv">0</span>] <span class="kw">in</span> <span class="st">"%&amp;"</span> <span class="cf">else</span> name</span>
<span id="cb54-1150"><a href="#cb54-1150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1151"><a href="#cb54-1151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1152"><a href="#cb54-1152" aria-hidden="true" tabindex="-1"></a>network <span class="op">=</span> {}</span>
<span id="cb54-1153"><a href="#cb54-1153" aria-hidden="true" tabindex="-1"></a>modules <span class="op">=</span> {}</span>
<span id="cb54-1154"><a href="#cb54-1154" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> source, destinations <span class="kw">in</span> <span class="bu">map</span>(<span class="kw">lambda</span> x: x.split(<span class="st">" -&gt; "</span>), data):</span>
<span id="cb54-1155"><a href="#cb54-1155" aria-hidden="true" tabindex="-1"></a>    network[source] <span class="op">=</span> destinations.split(<span class="st">", "</span>)</span>
<span id="cb54-1156"><a href="#cb54-1156" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key <span class="kw">in</span> network.keys():</span>
<span id="cb54-1157"><a href="#cb54-1157" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> key[<span class="dv">0</span>] <span class="op">==</span> <span class="st">"%"</span>:</span>
<span id="cb54-1158"><a href="#cb54-1158" aria-hidden="true" tabindex="-1"></a>        modules[key[<span class="dv">1</span>:]] <span class="op">=</span> FlipFlop(key[<span class="dv">1</span>:], network[key])</span>
<span id="cb54-1159"><a href="#cb54-1159" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> key[<span class="dv">0</span>] <span class="op">==</span> <span class="st">"&amp;"</span>:</span>
<span id="cb54-1160"><a href="#cb54-1160" aria-hidden="true" tabindex="-1"></a>        sources <span class="op">=</span> [strip_prefix(k) <span class="cf">for</span> k <span class="kw">in</span> network <span class="cf">if</span> key[<span class="dv">1</span>:] <span class="kw">in</span> network[k]]</span>
<span id="cb54-1161"><a href="#cb54-1161" aria-hidden="true" tabindex="-1"></a>        modules[key[<span class="dv">1</span>:]] <span class="op">=</span> Conjunction(key[<span class="dv">1</span>:], network[key], sources)</span>
<span id="cb54-1162"><a href="#cb54-1162" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> key <span class="op">==</span> <span class="st">"broadcaster"</span>:</span>
<span id="cb54-1163"><a href="#cb54-1163" aria-hidden="true" tabindex="-1"></a>        modules[key] <span class="op">=</span> Broadcaster(key, network[key])</span>
<span id="cb54-1164"><a href="#cb54-1164" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key <span class="kw">in</span> modules:</span>
<span id="cb54-1165"><a href="#cb54-1165" aria-hidden="true" tabindex="-1"></a>    modules[key].instantiate_destinations()</span>
<span id="cb54-1166"><a href="#cb54-1166" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-1167"><a href="#cb54-1167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1170"><a href="#cb54-1170" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1171"><a href="#cb54-1171" aria-hidden="true" tabindex="-1"></a>counts <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb54-1172"><a href="#cb54-1172" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1000</span>):</span>
<span id="cb54-1173"><a href="#cb54-1173" aria-hidden="true" tabindex="-1"></a>    bus <span class="op">=</span> [(<span class="st">"button"</span>, modules[<span class="st">"broadcaster"</span>], <span class="dv">0</span>)]</span>
<span id="cb54-1174"><a href="#cb54-1174" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> bus:</span>
<span id="cb54-1175"><a href="#cb54-1175" aria-hidden="true" tabindex="-1"></a>        source, destination, signal <span class="op">=</span> bus.pop(<span class="dv">0</span>)</span>
<span id="cb54-1176"><a href="#cb54-1176" aria-hidden="true" tabindex="-1"></a>        counts[signal] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb54-1177"><a href="#cb54-1177" aria-hidden="true" tabindex="-1"></a>        destination.recv(source, signal)</span>
<span id="cb54-1178"><a href="#cb54-1178" aria-hidden="true" tabindex="-1"></a>counts[<span class="dv">0</span>] <span class="op">*</span> counts[<span class="dv">1</span>]</span>
<span id="cb54-1179"><a href="#cb54-1179" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-1180"><a href="#cb54-1180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1181"><a href="#cb54-1181" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2</span></span>
<span id="cb54-1182"><a href="#cb54-1182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1185"><a href="#cb54-1185" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1186"><a href="#cb54-1186" aria-hidden="true" tabindex="-1"></a><span class="co"># for module in modules:</span></span>
<span id="cb54-1187"><a href="#cb54-1187" aria-hidden="true" tabindex="-1"></a><span class="co">#     modules[module].reset()</span></span>
<span id="cb54-1188"><a href="#cb54-1188" aria-hidden="true" tabindex="-1"></a>bus <span class="op">=</span> [(<span class="st">"button"</span>, modules[<span class="st">"broadcaster"</span>], <span class="dv">0</span>)]</span>
<span id="cb54-1189"><a href="#cb54-1189" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> bus:</span>
<span id="cb54-1190"><a href="#cb54-1190" aria-hidden="true" tabindex="-1"></a>    source, destination, signal <span class="op">=</span> bus.pop(<span class="dv">0</span>)</span>
<span id="cb54-1191"><a href="#cb54-1191" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(</span>
<span id="cb54-1192"><a href="#cb54-1192" aria-hidden="true" tabindex="-1"></a>        source,</span>
<span id="cb54-1193"><a href="#cb54-1193" aria-hidden="true" tabindex="-1"></a>        destination.name,</span>
<span id="cb54-1194"><a href="#cb54-1194" aria-hidden="true" tabindex="-1"></a>        signal,</span>
<span id="cb54-1195"><a href="#cb54-1195" aria-hidden="true" tabindex="-1"></a>        <span class="st">"conjunction"</span> <span class="cf">if</span> <span class="bu">hasattr</span>(destination, <span class="st">"signals"</span>) <span class="cf">else</span> <span class="st">"flipflop"</span>,</span>
<span id="cb54-1196"><a href="#cb54-1196" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb54-1197"><a href="#cb54-1197" aria-hidden="true" tabindex="-1"></a>    destination.recv(source, signal)</span>
<span id="cb54-1198"><a href="#cb54-1198" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-1199"><a href="#cb54-1199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1202"><a href="#cb54-1202" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1203"><a href="#cb54-1203" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb54-1204"><a href="#cb54-1204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1205"><a href="#cb54-1205" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.from_dict_of_lists(</span>
<span id="cb54-1206"><a href="#cb54-1206" aria-hidden="true" tabindex="-1"></a>    {strip_prefix(k): v <span class="cf">for</span> k, v <span class="kw">in</span> network.items()}, create_using<span class="op">=</span>nx.DiGraph</span>
<span id="cb54-1207"><a href="#cb54-1207" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-1208"><a href="#cb54-1208" aria-hidden="true" tabindex="-1"></a>nodes, prefices <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>([(strip_prefix(k), k[<span class="dv">0</span>]) <span class="cf">for</span> k <span class="kw">in</span> network] <span class="op">+</span> [(<span class="st">"rx"</span>, <span class="st">"d"</span>)]))</span>
<span id="cb54-1209"><a href="#cb54-1209" aria-hidden="true" tabindex="-1"></a>colormap <span class="op">=</span> {<span class="st">"%"</span>: <span class="st">"#1f77b4"</span>, <span class="st">"&amp;"</span>: <span class="st">"#ff7f0e"</span>, <span class="st">"b"</span>: <span class="st">"#2ca02c"</span>, <span class="st">"d"</span>: <span class="st">"#d62728"</span>}</span>
<span id="cb54-1210"><a href="#cb54-1210" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [colormap[prefix] <span class="cf">for</span> prefix <span class="kw">in</span> prefices]</span>
<span id="cb54-1211"><a href="#cb54-1211" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(</span>
<span id="cb54-1212"><a href="#cb54-1212" aria-hidden="true" tabindex="-1"></a>    G, nodelist<span class="op">=</span>nodes, node_color<span class="op">=</span>colors, arrows<span class="op">=</span><span class="va">True</span>, pos<span class="op">=</span>nx.bfs_layout(G)</span>
<span id="cb54-1213"><a href="#cb54-1213" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-1214"><a href="#cb54-1214" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb54-1215"><a href="#cb54-1215" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"off"</span>)</span>
<span id="cb54-1216"><a href="#cb54-1216" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-1217"><a href="#cb54-1217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1220"><a href="#cb54-1220" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1221"><a href="#cb54-1221" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb54-1222"><a href="#cb54-1222" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> plt.cm.tab10.colors: <span class="bu">print</span>(matplotlib.colors.to_hex(c))</span>
<span id="cb54-1223"><a href="#cb54-1223" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-1224"><a href="#cb54-1224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1225"><a href="#cb54-1225" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 21: Step Counter](https://adventofcode.com/2023/day/21)</span></span>
<span id="cb54-1226"><a href="#cb54-1226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1227"><a href="#cb54-1227" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-1228"><a href="#cb54-1228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1231"><a href="#cb54-1231" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1232"><a href="#cb54-1232" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.array([<span class="bu">list</span>(line) <span class="cf">for</span> line <span class="kw">in</span> load(<span class="dv">21</span>)])</span>
<span id="cb54-1233"><a href="#cb54-1233" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.pad(data, <span class="dv">1</span>, constant_values<span class="op">=</span><span class="st">"#"</span>)</span>
<span id="cb54-1234"><a href="#cb54-1234" aria-hidden="true" tabindex="-1"></a>y, x <span class="op">=</span> [x[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> np.where(data <span class="op">==</span> <span class="st">"S"</span>)]</span>
<span id="cb54-1235"><a href="#cb54-1235" aria-hidden="true" tabindex="-1"></a>data[y, x] <span class="op">=</span> <span class="st">"."</span></span>
<span id="cb54-1236"><a href="#cb54-1236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1237"><a href="#cb54-1237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1238"><a href="#cb54-1238" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> step(positions):</span>
<span id="cb54-1239"><a href="#cb54-1239" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb54-1240"><a href="#cb54-1240" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y, x <span class="kw">in</span> positions:</span>
<span id="cb54-1241"><a href="#cb54-1241" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dy <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>]:</span>
<span id="cb54-1242"><a href="#cb54-1242" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> data[y <span class="op">+</span> dy, x] <span class="op">==</span> <span class="st">"."</span>:</span>
<span id="cb54-1243"><a href="#cb54-1243" aria-hidden="true" tabindex="-1"></a>                result.add((y <span class="op">+</span> dy, x))</span>
<span id="cb54-1244"><a href="#cb54-1244" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dx <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>]:</span>
<span id="cb54-1245"><a href="#cb54-1245" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> data[y, x <span class="op">+</span> dx] <span class="op">==</span> <span class="st">"."</span>:</span>
<span id="cb54-1246"><a href="#cb54-1246" aria-hidden="true" tabindex="-1"></a>                result.add((y, x <span class="op">+</span> dx))</span>
<span id="cb54-1247"><a href="#cb54-1247" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb54-1248"><a href="#cb54-1248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1249"><a href="#cb54-1249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1250"><a href="#cb54-1250" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> [(y, x)]</span>
<span id="cb54-1251"><a href="#cb54-1251" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">64</span>):</span>
<span id="cb54-1252"><a href="#cb54-1252" aria-hidden="true" tabindex="-1"></a>    positions <span class="op">=</span> step(positions)</span>
<span id="cb54-1253"><a href="#cb54-1253" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(positions)</span>
<span id="cb54-1254"><a href="#cb54-1254" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-1255"><a href="#cb54-1255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1256"><a href="#cb54-1256" aria-hidden="true" tabindex="-1"></a><span class="fu"># [Day 25: Snowverload](https://adventofcode.com/2023/day/25)</span></span>
<span id="cb54-1257"><a href="#cb54-1257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1258"><a href="#cb54-1258" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1</span></span>
<span id="cb54-1259"><a href="#cb54-1259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1260"><a href="#cb54-1260" aria-hidden="true" tabindex="-1"></a>This one stumped me for way too long. Or rather, finding a computational solution to it did. The first thing I tried to do to get a handle on what the problem was about was to plot the graph. And when I did that, it was immediately clear which three edges should be cut, and the problem was solved. That's a perfectely reasonable solution plan – nowhere in the rules of AOC does it say that you have to run an algorithm on a computer to find the answer – but it felt a little unsatisfying.</span>
<span id="cb54-1261"><a href="#cb54-1261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1262"><a href="#cb54-1262" aria-hidden="true" tabindex="-1"></a>So down into the rabbit hole we go.</span>
<span id="cb54-1263"><a href="#cb54-1263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1264"><a href="#cb54-1264" aria-hidden="true" tabindex="-1"></a>The first thing I did was to load the data, and calculate the adjacency matrix of the graph</span>
<span id="cb54-1265"><a href="#cb54-1265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1268"><a href="#cb54-1268" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1269"><a href="#cb54-1269" aria-hidden="true" tabindex="-1"></a><span class="co"># | eval: true</span></span>
<span id="cb54-1270"><a href="#cb54-1270" aria-hidden="true" tabindex="-1"></a><span class="co"># | output: false</span></span>
<span id="cb54-1271"><a href="#cb54-1271" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> load(<span class="dv">25</span>)</span>
<span id="cb54-1272"><a href="#cb54-1272" aria-hidden="true" tabindex="-1"></a>network <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb54-1273"><a href="#cb54-1273" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> line <span class="kw">in</span> data:</span>
<span id="cb54-1274"><a href="#cb54-1274" aria-hidden="true" tabindex="-1"></a>    key, values <span class="op">=</span> line.split(<span class="st">":"</span>)</span>
<span id="cb54-1275"><a href="#cb54-1275" aria-hidden="true" tabindex="-1"></a>    values <span class="op">=</span> values.split()</span>
<span id="cb54-1276"><a href="#cb54-1276" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> value <span class="kw">in</span> values:</span>
<span id="cb54-1277"><a href="#cb54-1277" aria-hidden="true" tabindex="-1"></a>        network[key].append(value)</span>
<span id="cb54-1278"><a href="#cb54-1278" aria-hidden="true" tabindex="-1"></a>        network[value].append(key)</span>
<span id="cb54-1279"><a href="#cb54-1279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1280"><a href="#cb54-1280" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> <span class="bu">list</span>(network.keys())</span>
<span id="cb54-1281"><a href="#cb54-1281" aria-hidden="true" tabindex="-1"></a>adjacency_matrix <span class="op">=</span> np.zeros((<span class="bu">len</span>(nodes), <span class="bu">len</span>(nodes)), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb54-1282"><a href="#cb54-1282" aria-hidden="true" tabindex="-1"></a>node_numbers <span class="op">=</span> {k : v <span class="cf">for</span> v, k <span class="kw">in</span> <span class="bu">enumerate</span>(nodes)}</span>
<span id="cb54-1283"><a href="#cb54-1283" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> nodes:</span>
<span id="cb54-1284"><a href="#cb54-1284" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> neighbor <span class="kw">in</span> network[node]:</span>
<span id="cb54-1285"><a href="#cb54-1285" aria-hidden="true" tabindex="-1"></a>        adjacency_matrix[node_numbers[node], node_numbers[neighbor]] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb54-1286"><a href="#cb54-1286" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.from_dict_of_lists(network)</span>
<span id="cb54-1287"><a href="#cb54-1287" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb54-1288"><a href="#cb54-1288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1289"><a href="#cb54-1289" aria-hidden="true" tabindex="-1"></a>I know enough about graph theory to know that what the problem is asking for is the min-cut of the graph, and I even remembered that there are a bunch of standard approaches to solving this problem. I've never implemented any of them myself. The <span class="in">`networkx`</span> library implements the Stoer Wagner algorithm for doing this, so that might be a good place to start – if only to see how long I can expect things to actually take.</span>
<span id="cb54-1290"><a href="#cb54-1290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1291"><a href="#cb54-1291" aria-hidden="true" tabindex="-1"></a>If I let myself use the library, the problem is as simple as</span>
<span id="cb54-1292"><a href="#cb54-1292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1295"><a href="#cb54-1295" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1296"><a href="#cb54-1296" aria-hidden="true" tabindex="-1"></a>value, partition <span class="op">=</span> nx.stoer_wagner(G)</span>
<span id="cb54-1297"><a href="#cb54-1297" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(partition[<span class="dv">0</span>] <span class="op">*</span> <span class="bu">len</span>(partition[<span class="dv">1</span>])</span>
<span id="cb54-1298"><a href="#cb54-1298" aria-hidden="true" tabindex="-1"></a>```</span>
<span id="cb54-1299"><a href="#cb54-1299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1300"><a href="#cb54-1300" aria-hidden="true" tabindex="-1"></a>Note that this takes <span class="dv">15</span><span class="er">s</span> on my old laptop. So I don<span class="st">'t have high hopes that my implementation is going to run in any reasonable amount of time!</span></span>
<span id="cb54-1301"><a href="#cb54-1301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1302"><a href="#cb54-1302" aria-hidden="true" tabindex="-1"></a><span class="er">I can look at the </span>[wikipedia page](https:<span class="op">//</span>en.wikipedia.org<span class="op">/</span>wiki<span class="op">/</span>Stoer<span class="op">%</span>E2<span class="op">%</span><span class="dv">80</span><span class="op">%</span><span class="dv">93</span><span class="er">Wagner_algorithm</span>) <span class="cf">for</span> the algorithm, <span class="kw">and</span> read the original paper, <span class="kw">and</span> the algorithm itself <span class="kw">is</span> <span class="im">as</span> straightforward <span class="im">as</span></span>
<span id="cb54-1303"><a href="#cb54-1303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1306"><a href="#cb54-1306" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1307"><a href="#cb54-1307" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_indices(indices: <span class="bu">list</span>[<span class="bu">int</span>] <span class="op">|</span> <span class="bu">int</span>, a):</span>
<span id="cb54-1308"><a href="#cb54-1308" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(indices, <span class="bu">list</span>):</span>
<span id="cb54-1309"><a href="#cb54-1309" aria-hidden="true" tabindex="-1"></a>        indices <span class="op">=</span> [<span class="dv">0</span>, indices]</span>
<span id="cb54-1310"><a href="#cb54-1310" aria-hidden="true" tabindex="-1"></a>    smallest_index <span class="op">=</span> <span class="bu">min</span>(indices)</span>
<span id="cb54-1311"><a href="#cb54-1311" aria-hidden="true" tabindex="-1"></a>    good_indices <span class="op">=</span> np.setdiff1d(<span class="bu">range</span>(<span class="bu">len</span>(a)), indices)</span>
<span id="cb54-1312"><a href="#cb54-1312" aria-hidden="true" tabindex="-1"></a>    good_mask <span class="op">=</span> np.ix_(good_indices, good_indices)</span>
<span id="cb54-1313"><a href="#cb54-1313" aria-hidden="true" tabindex="-1"></a>    bad_mask <span class="op">=</span> np.ix_(indices, good_indices)</span>
<span id="cb54-1314"><a href="#cb54-1314" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> a[bad_mask].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb54-1315"><a href="#cb54-1315" aria-hidden="true" tabindex="-1"></a>    new_a <span class="op">=</span> a[good_mask].copy()</span>
<span id="cb54-1316"><a href="#cb54-1316" aria-hidden="true" tabindex="-1"></a>    new_a <span class="op">=</span> np.insert(new_a, smallest_index, row, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb54-1317"><a href="#cb54-1317" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> np.insert(row, <span class="bu">min</span>(indices), <span class="dv">0</span>)</span>
<span id="cb54-1318"><a href="#cb54-1318" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.insert(new_a, smallest_index, row, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb54-1319"><a href="#cb54-1319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1320"><a href="#cb54-1320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1321"><a href="#cb54-1321" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimum_cut_phase(adjacency_matrix, node_labels):</span>
<span id="cb54-1322"><a href="#cb54-1322" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">len</span>(node_labels) <span class="op">==</span> <span class="bu">len</span>(adjacency_matrix)</span>
<span id="cb54-1323"><a href="#cb54-1323" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> node_labels.copy()</span>
<span id="cb54-1324"><a href="#cb54-1324" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(adjacency_matrix) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb54-1325"><a href="#cb54-1325" aria-hidden="true" tabindex="-1"></a>        cut_value <span class="op">=</span> adjacency_matrix[<span class="dv">1</span>, <span class="dv">0</span>]</span>
<span id="cb54-1326"><a href="#cb54-1326" aria-hidden="true" tabindex="-1"></a>        node_index <span class="op">=</span> adjacency_matrix[<span class="dv">0</span>].argmax()</span>
<span id="cb54-1327"><a href="#cb54-1327" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb54-1328"><a href="#cb54-1328" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> labels.pop(node_index)</span>
<span id="cb54-1329"><a href="#cb54-1329" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span>:</span>
<span id="cb54-1330"><a href="#cb54-1330" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(labels, adjacency_matrix)</span>
<span id="cb54-1331"><a href="#cb54-1331" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span></span>
<span id="cb54-1332"><a href="#cb54-1332" aria-hidden="true" tabindex="-1"></a>        adjacency_matrix <span class="op">=</span> merge_indices(node_index, adjacency_matrix)</span>
<span id="cb54-1333"><a href="#cb54-1333" aria-hidden="true" tabindex="-1"></a>    node_index <span class="op">=</span> adjacency_matrix[<span class="op">-</span><span class="dv">1</span>].argmax()</span>
<span id="cb54-1334"><a href="#cb54-1334" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> labels.pop(node_index)</span>
<span id="cb54-1335"><a href="#cb54-1335" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s, t, cut_value</span>
<span id="cb54-1336"><a href="#cb54-1336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1337"><a href="#cb54-1337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1338"><a href="#cb54-1338" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimum_cut(adjacency_matrix, node_labels, target<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb54-1339"><a href="#cb54-1339" aria-hidden="true" tabindex="-1"></a>    min_cut_weight <span class="op">=</span> np.inf</span>
<span id="cb54-1340"><a href="#cb54-1340" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(adjacency_matrix) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb54-1341"><a href="#cb54-1341" aria-hidden="true" tabindex="-1"></a>        s, t, cut_weight <span class="op">=</span> minimum_cut_phase(adjacency_matrix, node_labels)</span>
<span id="cb54-1342"><a href="#cb54-1342" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cut_weight <span class="op">&lt;</span> min_cut_weight:</span>
<span id="cb54-1343"><a href="#cb54-1343" aria-hidden="true" tabindex="-1"></a>            min_cut_weight <span class="op">=</span> cut_weight</span>
<span id="cb54-1344"><a href="#cb54-1344" aria-hidden="true" tabindex="-1"></a>            min_cut <span class="op">=</span> s</span>
<span id="cb54-1345"><a href="#cb54-1345" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> min_cut_weight <span class="op">&lt;=</span> target:</span>
<span id="cb54-1346"><a href="#cb54-1346" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb54-1347"><a href="#cb54-1347" aria-hidden="true" tabindex="-1"></a>        new_label <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>s<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>t<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb54-1348"><a href="#cb54-1348" aria-hidden="true" tabindex="-1"></a>        s_idx <span class="op">=</span> node_labels.index(s)</span>
<span id="cb54-1349"><a href="#cb54-1349" aria-hidden="true" tabindex="-1"></a>        t_idx <span class="op">=</span> node_labels.index(t)</span>
<span id="cb54-1350"><a href="#cb54-1350" aria-hidden="true" tabindex="-1"></a>        first, second <span class="op">=</span> <span class="bu">sorted</span>([s_idx, t_idx])</span>
<span id="cb54-1351"><a href="#cb54-1351" aria-hidden="true" tabindex="-1"></a>        node_labels[first] <span class="op">=</span> new_label</span>
<span id="cb54-1352"><a href="#cb54-1352" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> node_labels[second]</span>
<span id="cb54-1353"><a href="#cb54-1353" aria-hidden="true" tabindex="-1"></a>        adjacency_matrix <span class="op">=</span> merge_indices([first, second], adjacency_matrix)</span>
<span id="cb54-1354"><a href="#cb54-1354" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min_cut_weight, min_cut</span>
<span id="cb54-1355"><a href="#cb54-1355" aria-hidden="true" tabindex="-1"></a>```</span>
<span id="cb54-1356"><a href="#cb54-1356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1357"><a href="#cb54-1357" aria-hidden="true" tabindex="-1"></a>Unfortunately, this runs much too slowly to be of <span class="bu">any</span> use at <span class="bu">all</span>. That<span class="st">'s probably because I should be using a heap to store the closest neighbors to my active set. I'</span>m fairly sure the implementation <span class="kw">is</span> correct<span class="op">;</span> based on the various tests I<span class="st">'ve done with smaller graphs. Since that was my main goal with this implementation, I'</span>m <span class="kw">not</span> going optimize it.</span>
<span id="cb54-1358"><a href="#cb54-1358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1359"><a href="#cb54-1359" aria-hidden="true" tabindex="-1"></a>Another approach <span class="kw">is</span> to just pick edges at random <span class="kw">and</span> merge the nodes connecting them, <span class="kw">and</span> keep going until there are only two nodes left – this represents a cut <span class="kw">in</span> the original graph. The idea <span class="kw">is</span> that there are many more edges that are <span class="kw">not</span> part of a minimum cut than there are edges which are, so the chances of selecting a bad edge <span class="kw">is</span> low. You run this algorithm a bunch of times <span class="kw">and</span> pick the partition that leads to the lowest cut weight.</span>
<span id="cb54-1360"><a href="#cb54-1360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1363"><a href="#cb54-1363" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1364"><a href="#cb54-1364" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pick_edge(adjacency_matrix, rng<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb54-1365"><a href="#cb54-1365" aria-hidden="true" tabindex="-1"></a>    <span class="st">"""</span></span>
<span id="cb54-1366"><a href="#cb54-1366" aria-hidden="true" tabindex="-1"></a><span class="st">    Pick an edge uniformly at random from an adjacency matrix representation of a graph.</span></span>
<span id="cb54-1367"><a href="#cb54-1367" aria-hidden="true" tabindex="-1"></a><span class="st">    """</span></span>
<span id="cb54-1368"><a href="#cb54-1368" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rng <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb54-1369"><a href="#cb54-1369" aria-hidden="true" tabindex="-1"></a>        rng <span class="op">=</span> np.random.default_rng()</span>
<span id="cb54-1370"><a href="#cb54-1370" aria-hidden="true" tabindex="-1"></a>    n_edges <span class="op">=</span> (adjacency_matrix <span class="op">&gt;</span> <span class="dv">0</span>).<span class="bu">sum</span>()</span>
<span id="cb54-1371"><a href="#cb54-1371" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> rng.integers(n_edges)</span>
<span id="cb54-1372"><a href="#cb54-1372" aria-hidden="true" tabindex="-1"></a>    totals <span class="op">=</span> (adjacency_matrix <span class="op">&gt;</span> <span class="dv">0</span>).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>).cumsum()</span>
<span id="cb54-1373"><a href="#cb54-1373" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> (totals <span class="op">&gt;</span> idx).argmax()</span>
<span id="cb54-1374"><a href="#cb54-1374" aria-hidden="true" tabindex="-1"></a>    previous <span class="op">=</span> totals[row <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> row <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb54-1375"><a href="#cb54-1375" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>([row, np.where(adjacency_matrix[row])[<span class="dv">0</span>][idx <span class="op">-</span> previous]])</span>
<span id="cb54-1376"><a href="#cb54-1376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1377"><a href="#cb54-1377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1378"><a href="#cb54-1378" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng()</span>
<span id="cb54-1379"><a href="#cb54-1379" aria-hidden="true" tabindex="-1"></a>pick_edge(adjacency_matrix, rng)</span>
<span id="cb54-1380"><a href="#cb54-1380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1381"><a href="#cb54-1381" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> contract(adjacency_matrix, labels, limit):</span>
<span id="cb54-1382"><a href="#cb54-1382" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> labels.copy()</span>
<span id="cb54-1383"><a href="#cb54-1383" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(adjacency_matrix) <span class="op">&gt;</span> limit:</span>
<span id="cb54-1384"><a href="#cb54-1384" aria-hidden="true" tabindex="-1"></a>        n1, n2 <span class="op">=</span> pick_edge(adjacency_matrix)</span>
<span id="cb54-1385"><a href="#cb54-1385" aria-hidden="true" tabindex="-1"></a>        l1, l2 <span class="op">=</span> labels[n1], labels[n2]</span>
<span id="cb54-1386"><a href="#cb54-1386" aria-hidden="true" tabindex="-1"></a>        labels[n1] <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>l1<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>l2<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb54-1387"><a href="#cb54-1387" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> labels[n2]</span>
<span id="cb54-1388"><a href="#cb54-1388" aria-hidden="true" tabindex="-1"></a>        adjacency_matrix <span class="op">=</span> merge_indices([n1, n2], adjacency_matrix)</span>
<span id="cb54-1389"><a href="#cb54-1389" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> adjacency_matrix, labels</span>
<span id="cb54-1390"><a href="#cb54-1390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1391"><a href="#cb54-1391" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fastmincut(adjacency_matrix, labels):</span>
<span id="cb54-1392"><a href="#cb54-1392" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(adjacency_matrix) <span class="op">&lt;=</span> <span class="dv">6</span>:</span>
<span id="cb54-1393"><a href="#cb54-1393" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> contract(adjacency_matrix, labels, <span class="dv">2</span>)</span>
<span id="cb54-1394"><a href="#cb54-1394" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="bu">int</span>(np.ceil(<span class="dv">1</span> <span class="op">+</span> <span class="bu">len</span>(adjacency_matrix) <span class="op">/</span> np.sqrt(<span class="dv">2</span>)))</span>
<span id="cb54-1395"><a href="#cb54-1395" aria-hidden="true" tabindex="-1"></a>    c1, l1 <span class="op">=</span> contract(adjacency_matrix, labels, t)</span>
<span id="cb54-1396"><a href="#cb54-1396" aria-hidden="true" tabindex="-1"></a>    c2, l2 <span class="op">=</span> contract(adjacency_matrix, labels, t)</span>
<span id="cb54-1397"><a href="#cb54-1397" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(fastmincut(c1, l1), fastmincut(c2, l2), key<span class="op">=</span><span class="kw">lambda</span> x:x[<span class="dv">0</span>][<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb54-1398"><a href="#cb54-1398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1399"><a href="#cb54-1399" aria-hidden="true" tabindex="-1"></a>```</span>
<span id="cb54-1400"><a href="#cb54-1400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1401"><a href="#cb54-1401" aria-hidden="true" tabindex="-1"></a>Again, I was unable to get this to run <span class="kw">in</span> a reasonable amount of time.</span>
<span id="cb54-1402"><a href="#cb54-1402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1403"><a href="#cb54-1403" aria-hidden="true" tabindex="-1"></a>Finally, (based on having plotted the graph), spectral clustering seems like a nice approach to assign each node to one of two groups. Sklearn [implements this](https:<span class="op">//</span>scikit<span class="op">-</span>learn.org<span class="op">/</span>stable<span class="op">/</span>modules<span class="op">/</span>generated<span class="op">/</span>sklearn.cluster.SpectralClustering.html) <span class="cf">for</span> us, so we don<span class="st">'t even need to do anthing, or something.</span></span>
<span id="cb54-1404"><a href="#cb54-1404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1407"><a href="#cb54-1407" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1408"><a href="#cb54-1408" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> SpectralClustering</span>
<span id="cb54-1409"><a href="#cb54-1409" aria-hidden="true" tabindex="-1"></a>sc <span class="op">=</span> SpectralClustering(<span class="dv">2</span>, affinity<span class="op">=</span><span class="st">'precomputed'</span>, n_init<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb54-1410"><a href="#cb54-1410" aria-hidden="true" tabindex="-1"></a>                        assign_labels<span class="op">=</span><span class="st">'discretize'</span>)</span>
<span id="cb54-1411"><a href="#cb54-1411" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> sc.fit_predict(adjacency_matrix)</span>
<span id="cb54-1412"><a href="#cb54-1412" aria-hidden="true" tabindex="-1"></a>c1 <span class="op">=</span> np.where(fit <span class="op">==</span> <span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb54-1413"><a href="#cb54-1413" aria-hidden="true" tabindex="-1"></a>c2 <span class="op">=</span> np.where(fit <span class="op">==</span> <span class="dv">1</span>)[<span class="dv">0</span>]</span>
<span id="cb54-1414"><a href="#cb54-1414" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(c1) <span class="op">*</span> <span class="bu">len</span>(c2)</span>
<span id="cb54-1415"><a href="#cb54-1415" aria-hidden="true" tabindex="-1"></a>```</span>
<span id="cb54-1416"><a href="#cb54-1416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1417"><a href="#cb54-1417" aria-hidden="true" tabindex="-1"></a>With <span class="bu">all</span> that meandering out of the way, here<span class="st">'s my graph visualized,</span></span>
<span id="cb54-1418"><a href="#cb54-1418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1421"><a href="#cb54-1421" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1422"><a href="#cb54-1422" aria-hidden="true" tabindex="-1"></a><span class="co"># | eval: true</span></span>
<span id="cb54-1423"><a href="#cb54-1423" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb54-1424"><a href="#cb54-1424" aria-hidden="true" tabindex="-1"></a>centrality <span class="op">=</span> nx.betweenness_centrality(G)</span>
<span id="cb54-1425"><a href="#cb54-1425" aria-hidden="true" tabindex="-1"></a>nx.set_node_attributes(G, centrality, name<span class="op">=</span><span class="st">"centrality"</span>)</span>
<span id="cb54-1426"><a href="#cb54-1426" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G)</span>
<span id="cb54-1427"><a href="#cb54-1427" aria-hidden="true" tabindex="-1"></a>nx.set_node_attributes(G, pos, name<span class="op">=</span><span class="st">"pos"</span>)</span>
<span id="cb54-1428"><a href="#cb54-1428" aria-hidden="true" tabindex="-1"></a>```</span>
<span id="cb54-1429"><a href="#cb54-1429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1432"><a href="#cb54-1432" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb54-1433"><a href="#cb54-1433" aria-hidden="true" tabindex="-1"></a><span class="co"># | eval: true</span></span>
<span id="cb54-1434"><a href="#cb54-1434" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb54-1435"><a href="#cb54-1435" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "A lot of plotly code"</span></span>
<span id="cb54-1436"><a href="#cb54-1436" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.graph_objects <span class="im">as</span> go</span>
<span id="cb54-1437"><a href="#cb54-1437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1438"><a href="#cb54-1438" aria-hidden="true" tabindex="-1"></a>edge_x <span class="op">=</span> []</span>
<span id="cb54-1439"><a href="#cb54-1439" aria-hidden="true" tabindex="-1"></a>edge_y <span class="op">=</span> []</span>
<span id="cb54-1440"><a href="#cb54-1440" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> edge <span class="kw">in</span> G.edges():</span>
<span id="cb54-1441"><a href="#cb54-1441" aria-hidden="true" tabindex="-1"></a>    x0, y0 <span class="op">=</span> G.nodes[edge[<span class="dv">0</span>]][<span class="st">"pos"</span>]</span>
<span id="cb54-1442"><a href="#cb54-1442" aria-hidden="true" tabindex="-1"></a>    x1, y1 <span class="op">=</span> G.nodes[edge[<span class="dv">1</span>]][<span class="st">"pos"</span>]</span>
<span id="cb54-1443"><a href="#cb54-1443" aria-hidden="true" tabindex="-1"></a>    edge_x.append(x0)</span>
<span id="cb54-1444"><a href="#cb54-1444" aria-hidden="true" tabindex="-1"></a>    edge_x.append(x1)</span>
<span id="cb54-1445"><a href="#cb54-1445" aria-hidden="true" tabindex="-1"></a>    edge_x.append(<span class="va">None</span>)</span>
<span id="cb54-1446"><a href="#cb54-1446" aria-hidden="true" tabindex="-1"></a>    edge_y.append(y0)</span>
<span id="cb54-1447"><a href="#cb54-1447" aria-hidden="true" tabindex="-1"></a>    edge_y.append(y1)</span>
<span id="cb54-1448"><a href="#cb54-1448" aria-hidden="true" tabindex="-1"></a>    edge_y.append(<span class="va">None</span>)</span>
<span id="cb54-1449"><a href="#cb54-1449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1450"><a href="#cb54-1450" aria-hidden="true" tabindex="-1"></a>edge_trace <span class="op">=</span> go.Scatter(</span>
<span id="cb54-1451"><a href="#cb54-1451" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>edge_x,</span>
<span id="cb54-1452"><a href="#cb54-1452" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span>edge_y,</span>
<span id="cb54-1453"><a href="#cb54-1453" aria-hidden="true" tabindex="-1"></a>    line<span class="op">=</span><span class="bu">dict</span>(width<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">"#888"</span>),</span>
<span id="cb54-1454"><a href="#cb54-1454" aria-hidden="true" tabindex="-1"></a>    hoverinfo<span class="op">=</span><span class="st">"none"</span>,</span>
<span id="cb54-1455"><a href="#cb54-1455" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span><span class="st">"lines"</span>,</span>
<span id="cb54-1456"><a href="#cb54-1456" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-1457"><a href="#cb54-1457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1458"><a href="#cb54-1458" aria-hidden="true" tabindex="-1"></a>node_x <span class="op">=</span> []</span>
<span id="cb54-1459"><a href="#cb54-1459" aria-hidden="true" tabindex="-1"></a>node_y <span class="op">=</span> []</span>
<span id="cb54-1460"><a href="#cb54-1460" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> []</span>
<span id="cb54-1461"><a href="#cb54-1461" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label <span class="kw">in</span> G.nodes():</span>
<span id="cb54-1462"><a href="#cb54-1462" aria-hidden="true" tabindex="-1"></a>    node <span class="op">=</span> G.nodes[label]</span>
<span id="cb54-1463"><a href="#cb54-1463" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> node[<span class="st">"pos"</span>]</span>
<span id="cb54-1464"><a href="#cb54-1464" aria-hidden="true" tabindex="-1"></a>    node_x.append(x)</span>
<span id="cb54-1465"><a href="#cb54-1465" aria-hidden="true" tabindex="-1"></a>    node_y.append(y)</span>
<span id="cb54-1466"><a href="#cb54-1466" aria-hidden="true" tabindex="-1"></a>    colors.append(node[<span class="st">"centrality"</span>])</span>
<span id="cb54-1467"><a href="#cb54-1467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1468"><a href="#cb54-1468" aria-hidden="true" tabindex="-1"></a>node_trace <span class="op">=</span> go.Scatter(</span>
<span id="cb54-1469"><a href="#cb54-1469" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>node_x,</span>
<span id="cb54-1470"><a href="#cb54-1470" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span>node_y,</span>
<span id="cb54-1471"><a href="#cb54-1471" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span><span class="st">"markers"</span>,</span>
<span id="cb54-1472"><a href="#cb54-1472" aria-hidden="true" tabindex="-1"></a>    hoverinfo<span class="op">=</span><span class="st">"text"</span>,</span>
<span id="cb54-1473"><a href="#cb54-1473" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span><span class="bu">dict</span>(</span>
<span id="cb54-1474"><a href="#cb54-1474" aria-hidden="true" tabindex="-1"></a>        showscale<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb54-1475"><a href="#cb54-1475" aria-hidden="true" tabindex="-1"></a>        colorscale<span class="op">=</span><span class="st">"Viridis"</span>,</span>
<span id="cb54-1476"><a href="#cb54-1476" aria-hidden="true" tabindex="-1"></a>        reversescale<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb54-1477"><a href="#cb54-1477" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span>colors,</span>
<span id="cb54-1478"><a href="#cb54-1478" aria-hidden="true" tabindex="-1"></a>        size<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb54-1479"><a href="#cb54-1479" aria-hidden="true" tabindex="-1"></a>        colorbar<span class="op">=</span><span class="bu">dict</span>(</span>
<span id="cb54-1480"><a href="#cb54-1480" aria-hidden="true" tabindex="-1"></a>            thickness<span class="op">=</span><span class="dv">15</span>,</span>
<span id="cb54-1481"><a href="#cb54-1481" aria-hidden="true" tabindex="-1"></a>            title<span class="op">=</span><span class="bu">dict</span>(text<span class="op">=</span><span class="st">"Node Connections"</span>, side<span class="op">=</span><span class="st">"right"</span>),</span>
<span id="cb54-1482"><a href="#cb54-1482" aria-hidden="true" tabindex="-1"></a>            xanchor<span class="op">=</span><span class="st">"left"</span>,</span>
<span id="cb54-1483"><a href="#cb54-1483" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb54-1484"><a href="#cb54-1484" aria-hidden="true" tabindex="-1"></a>        line_width<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb54-1485"><a href="#cb54-1485" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb54-1486"><a href="#cb54-1486" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-1487"><a href="#cb54-1487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-1488"><a href="#cb54-1488" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> go.Figure(data<span class="op">=</span>[edge_trace, node_trace],</span>
<span id="cb54-1489"><a href="#cb54-1489" aria-hidden="true" tabindex="-1"></a>             layout<span class="op">=</span>go.Layout(</span>
<span id="cb54-1490"><a href="#cb54-1490" aria-hidden="true" tabindex="-1"></a>                showlegend<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb54-1491"><a href="#cb54-1491" aria-hidden="true" tabindex="-1"></a>                hovermode<span class="op">=</span><span class="st">'closest'</span>,</span>
<span id="cb54-1492"><a href="#cb54-1492" aria-hidden="true" tabindex="-1"></a>                margin<span class="op">=</span><span class="bu">dict</span>(b<span class="op">=</span><span class="dv">20</span>,l<span class="op">=</span><span class="dv">5</span>,r<span class="op">=</span><span class="dv">5</span>,t<span class="op">=</span><span class="dv">40</span>),</span>
<span id="cb54-1493"><a href="#cb54-1493" aria-hidden="true" tabindex="-1"></a>                xaxis<span class="op">=</span><span class="bu">dict</span>(showgrid<span class="op">=</span><span class="va">False</span>, zeroline<span class="op">=</span><span class="va">False</span>, showticklabels<span class="op">=</span><span class="va">False</span>),</span>
<span id="cb54-1494"><a href="#cb54-1494" aria-hidden="true" tabindex="-1"></a>                yaxis<span class="op">=</span><span class="bu">dict</span>(showgrid<span class="op">=</span><span class="va">False</span>, zeroline<span class="op">=</span><span class="va">False</span>, showticklabels<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb54-1495"><a href="#cb54-1495" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb54-1496"><a href="#cb54-1496" aria-hidden="true" tabindex="-1"></a>fig.show()</span>
<span id="cb54-1497"><a href="#cb54-1497" aria-hidden="true" tabindex="-1"></a>```</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../index.html">Front page</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/cutonbuminband/AOC">Github</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



</body></html>